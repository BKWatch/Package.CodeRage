<?php
/* AUTOMATICALLY GENERATED BY CODERAGE TOOLS - DO NOT EDIT */
/* 2018-08-15T15:36:32-04:00 */
/* Copyright CodeRage */
namespace Makeme;

class Config {
	public function hasProperty($n) { return false; }
	public function getProperty($n, $d = null) { return $d; }
	public static function current() { return new Config; }
}

namespace Makeme\Build;

class Resource_ {
	static function listFiles(\Makeme\Build\Run $run)
	{
		return [
				   'CodeRage-3.0.php', 'CodeRage.php', 'CodeRage.pm', 'builddb',
				   'builddb.bat', 'builddb.php', 'decode-id', 'encode-id',
				   'makeme', 'makeme.bat', 'project.xsd', 'run-coderage',
				   'run-coderage.bat'
			   ];
	}
	static function load(\Makeme\Build\Run $run, $file)
	{
		$content = null;
		switch($file) {
		case 'CodeRage-3.0.php':
			$content = <<< __ENDRESOURCE__
				PD9waHAKCnJlcXVpcmVfb25jZShfX0RJUl9fIC4gJy9Db2RlUmFnZS5waHAnKTsK
__ENDRESOURCE__;
			break;
		case 'CodeRage.php':
			$content = <<< __ENDRESOURCE__
				PD9waHAKCi8qKgogKiBEZWZpbmVzIHRoZSBjbGFzcyBDb2RlUmFnZVxDb25maWcg
				YW5kIHRoZSBmdW5jdGlvbiBhdXRvbG9hZCgpCiAqCiAqIEZpbGU6ICAgICAgICBD
				b2RlUmFnZS9CdWlsZC9SZXNvdXJjZS9Db2RlUmFnZS5waHAKICogRGF0ZTogICAg
				ICAgIFdlZCBEZWMgMzEgMTQ6MjU6NTkgTVNUIDIwMDgKICogTm90aWNlOiAgICAg
				IFRoaXMgZG9jdW1lbnQgY29udGFpbnMgY29uZmlkZW50aWFsIGluZm9ybWF0aW9u
				CiAqICAgICAgICAgICAgICBhbmQgdHJhZGUgc2VjcmV0cwogKgogKiBAY29weXJp
				Z2h0ICAgMjAxNSBDb3Vuc2VsTm93LCBMTEMKICogQGF1dGhvciAgICAgIEpvbmF0
				aGFuIFR1cmthbmlzCiAqIEBsaWNlbnNlICAgICBBbGwgcmlnaHRzIHJlc2VydmVk
				CiAqLwoKbmFtZXNwYWNlIENvZGVSYWdlOwoKdXNlIEV4Y2VwdGlvbjsKCi8qKgog
				KiBQcm92aWRlcyBhY2Nlc3MgdG8gY29uZmlndXJhdGlvbiB2YXJpYWJsZXMKICov
				CmZpbmFsIGNsYXNzIENvbmZpZyB7CgogICAgLyoqCiAgICAgKiBAdmFyIHN0cmlu
				ZwogICAgICovCiAgICBjb25zdCBERUZBVUxUX1RPT0xTX1JPT1QgPSAnL3Vzci9z
				aGFyZS9Db2RlUmFnZS0zLjAnOwoKICAgIC8qKgogICAgICogQHZhciBzdHJpbmcK
				ICAgICAqLwogICAgY29uc3QgQ09NUE9TRVJfQVVUT0xPQURfUEFUSCA9ICcuY29k
				ZXJhZ2UvY29tcG9zZXIvYXV0b2xvYWQucGhwJzsKCiAgICAvKioKICAgICAqIENv
				bnNydHJ1Y3RzIGFuIGluc3RhbmNlIG9mIENvZGVSYWdlXENvbmZpZwogICAgICoK
				ICAgICAqIEBwYXJhbSBhcnJheSAkcHJvcGVydGllcyBUaGUgYXNzb2NpYXRpdmUg
				YXJyYXkgb2YgcHJvcGVydGllczsgaWYgb21pdHRlZCwKICAgICAqICAgdGhlIHBy
				b3BlcnRpeSB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgZnJvbSB0aGUgcHJvamVjdCBj
				b25maWd1cmF0aW9uOyBtYXkKICAgICAqICAgbm90IHNwZWNpZnkgdmFsdWVzIGZv
				ciB0aGUgcHJvcGVydGllcyAicHJvamVjdF9yb290IiBvciAidG9vbHNfcm9vdCIK
				ICAgICAqIEBwYXJhbSBDb2RlUmFnZVxDb25maWcgJGRlZmF1bHQgQW4gaW5zdGFu
				Y2Ugb2YgQ29kZVJhZ2VcQ29uZmlnIHdob3NlCiAgICAgKiAgIGNvbGxlY3Rpb24g
				b2YgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgdG8gc3VwcGx5IHZhbHVlcyBmb3Ig
				cHJvcGVydGllcwogICAgICogICBub3QgZGVmaW5lZCBpbiAkcHJvcGVydGllczsg
				aWdub3JlZCBpZiAkcHJvcGVydGllcyBpcyBudWxsCiAgICAgKiBAdGhyb3dzIEV4
				Y2VwdGlvbiBpZiAkcHJvcGVydGllcyBvciAkZGVmYXVsdCBpcyBpbnZhbGlkCiAg
				ICAgKi8KICAgIHB1YmxpYyBmdW5jdGlvbiBfX2NvbnN0cnVjdCgkcHJvcGVydGll
				cyA9IG51bGwsICRkZWZhdWx0ID0gbnVsbCkKICAgIHsKICAgICAgICBpZiAoc2Vs
				Zjo6JHZhbHVlcyA9PT0gbnVsbCkKICAgICAgICAgICAgc2VsZjo6bG9hZCgpOwog
				ICAgICAgIGlmICgkcHJvcGVydGllcyAhPT0gbnVsbCkgewogICAgICAgICAgICBp
				ZiAoIWlzX2FycmF5KCRwcm9wZXJ0aWVzKSkKICAgICAgICAgICAgICAgIHRocm93
				IG5ldwogICAgICAgICAgICAgICAgICAgIEV4Y2VwdGlvbigKICAgICAgICAgICAg
				ICAgICAgICAgICAgJ0ludmFsaWQgcHJvcGVydGllcyBhcnJheTogZXhwZWN0ZWQg
				YXJyYXk7IGZvdW5kICcgLgogICAgICAgICAgICAgICAgICAgICAgICBzZWxmOjpn
				ZXRUeXBlKCRwcm9wZXJ0aWVzKQogICAgICAgICAgICAgICAgICAgICk7CiAgICAg
				ICAgICAgIGlmIChhcnJheV9rZXlfZXhpc3RzKCdwcm9qZWN0X3Jvb3QnLCAkcHJv
				cGVydGllcykpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdJ
				bnZhbGlkIHByb3BlcnR5IG5hbWU6IHByb2plY3Rfcm9vdCcpOwogICAgICAgICAg
				ICBpZiAoYXJyYXlfa2V5X2V4aXN0cygndG9vbHNfcm9vdCcsICRwcm9wZXJ0aWVz
				KSkKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ0ludmFsaWQg
				cHJvcGVydHkgbmFtZTogdG9vbHNfcm9vdCcpOwogICAgICAgICAgICBmb3JlYWNo
				ICgkcHJvcGVydGllcyBhcyAkbiA9PiAkdikKICAgICAgICAgICAgICAgIGlmICgh
				aXNfc3RyaW5nKCR2KSkKICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcKICAg
				ICAgICAgICAgICAgICAgICAgICAgRXhjZXB0aW9uKAogICAgICAgICAgICAgICAg
				ICAgICAgICAgICAgJ0ludmFsaWQgcHJvcGVydHkgdmFsdWU6IGV4cGVjdGVkIHN0
				cmluZzsgZm91bmQgJyAuCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxm
				OjpnZXRUeXBlKCR2KQogICAgICAgICAgICAgICAgICAgICAgICApOwogICAgICAg
				ICAgICBpZiAoJGRlZmF1bHQgIT09IG51bGwpIHsKICAgICAgICAgICAgICAgIGlm
				ICghJGRlZmF1bHQgaW5zdGFuY2VvZiBDb25maWcpCiAgICAgICAgICAgICAgICAg
				ICAgdGhyb3cgbmV3CiAgICAgICAgICAgICAgICAgICAgICAgIEV4Y2VwdGlvbigK
				ICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIGRlZmF1bHQgY29u
				ZmlndXJhdGlvbjogZXhwZWN0ZWQgJyAuCiAgICAgICAgICAgICAgICAgICAgICAg
				ICAgICAnQ29kZVJhZ2VcXENvbmZpZzsgZm91bmQgJyAuCiAgICAgICAgICAgICAg
				ICAgICAgICAgICAgICBzZWxmOjpnZXRUeXBlKCRkZWZhdWx0KQogICAgICAgICAg
				ICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgJHRoaXMtPnByb3BlcnRp
				ZXMgPSAkcHJvcGVydGllcyArICRkZWZhdWx0LT5wcm9wZXJ0aWVzOwogICAgICAg
				ICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgJHByb3BlcnRpZXNbJ3Byb2pl
				Y3Rfcm9vdCddID0gc2VsZjo6JHZhbHVlc1sncHJvamVjdF9yb290J107CiAgICAg
				ICAgICAgICAgICAkcHJvcGVydGllc1sndG9vbHNfcm9vdCddID0gc2VsZjo6JHZh
				bHVlc1sndG9vbHNfcm9vdCddOwogICAgICAgICAgICAgICAgJHRoaXMtPnByb3Bl
				cnRpZXMgPSAkcHJvcGVydGllczsKCiAgICAgICAgICAgIH0KICAgICAgICB9IGVs
				c2UgewogICAgICAgICAgICAkdGhpcy0+cHJvcGVydGllcyA9IHNlbGY6OiR2YWx1
				ZXM7CiAgICAgICAgfQogICAgICAgICR0aGlzLT5idWlsdGluID0gJHByb3BlcnRp
				ZXMgPT09IG51bGw7CiAgICB9CgogICAgICAgIC8qCiAgICAgICAgICogTWV0aG9k
				cyBmb3IgYWNjZXNzaW5nIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcwogICAgICAg
				ICAqLwoKICAgIC8qKgogICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBuYW1lZCBj
				b25maWd1cmF0aW9uIHZhcmlhYmxlIGhhcyBiZWVuIGFzc2lnbmVkIGEKICAgICAq
				IHZhbHVlCiAgICAgKgogICAgICogQHBhcmFtIHN0cmluZyAkbmFtZSBBIGNvbmZp
				Z3VyYXRpb24gdmFyaWFibGUgbmFtZQogICAgICogQHJldHVybiBib29sZWFuCiAg
				ICAgKi8KICAgIHB1YmxpYyBmdW5jdGlvbiBoYXNQcm9wZXJ0eSgkbmFtZSkKICAg
				IHsKICAgICAgICByZXR1cm4gaXNzZXQoJHRoaXMtPnByb3BlcnRpZXNbJG5hbWVd
				KTsKICAgIH0KCiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRo
				ZSBuYW1lZCBjb25maWd1cmF0aW9uIHZhcmlhYmxlLCBvciB0aGUgZ2l2ZW4KICAg
				ICAqIGRlZmF1bHQgdmFsdWUgaXMgdGhlIHZhcmlhYmxlIGlzIG5vdCBzZXQKICAg
				ICAqCiAgICAgKiBAcGFyYW0gc3RyaW5nICRuYW1lIEEgY29uZmlndXJhdGlvbiB2
				YXJpYWJsZSBuYW1lCiAgICAgKiBAcGFyYW0gc3RyaW5nICRkZWZhdWx0IFRoZSBk
				ZWZhdWx0IHZhbHVlCiAgICAgKiBAcmV0dXJuIHN0cmluZwogICAgICovCiAgICBw
				dWJsaWMgZnVuY3Rpb24gZ2V0UHJvcGVydHkoJG5hbWUsICRkZWZhdWx0ID0gbnVs
				bCkKICAgIHsKICAgICAgICByZXR1cm4gYXJyYXlfa2V5X2V4aXN0cygkbmFtZSwg
				JHRoaXMtPnByb3BlcnRpZXMpID8KICAgICAgICAgICAgJHRoaXMtPnByb3BlcnRp
				ZXNbJG5hbWVdIDoKICAgICAgICAgICAgJGRlZmF1bHQ7CiAgICB9CgogICAgLyoq
				CiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgY29uZmlndXJh
				dGlvbiB2YXJpYWJsZSwgdGhyb3dpbmcgYW4KICAgICAqIGV4Y2VwdGlvbiBpZiBp
				dCBpcyBub3Qgc2V0CiAgICAgKgogICAgICogQHBhcmFtIHN0cmluZyAkbmFtZSBB
				IGNvbmZpZ3VyYXRpb24gdmFyaWFibGUgbmFtZQogICAgICogQHJldHVybiBzdHJp
				bmcKICAgICAqIEB0aHJvd3MgRXhjZXB0aW9uIGlmIHRoZSB2YXJpYWJsZSBpcyBu
				b3Qgc2V0CiAgICAgKi8KICAgIHB1YmxpYyBmdW5jdGlvbiBnZXRSZXF1aXJlZFBy
				b3BlcnR5KCRuYW1lKQogICAgewogICAgICAgIGlmICghYXJyYXlfa2V5X2V4aXN0
				cygkbmFtZSwgJHRoaXMtPnByb3BlcnRpZXMpKQogICAgICAgICAgICB0aHJvdyBu
				ZXcgRXhjZXB0aW9uKCJUaGUgY29uZmlnIHZhcmlhYmxlICckbmFtZScgaXMgbm90
				IHNldCIpOwogICAgICAgIHJldHVybiAkdGhpcy0+cHJvcGVydGllc1skbmFtZV07
				CiAgICB9CgogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgbmFt
				ZXMgb2YgYWxsIGNvbmZpZ3VyYXRpb24gdmFyaWFibGVzCiAgICAgKgogICAgICog
				QHJldHVybiBhcnJheQogICAgICovCiAgICBwdWJsaWMgZnVuY3Rpb24gcHJvcGVy
				dHlOYW1lcygpCiAgICB7CiAgICAgICAgcmV0dXJuIGFycmF5X2tleXMoJHRoaXMt
				PnByb3BlcnRpZXMpOwogICAgfQoKICAgIC8qKgogICAgICogUmV0dXJucyB0cnVl
				IGlmIHRoaXMgaW5zdGFuY2UgaXMgYSBjb3B5IG9mIHRoZSBwcm9qZWN0IGNvbmZp
				Z3VyYXRpb24KICAgICAqCiAgICAgKiBAcmV0dXJuIGJvb2xlYW4KICAgICAqLwog
				ICAgcHVibGljIGZ1bmN0aW9uIGJ1aWx0aW4oKSB7IHJldHVybiAkdGhpcy0+YnVp
				bHRpbjsgfQoKICAgICAgICAvKgogICAgICAgICAqIE1ldGhvZHMgZm9yIGFjY2Vz
				c2luZyB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uCiAgICAgICAgICovCgogICAg
				LyoqCiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24KICAg
				ICAqCiAgICAgKiBAcmV0dXJuIENvZGVSYWdlXENvbmZpZwogICAgICovCiAgICBw
				dWJsaWMgc3RhdGljIGZ1bmN0aW9uIGN1cnJlbnQoKQogICAgewogICAgICAgIGlm
				IChzZWxmOjokY3VycmVudCA9PT0gbnVsbCkKICAgICAgICAgICAgc2VsZjo6JGN1
				cnJlbnQgPSBuZXcgQ29uZmlnOwogICAgICAgIHJldHVybiBzZWxmOjokY3VycmVu
				dDsKICAgIH0KCiAgICAvKioKICAgICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGNv
				bmZpZ3VyYXRpb24KICAgICAqCiAgICAgKiBAcGFyYW0gQ29kZVJhZ2VcQ29uZmln
				ICRjdXJyZW50IFRoZSBuZXcgY29uZmlndXJhdGlvbgogICAgICogQHJldHVybiBD
				b2RlUmFnZVxDb25maWcgVGhlIHByZXZpb3VzIGNvbmZpZ3VyYXRpb24KICAgICAq
				LwogICAgcHVibGljIHN0YXRpYyBmdW5jdGlvbiBzZXRDdXJyZW50KENvbmZpZyAk
				Y3VycmVudCkKICAgIHsKICAgICAgICBpZiAoISRjdXJyZW50IGluc3RhbmNlb2Yg
				Q29uZmlnKQogICAgICAgICAgICB0aHJvdyBuZXcKICAgICAgICAgICAgICAgIEV4
				Y2VwdGlvbigKICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBjb25maWd1cmF0
				aW9uOiBleHBlY3RlZCBDb2RlUmFnZVxDb25maWc7IGZvdW5kICcgLgogICAgICAg
				ICAgICAgICAgICAgIHNlbGY6OmdldFR5cGUoJGN1cnJlbnQpCiAgICAgICAgICAg
				ICAgICApOwogICAgICAgICRwcmV2ID0gc2VsZjo6JGN1cnJlbnQ7CiAgICAgICAg
				c2VsZjo6JGN1cnJlbnQgPSAkY3VycmVudDsKICAgICAgICByZXR1cm4gJHByZXY7
				CiAgICB9CgogICAgICAgIC8qCiAgICAgICAgICogTWV0aG9kIGNhbGxlZCBieSB0
				aGUgc3lzdGVtIGF0IGluaXRpYWxpemF0aW9uCiAgICAgICAgICovCgogICAgLyoq
				CiAgICAgKiBTZXRzIHRoZSBwcm9qZWN0IHJvb3QgZGlyZWN0b3J5CiAgICAgKi8K
				ICAgIHB1YmxpYyBzdGF0aWMgZnVuY3Rpb24gYm9vdHN0cmFwKCkKICAgIHsKICAg
				ICAgICAvLyBCb290c3RyYXAgYXQgbW9zdCBvbmNlCiAgICAgICAgc3RhdGljICRi
				b290c3RyYXBwZWQgPSBmYWxzZTsKICAgICAgICBpZiAoJGJvb3RzdHJhcHBlZCkK
				ICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICRib290c3RyYXBwZWQgPSB0cnVl
				OwoKICAgICAgICAvLyBTZWFyY2ggZm9yIHJvb3QgZGlyZWN0b3J5CiAgICAgICAg
				aWYgKGlzc2V0KCRfRU5WWydDT0RFUkFHRV9QUk9KRUNUX1JPT1QnXSkpIHsKICAg
				ICAgICAgICAgc2VsZjo6JHByb2plY3RSb290ID0gJF9FTlZbJ0NPREVSQUdFX1BS
				T0pFQ1RfUk9PVCddOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICRjdXIg
				PSAnJzsKICAgICAgICAgICAgJG5leHQgPSBnZXRjd2QoKTsKICAgICAgICAgICAg
				d2hpbGUgKCAkY3VyICE9ICRuZXh0ICYmCiAgICAgICAgICAgICAgICAgICAgIWlz
				X2ZpbGUoIiRuZXh0L3Byb2plY3QueG1sIikgJiYKICAgICAgICAgICAgICAgICAg
				ICAhaXNfZmlsZSgiJG5leHQvcHJvamVjdC5pbmkiKSApCiAgICAgICAgICAgIHsK
				ICAgICAgICAgICAgICAgICRjdXIgPSAkbmV4dDsKICAgICAgICAgICAgICAgICRu
				ZXh0ID0gZGlybmFtZSgkbmV4dCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAg
				aWYgKCRjdXIgIT0gJG5leHQpCiAgICAgICAgICAgICAgICBzZWxmOjokcHJvamVj
				dFJvb3QgPSByZWFscGF0aCgkbmV4dCk7CiAgICAgICAgfQoKICAgICAgICAvLyBM
				b2FkIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MKICAgICAgICBzZWxmOjpsb2FkKCk7
				CgogICAgICAgIC8vIEFkZCBwcm9qZWN0IHJvb3QgYW5kIHRvb2xzIHJvb3QgdG8g
				aW5jbHVkZSBwYXRoCiAgICAgICAgJGluYyA9IGV4cGxvZGUoUEFUSF9TRVBBUkFU
				T1IsIGluaV9nZXQoJ2luY2x1ZGVfcGF0aCcpKTsKICAgICAgICAkY29uZmlnID0g
				Q29uZmlnOjpjdXJyZW50KCk7CiAgICAgICAgJHRvb2xzID0gJGNvbmZpZy0+Z2V0
				UmVxdWlyZWRQcm9wZXJ0eSgndG9vbHNfcm9vdCcpOwogICAgICAgIGlmICghaW5f
				YXJyYXkoJHRvb2xzLCAkaW5jKSkKICAgICAgICAgICAgYXJyYXlfdW5zaGlmdCgk
				aW5jLCAkdG9vbHMpOwogICAgICAgIGlmIChzZWxmOjokcHJvamVjdFJvb3QgIT09
				IG51bGwpIHsKICAgICAgICAgICAgaWYgKCFpbl9hcnJheShzZWxmOjokcHJvamVj
				dFJvb3QsICRpbmMpKQogICAgICAgICAgICAgICAgYXJyYXlfdW5zaGlmdCgkaW5j
				LCBzZWxmOjokcHJvamVjdFJvb3QpOwogICAgICAgICAgICAkYXV0b2xvYWQgPSBz
				ZWxmOjokcHJvamVjdFJvb3QgLiAnLycgLiBzZWxmOjpDT01QT1NFUl9BVVRPTE9B
				RF9QQVRIOwogICAgICAgICAgICBpZiAoZmlsZV9leGlzdHMoJGF1dG9sb2FkKSAm
				JiBpc19maWxlKCRhdXRvbG9hZCkpCiAgICAgICAgICAgICAgICByZXF1aXJlKCRh
				dXRvbG9hZCk7CiAgICAgICAgfQogICAgICAgIGluaV9zZXQoJ2luY2x1ZGVfcGF0
				aCcsIGpvaW4oUEFUSF9TRVBBUkFUT1IsICRpbmMpKTsKCiAgICAgICAgLy8gUmVn
				aXN0ZXIgYXV0b2xvYWQKICAgICAgICBzcGxfYXV0b2xvYWRfcmVnaXN0ZXIoJ0Nv
				ZGVSYWdlXGF1dG9sb2FkJywgdHJ1ZSwgdHJ1ZSk7CiAgICB9CgogICAgICAgIC8q
				CiAgICAgICAgICogRGVwcmVjYXRlZCBpbnRlcmZhY2UKICAgICAgICAgKi8KCiAg
				ICAvKioKICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbmFtZWQgY29uZmlndXJh
				dGlvbiB2YXJpYWJsZSBoYXMgYmVlbiBhc3NpZ25lZCBhCiAgICAgKiB2YWx1ZSAo
				cG9zc2libHkgbnVsbCkKICAgICAqCiAgICAgKiBAcGFyYW0gc3RyaW5nICRuYW1l
				IEEgY29uZmlndXJhdGlvbiB2YXJpYWJsZSBuYW1lCiAgICAgKiBAcmV0dXJuIGJv
				b2xlYW4KICAgICAqIEBkZXByZWNhdGVkCiAgICAgKi8KICAgIHB1YmxpYyBzdGF0
				aWMgZnVuY3Rpb24gZGVmaW5lZCgkbmFtZSkKICAgIHsKICAgICAgICBzZWxmOjpk
				ZXByZWNhdGVkKCk7CiAgICAgICAgaWYgKHNlbGY6OiR2YWx1ZXMgPT09IG51bGwp
				CiAgICAgICAgICAgIHNlbGY6OmxvYWQoKTsKICAgICAgICByZXR1cm4gYXJyYXlf
				a2V5X2V4aXN0cygkbmFtZSwgc2VsZjo6JHZhbHVlcyk7CiAgICB9CgogICAgLyoq
				CiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgY29uZmlndXJh
				dGlvbiB2YXJpYWJsZQogICAgICoKICAgICAqIEBwYXJhbSBzdHJpbmcgJG5hbWUK
				ICAgICAqIEByZXR1cm4gbWl4ZWQKICAgICAqIEB0aHJvd3MgRXhjZXB0aW9uIGlm
				IHRoZSB2YXJpYWJsZSBoYXMgbm90IGJlZW4gc2V0CiAgICAgKiBAZGVwcmVjYXRl
				ZAogICAgICovCiAgICBwdWJsaWMgc3RhdGljIGZ1bmN0aW9uIGdldCgkbmFtZSkK
				ICAgIHsKICAgICAgICBzZWxmOjpkZXByZWNhdGVkKCk7CiAgICAgICAgaWYgKHNl
				bGY6OiR2YWx1ZXMgPT09IG51bGwpCiAgICAgICAgICAgIHNlbGY6OmxvYWQoKTsK
				ICAgICAgICBpZiAoIWFycmF5X2tleV9leGlzdHMoJG5hbWUsIHNlbGY6OiR2YWx1
				ZXMpKQogICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCJUaGUgY29uZmln
				IHZhcmlhYmxlICckbmFtZScgaXMgbm90IHNldCIpOwogICAgICAgIHJldHVybiBz
				ZWxmOjokdmFsdWVzWyRuYW1lXTsKICAgIH0KCiAgICAvKioKICAgICAqIFJldHVy
				bnMgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBjb25maWd1cmF0aW9uIHZhcmlhYmxl
				LCBpZiBpdCBoYXMgYmVlbgogICAgICogc2V0LCBhbmQgdGhlIHNwZWNpZmllZCBk
				ZWZhdWx0IHZhbHVlIG90aGVyd2lzZQogICAgICoKICAgICAqIEBwYXJhbSBzdHJp
				bmcgJG5hbWUgVGhlIHZhcmlhYmxlIG5hbWUKICAgICAqIEBwYXJhbSBtaXhlZCAk
				ZGVmYXVsdCBUaGUgZGVmYXVsdCB2YWx1ZQogICAgICogQHJldHVybiBtaXhlZAog
				ICAgICogQGRlcHJlY2F0ZWQKICAgICAqLwogICAgcHVibGljIHN0YXRpYyBmdW5j
				dGlvbiBnZXRJZigkbmFtZSwgJGRlZmF1bHQgPSBudWxsKQogICAgewogICAgICAg
				IHNlbGY6OmRlcHJlY2F0ZWQoKTsKICAgICAgICBpZiAoc2VsZjo6JHZhbHVlcyA9
				PT0gbnVsbCkKICAgICAgICAgICAgc2VsZjo6bG9hZCgpOwogICAgICAgIHJldHVy
				biBhcnJheV9rZXlfZXhpc3RzKCRuYW1lLCBzZWxmOjokdmFsdWVzKSA/CiAgICAg
				ICAgICAgIHNlbGY6OiR2YWx1ZXNbJG5hbWVdIDoKICAgICAgICAgICAgJGRlZmF1
				bHQ7CiAgICB9CgogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUg
				bmFtZXMgb2YgYWxsIGNvbmZpZ3VyYXRpb24gdmFyaWFibGVzCiAgICAgKgogICAg
				ICogQHJldHVybiBhcnJheQogICAgICogQGRlcHJlY2F0ZWQKICAgICAqLwogICAg
				cHVibGljIHN0YXRpYyBmdW5jdGlvbiBwcm9wZXJ0aWVzKCkKICAgIHsKICAgICAg
				ICBzZWxmOjpkZXByZWNhdGVkKCk7CiAgICAgICAgaWYgKHNlbGY6OiR2YWx1ZXMg
				PT09IG51bGwpCiAgICAgICAgICAgIHNlbGY6OmxvYWQoKTsKICAgICAgICByZXR1
				cm4gYXJyYXlfa2V5cyhzZWxmOjokdmFsdWVzKTsKICAgIH0KCiAgICAvKioKICAg
				ICAqIENhdXNlcyBjb25maWd1cmF0aW9uIHNldHRpbmdzIHRvIGJlIHJlbG9hZGVk
				IHVwb24gbmV4dCBhY2Nlc3MKICAgICAqCiAgICAgKiBAZGVwcmVjYXRlZAogICAg
				ICovCiAgICBwdWJsaWMgc3RhdGljIGZ1bmN0aW9uIGNsZWFyKCkKICAgIHsKICAg
				ICAgICBzZWxmOjokdmFsdWVzID0gc2VsZjo6JGN1cnJlbnQgPSBudWxsOwogICAg
				fQoKICAgIC8qKgogICAgICogTG9hZHMgY29uZmlndXJhdGlvbiBzZXR0aW5ncwog
				ICAgICovCiAgICBwcml2YXRlIHN0YXRpYyBmdW5jdGlvbiBsb2FkKCkKICAgIHsK
				ICAgICAgICBzZWxmOjokdmFsdWVzID0gW107CiAgICAgICAgc2VsZjo6JHZhbHVl
				c1sncHJvamVjdF9yb290J10gPSBzZWxmOjokcHJvamVjdFJvb3Q7CiAgICAgICAg
				c2VsZjo6JHZhbHVlc1sndG9vbHNfcm9vdCddID0gaXNzZXQoJF9FTlZbJ0NPREVS
				QUdFX1RPT0xTX1JPT1QnXSkgPwogICAgICAgICAgICAkX0VOVlsnQ09ERVJBR0Vf
				VE9PTFNfUk9PVCddIDoKICAgICAgICAgICAgc2VsZjo6REVGQVVMVF9UT09MU19S
				T09UOwogICAgICAgIGlmICggc2VsZjo6JHByb2plY3RSb290ICE9PSBudWxsICYm
				CiAgICAgICAgICAgICBmaWxlX2V4aXN0cyhzZWxmOjokcHJvamVjdFJvb3QgLiAn
				Ly5jb2RlcmFnZS9jb25maWcucGhwJykgKQogICAgICAgIHsKICAgICAgICAgICAg
				aW5jbHVkZShzZWxmOjokcHJvamVjdFJvb3QgLiAnLy5jb2RlcmFnZS9jb25maWcu
				cGhwJyk7CiAgICAgICAgICAgIGZvcmVhY2ggKCRjb25maWcgYXMgJG4gPT4gJHYp
				CiAgICAgICAgICAgICAgICBzZWxmOjokdmFsdWVzWyRuXSA9ICR2OwogICAgICAg
				IH0KICAgIH0KCiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhl
				IGdpdmVuIHZhbHVlLCBmb3IgdXNlIGluIGVycm9yIG1lc3NhZ2VzCiAgICAgKgog
				ICAgICogQHBhcmFtIG1peGVkICR2YWx1ZSBUaGUgdmFsdWUKICAgICAqIEByZXR1
				cm4gc3RyaW5nCiAgICAgKi8KICAgIHByaXZhdGUgc3RhdGljIGZ1bmN0aW9uIGdl
				dFR5cGUoJHZhbHVlKQogICAgewogICAgICAgIHJldHVybiBpc19vYmplY3QoJHZh
				bHVlKSA/IGdldF9jbGFzcygkdmFsdWUpIDogZ2V0dHlwZSgkdmFsdWUpOwogICAg
				fQoKICAgIC8qKgogICAgICogVHJpZ2dlcnMgYW4gZXJyb3Igd2l0aCBlcnJvciBs
				ZXZlbCBFX1VTRVJfREVQUkVDQVRFRAogICAgICovCiAgICBwcml2YXRlIHN0YXRp
				YyBmdW5jdGlvbiBkZXByZWNhdGVkKCkKICAgIHsKICAgICAgICAkdHJhY2UgPSBk
				ZWJ1Z19iYWNrdHJhY2UoREVCVUdfQkFDS1RSQUNFX0lHTk9SRV9BUkdTLCAyKTsK
				ICAgICAgICAkbWVzc2FnZSA9ICJDb2RlUmFnZVxcQ29uZmlnOjp7JHRyYWNlWzFd
				WydmdW5jdGlvbiddfSBpcyBkZXByZWNhdGVkIjsKICAgICAgICB0cmlnZ2VyX2Vy
				cm9yKCRtZXNzYWdlLCBFX1VTRVJfREVQUkVDQVRFRCk7CiAgICB9CgogICAgLyoq
				CiAgICAgKiBUaGUgcHJvamVjdCByb290IGRpcmVjdG9yeQogICAgICoKICAgICAq
				IEB2YXIgc3RyaW5nCiAgICAgKi8KICAgIHByaXZhdGUgc3RhdGljICRwcm9qZWN0
				Um9vdDsKCiAgICAvKioKICAgICAqIEFzc29jaWF0aXZlIGFycmF5IG1hcHBpbmcg
				Y29uZmlndXJhdGlvbiB2YXJpYWJsZSBuYW1lcyB0byB2YWx1ZXMuCiAgICAgKgog
				ICAgICogQHZhciBhcnJheQogICAgICovCiAgICBwcml2YXRlIHN0YXRpYyAkdmFs
				dWVzOwoKICAgIC8qKgogICAgICogVGhlIGN1cnJlbnRseSBpbnN0YWxsZWQgY29u
				ZmlndXJhdGlvbgogICAgICoKICAgICAqIEB2YXIgQ29kZVJhZ2VcQ29uZmlnCiAg
				ICAgKi8KICAgIHByaXZhdGUgc3RhdGljICRjdXJyZW50OwoKICAgIC8qKgogICAg
				ICogTWFwcyBwcm9wZXJ0eSBuYW1lcyB0byB2YWx1ZXMKICAgICAqCiAgICAgKiBA
				dmFyIGFycmF5CiAgICAgKi8KICAgIHByaXZhdGUgJHByb3BlcnRpZXM7CgogICAg
				LyoqCiAgICAgKiB0cnVlIGlmIHRoaXMgaW5zdGFuY2UgaXMgYSBjb3B5IG9mIHRo
				ZSBwcm9qZWN0IGNvbmZpZ3VyYXRpb24KICAgICAqCiAgICAgKiBAdmFyIGJvb2xl
				YW4KICAgICAqLwogICAgcHJpdmF0ZSAkYnVpbHRpbjsKfQoKZnVuY3Rpb24gYXV0
				b2xvYWQoJGNsYXNzKQp7CiAgICAkcGFydHMgPSBleHBsb2RlKCdcXCcsICRjbGFz
				cyk7CiAgICAkcGFydHNbY291bnQoJHBhcnRzKSAtIDFdID0gcnRyaW0oJHBhcnRz
				W2NvdW50KCRwYXJ0cykgLSAxXSwgJ18nKTsKICAgIGZvcmVhY2ggKGV4cGxvZGUo
				UEFUSF9TRVBBUkFUT1IsIGluaV9nZXQoJ2luY2x1ZGVfcGF0aCcpKSBhcyAkcCkg
				ewogICAgICAgICRmaWxlID0gJHAgLiAnLycgLiBqb2luKCcvJywgJHBhcnRzKSAu
				ICcucGhwJzsKICAgICAgICBpZiAoZmlsZV9leGlzdHMoJGZpbGUpICYmIGlzX3Jl
				YWRhYmxlKCRmaWxlKSkgewogICAgICAgICAgICByZXF1aXJlX29uY2UoJGZpbGUp
				OwogICAgICAgICAgICBpZiAoY2xhc3NfZXhpc3RzKCRjbGFzcykgfHwgaW50ZXJm
				YWNlX2V4aXN0cygkY2xhc3MpKQogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7
				CiAgICAgICAgfQogICAgfQogICAgcmV0dXJuIGZhbHNlOwp9CgpDb25maWc6OmJv
				b3RzdHJhcCgpOwo=
__ENDRESOURCE__;
			break;
		case 'CodeRage.pm':
			$content = <<< __ENDRESOURCE__
				IyBEZWZpbmVzIHRoZSBjbGFzcyBDb2RlUmFnZTo6Q29uZmlnLCBwcm92aWRpbmcg
				YWNjZXNzIHRvIGNvbmZpZ3VyYXRpb24KIyB2YXJpYWJsZXMKIwojIEZpbGU6ICAg
				ICAgICBDb2RlUmFnZS9CdWlsZC9SZXNvdXJjZS9Db2RlUmFnZS5wbQojIERhdGU6
				ICAgICAgICBUdWUgSmFuIDIyIDE0OjI3OjEwIE1TVCAyMDA4CiMgTm90aWNlOiAg
				ICAgIFRoaXMgZG9jdW1lbnQgY29udGFpbnMgY29uZmlkZW50aWFsIGluZm9ybWF0
				aW9uIGFuZAojICAgICAgICAgICAgICB0cmFkZSBzZWNyZXRzCiMKIyBDb3B5cmln
				aHQ6ICAgMjAxNSBDb3Vuc2VsTm93LCBMTEMKIyBBdXRob3I6ICAgICAgSm9uYXRo
				YW4gVHVya2FuaXMKIyBMaWNlbnNlOiAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZAoK
				cGFja2FnZSBDb2RlUmFnZTsKCnVzZSBzdHJpY3Q7Cgp7CiAgICBwYWNrYWdlIENv
				ZGVSYWdlOjpDb25maWc7CgogICAgdXNlIGNvbnN0YW50IERFRkFVTFRfVE9PTFNf
				Uk9PVCA9PiAnL3Vzci9zaGFyZS9Db2RlUmFnZS0zLjAnOwoKCiAgICAjIFRoZSBw
				cm9qZWN0IHJvb3QgZGlyZWN0b3J5CiAgICBteSAkX3Byb2plY3RSb290OwoKICAg
				ICMgSGFzaCByZWZlcmVuY2UgbWFwcGluZyBjb25maWd1cmF0aW9uIHZhcmlhYmxl
				IG5hbWVzIHRvIHZhbHVlcwogICAgbXkgJF92YWx1ZXM7CgogICAgIyBUaGUgY3Vy
				cmVudGx5IGluc3RhbGxlZCBjb25maWd1cmF0aW9uCiAgICBteSAkX2N1cnJlbnQ7
				CgogICAgIyBFcXVhbCB0byAxIGlmIGJvb3RzdHJhcCgpIGhhcyBiZWVuIGNhbGxl
				ZAogICAgbXkgJF9ib290c3RyYXBwZWQgPSAwOwoKICAgICMgQ29uc3J0cnVjdHMg
				YW4gaW5zdGFuY2Ugb2YgQ29kZVJhZ2VcQ29uZmlnCiAgICAjCiAgICAjIFBhcmFt
				ZXRlcnM6CiAgICAjICAgJHByb3BlcnRpZXMgLSBUaGUgaGFzaCByZWZlcmVuY2Ug
				b2YgcHJvcGVydGllczsgaWYgb21pdHRlZCwgdGhlIHByb3BlcnR5CiAgICAjICAg
				ICB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgZnJvbSB0aGUgcHJvamVjdCBjb25maWd1
				cmF0aW9uOyBtYXkgbm90IHNwZWNpZnkKICAgICMgICAgIHZhbHVlcyBmb3IgdGhl
				IHByb3BlcnRpZXMgInByb2plY3Rfcm9vdCIgb3IgInRvb2xzX3Jvb3QiCiAgICAj
				ICAkZGVmYXVsdCAtIEFuIGluc3RhbmNlIG9mIENvZGVSYWdlOjpDb25maWcgd2hv
				c2UgY29sbGVjdGlvbiBvZiBwcm9wZXJ0aWVzCiAgICAjICAgIHdpbGwgYmUgdXNl
				ZCB0byBzdXBwbHkgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIG5vdCBkZWZpbmVkIGlu
				CiAgICAjICAgICRwcm9wZXJ0aWVzOyBpZ25vcmVkIGlmICRwcm9wZXJ0aWVzIGlz
				IG5vdCBkZWZpbmVkCiAgICAjIFRocm93czogaWYgJHByb3BlcnRpZXMgb3IgJGRl
				ZmF1bHQgaXMgaW52YWxpZAogICAgc3ViIG5ldyB7CiAgICAgICAgbXkgKCRjbGFz
				cywgJHByb3BlcnRpZXMsICRkZWZhdWx0KSA9IEBfOwogICAgICAgICRjbGFzcy0+
				X2xvYWQgaWYgIWRlZmluZWQgJF92YWx1ZXM7CiAgICAgICAgbXkgJXByb3BlcnRp
				ZXM7CiAgICAgICAgaWYgKGRlZmluZWQgJHByb3BlcnRpZXMpIHsKICAgICAgICAg
				ICAgcmVmICRwcm9wZXJ0aWVzIGVxICdIQVNIJyB8fAogICAgICAgICAgICAgICAg
				ZGllICdJbnZhbGlkIHByb3BlcnRpZXMgYXJyYXk6IGV4cGVjdGVkIGFycmF5OyBm
				b3VuZCAnIC4KICAgICAgICAgICAgICAgICAgICAkY2xhc3MtPl9nZXRUeXBlKCRw
				cm9wZXJ0aWVzKTsKICAgICAgICAgICAgZXhpc3RzICRwcm9wZXJ0aWVzLT57cHJv
				amVjdF9yb290fSAmJgogICAgICAgICAgICAgICAgZGllICdJbnZhbGlkIHByb3Bl
				cnR5IG5hbWU6IHByb2plY3Rfcm9vdCc7CiAgICAgICAgICAgIGV4aXN0cyAkcHJv
				cGVydGllcy0+e3Rvb2xzX3Jvb3R9ICYmCiAgICAgICAgICAgICAgICBkaWUgJ0lu
				dmFsaWQgcHJvcGVydHkgbmFtZTogdG9vbHNfcm9vdCc7CiAgICAgICAgICAgIGZv
				ciAobXkgKCRuLCAkdikgPSBlYWNoICUkcHJvcGVydGllcykgewogICAgICAgICAg
				ICAgICAgIXJlZiAkdiB8fAogICAgICAgICAgICAgICAgICAgIGRpZSAnSW52YWxp
				ZCBwcm9wZXJ0eSB2YWx1ZTogZXhwZWN0ZWQgc3RyaW5nOyBmb3VuZCAnIC4KICAg
				ICAgICAgICAgICAgICAgICAgICAgJGNsYXNzLT5fZ2V0VHlwZSgkdik7CiAgICAg
				ICAgICAgIH0KICAgICAgICAgICAgJXByb3BlcnRpZXMgPSAlJHByb3BlcnRpZXM7
				CiAgICAgICAgICAgIGlmIChkZWZpbmVkICRkZWZhdWx0KSB7CiAgICAgICAgICAg
				ICAgICByZWYgJGRlZmF1bHQgZXEgJ0NvZGVSYWdlOjpDb25maWcnIHx8CiAgICAg
				ICAgICAgICAgICAgICAgZGllICdJbnZhbGlkIGRlZmF1bHQgY29uZmlndXJhdGlv
				bjogZXhwZWN0ZWQgJyAuCiAgICAgICAgICAgICAgICAgICAgICAgICdDb2RlUmFn
				ZTo6Q29uZmlnOyBmb3VuZCAnIC4gJGNsYXNzLT5fZ2V0VHlwZSgkZGVmYXVsdCk7
				CiAgICAgICAgICAgICAgICB3aGlsZSAobXkgKCRuLCAkdikgPSBlYWNoICV7JGRl
				ZmF1bHQtPntfcHJvcGVydGllc319KSB7CiAgICAgICAgICAgICAgICAgICAgJHBy
				b3BlcnRpZXN7JG59ID0gJHYgaWYgIWRlZmluZWQgJHByb3BlcnRpZXN7JG59Owog
				ICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAg
				ICAgICAgJHByb3BlcnRpZXN7cHJvamVjdF9yb290fSA9ICRfdmFsdWVzLT57cHJv
				amVjdF9yb290fTsKICAgICAgICAgICAgICAgICRwcm9wZXJ0aWVze3Rvb2xzX3Jv
				b3R9ID0gJF92YWx1ZXMtPnt0b29sc19yb290fTsKICAgICAgICAgICAgfQogICAg
				ICAgIH0gZWxzZSB7CiAgICAgICAgICAgICVwcm9wZXJ0aWVzPSAleyRfdmFsdWVz
				fTsKICAgICAgICB9CiAgICAgICAgbXkgJHNlbGYgPQogICAgICAgICAgICB7CiAg
				ICAgICAgICAgICAgICBfcHJvcGVydGllcyA9PiBcJXByb3BlcnRpZXMsCiAgICAg
				ICAgICAgICAgICBfYnVpbHRpbiA9PiBkZWZpbmVkICRwcm9wZXJ0aWVzID8gMCA6
				IDEKICAgICAgICAgICAgfTsKICAgICAgICBibGVzcyAkc2VsZiwgJGNsYXNzOwog
				ICAgICAgIHJldHVybiAkc2VsZjsKICAgIH0KCiAgICAgICAgIwogICAgICAgICMg
				TWV0aG9kcyBmb3IgYWNjZXNzaW5nIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcwog
				ICAgICAgICMKCiAgICAjIFJldHVybnMgdHJ1ZSBpZiB0aGUgbmFtZWQgY29uZmln
				dXJhdGlvbiB2YXJpYWJsZSBoYXMgYmVlbiBhc3NpZ25lZCBhIHZhbHVlCiAgICAj
				CiAgICAjIFBhcmFtZXRlcnM6CiAgICAjICAgJG5hbWUgLSBBIGNvbmZpZ3VyYXRp
				b24gdmFyaWFibGUgbmFtZQogICAgIyBSZXR1cm5zOiBib29sZWFuCiAgICBzdWIg
				aGFzUHJvcGVydHkgewogICAgICAgIG15ICgkc2VsZiwgJG5hbWUpID0gQF87CiAg
				ICAgICAgcmV0dXJuIGRlZmluZWQgJHNlbGYtPntfcHJvcGVydGllc317JG5hbWV9
				OwogICAgfQoKICAgICMgUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGNv
				bmZpZ3VyYXRpb24gdmFyaWFibGUsIG9yIHRoZSBnaXZlbgogICAgIyBkZWZhdWx0
				IHZhbHVlIGlzIHRoZSB2YXJpYWJsZSBpcyBub3Qgc2V0CiAgICAjCiAgICAjIFBh
				cmFtZXRlcnM6CiAgICAjICAgJG5hbWUgLSBBIGNvbmZpZ3VyYXRpb24gdmFyaWFi
				bGUgbmFtZQogICAgIyAgICRkZWZhdWx0IC0gVGhlIGRlZmF1bHQgdmFsdWUKICAg
				ICMgUmV0dXJuczogc3RyaW5nCiAgICBzdWIgZ2V0UHJvcGVydHkgewogICAgICAg
				IG15ICgkc2VsZiwgJG5hbWUsICRkZWZhdWx0KSA9IEBfOwogICAgICAgIHJldHVy
				biBleGlzdHMgJHNlbGYtPntfcHJvcGVydGllc317JG5hbWV9ID8KICAgICAgICAg
				ICAgJHNlbGYtPntfcHJvcGVydGllc317JG5hbWV9IDoKICAgICAgICAgICAgJGRl
				ZmF1bHQ7CiAgICB9CgogICAgIyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmFt
				ZWQgY29uZmlndXJhdGlvbiB2YXJpYWJsZSwgdGhyb3dpbmcgYW4KICAgICMgZXhj
				ZXB0aW9uIGlmIGl0IGlzIG5vdCBzZXQKICAgICMKICAgICMgUGFyYW1ldGVyczoK
				ICAgICMgICAkbmFtZSAtIEEgY29uZmlndXJhdGlvbiB2YXJpYWJsZSBuYW1lCiAg
				ICAjIFJldHVybnM6IHN0cmluZwogICAgc3ViIGdldFJlcXVpcmVkUHJvcGVydHkg
				ewogICAgICAgIG15ICgkc2VsZiwgJG5hbWUpID0gQF87CiAgICAgICAgZXhpc3Rz
				ICRzZWxmLT57X3Byb3BlcnRpZXN9eyRuYW1lfSB8fAogICAgICAgICAgICBkaWUg
				IlRoZSBjb25maWcgdmFyaWFibGUgJyRuYW1lJyBpcyBub3Qgc2V0IjsKICAgICAg
				ICByZXR1cm4gJHNlbGYtPntfcHJvcGVydGllc317JG5hbWV9OwogICAgfQoKICAg
				ICMgUmV0dXJucyB0aGUgbGlzdCBvZiBjb25maWd1cmF0aW9uIHZhcmlhYmxlIG5h
				bWVzCiAgICAjIFJldHVybnM6IGFycmF5CiAgICBzdWIgcHJvcGVydHlOYW1lcyB7
				CiAgICAgICAgbXkgKCRzZWxmKSA9IEBfOwogICAgICAgIHJldHVybiBrZXlzICV7
				JHNlbGYtPntfcHJvcGVydGllc319OwogICAgfQoKICAgICMgUmV0dXJucyB0cnVl
				IGlmIHRoaXMgaW5zdGFuY2UgaXMgYSBjb3B5IG9mIHRoZSBwcm9qZWN0IGNvbmZp
				Z3VyYXRpb24KICAgIHN1YiBidWlsdGluIHsgcmV0dXJuIHNoaWZ0LT57X2J1aWx0
				aW59OyB9CgogICAgICAgICMKICAgICAgICAjIE1ldGhvZHMgZm9yIGFjY2Vzc2lu
				ZyB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uCiAgICAgICAgIwoKICAgICMgUmV0
				dXJucyB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uCiAgICAjCiAgICAjIFJldHVy
				bjogQ29kZVJhZ2U6OkNvbmZpZwogICAgc3ViIGN1cnJlbnQgewogICAgICAgIG15
				ICgkY2xhc3MpID0gQF87CiAgICAgICAgJF9jdXJyZW50ID0gbmV3IENvZGVSYWdl
				OjpDb25maWcgaWYgIWRlZmluZWQgJF9jdXJyZW50OwogICAgICAgIHJldHVybiAk
				X2N1cnJlbnQ7CiAgICB9CgogICAgIyBSZXBsYWNlcyB0aGUgY3VycmVudCBjb25m
				aWd1cmF0aW9uCiAgICAjCiAgICAjIFBhcmFtZXRlcnM6CiAgICAjICAgJGN1cnJl
				bnQgLSBDb2RlUmFnZTo6Q29uZmlnIFRoZSBuZXcgY29uZmlndXJhdGlvbgogICAg
				IyBSZXR1cm5zOiBUaGUgcHJldmlvdXMgY29uZmlndXJhdGlvbgogICAgc3ViIHNl
				dEN1cnJlbnQgewogICAgICAgIG15ICgkY2xhc3MsICRjdXJyZW50KSA9IEBfOwog
				ICAgICAgIHJlZiAkY3VycmVudCBlcSAnQ29kZVJhZ2U6OkNvbmZpZycgfHwKICAg
				ICAgICAgICAgZGllICdJbnZhbGlkIGNvbmZpZ3VyYXRpb246IGV4cGVjdGVkIENv
				ZGVSYWdlOjpDb25maWc7ICcgLgogICAgICAgICAgICAgICAgJ2ZvdW5kICcgLiAk
				Y2xhc3MtPl9nZXRUeXBlKCRjdXJyZW50KTsKICAgICAgICBteSAkcHJldiA9ICRf
				Y3VycmVudDsKICAgICAgICAkX2N1cnJlbnQgPSAkY3VycmVudDsKICAgICAgICBy
				ZXR1cm4gJHByZXY7CiAgICB9CgogICAgICAgICMKICAgICAgICAjIE1ldGhvZCBj
				YWxsZWQgYnkgdGhlIHN5c3RlbSBhdCBpbml0aWFsaXphdGlvbgogICAgICAgICMK
				CiAgICAjIFNldHMgdGhlIHByb2plY3Qgcm9vdCBkaXJlY3RvcnkKICAgIHN1YiBi
				b290c3RyYXAgewogICAgICAgIG15ICgkY2xhc3MpID0gQF87CiAgICAgICAgcmV0
				dXJuIGlmICRfYm9vdHN0cmFwcGVkOwogICAgICAgICRfYm9vdHN0cmFwcGVkID0g
				MTsKCiAgICAgICAgIyBTZWFyY2ggZm9yIHJvb3QgZGlyZWN0b3J5CiAgICAgICAg
				aWYgKGRlZmluZWQgJEVOVntDT0RFUkFHRV9QUk9KRUNUX1JPT1R9KSB7CiAgICAg
				ICAgICAgICRfcHJvamVjdFJvb3QgPSAkRU5We0NPREVSQUdFX1BST0pFQ1RfUk9P
				VH07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmVxdWlyZSBDd2Q7CiAg
				ICAgICAgICAgIHJlcXVpcmUgRmlsZTo6QmFzZW5hbWU7CiAgICAgICAgICAgIG15
				ICRjdXIgPSAnJzsKICAgICAgICAgICAgbXkgJG5leHQgPSBDd2Q6OmdldGN3ZCgp
				OwogICAgICAgICAgICB3aGlsZSAoICRjdXIgbmUgJG5leHQgJiYKICAgICAgICAg
				ICAgICAgICAgICAhLWYgIiRuZXh0L3Byb2plY3QueG1sIiAmJgogICAgICAgICAg
				ICAgICAgICAgICEtZiAiJG5leHQvcHJvamVjdC5pbmkiICkKICAgICAgICAgICAg
				ewogICAgICAgICAgICAgICAgJGN1ciA9ICRuZXh0OwogICAgICAgICAgICAgICAg
				JG5leHQgPSBGaWxlOjpCYXNlbmFtZTo6ZGlybmFtZSgkbmV4dCk7CiAgICAgICAg
				ICAgIH0KICAgICAgICAgICAgJF9wcm9qZWN0Um9vdCA9ICRuZXh0IGlmICRjdXIg
				bmUgJG5leHQ7CiAgICAgICAgfQoKICAgICAgICAjIExvYWQgY29uZmlndXJhdGlv
				biBzZXR0aW5ncwogICAgICAgICRjbGFzcy0+X2xvYWQ7CgogICAgICAgICMgQWRk
				IHByb2plY3Qgcm9vdCBhbmQgdG9vbHMgcm9vdCB0byBASU5DCiAgICAgICAgbXkg
				JGNvbmZpZyA9IENvZGVSYWdlOjpDb25maWctPmN1cnJlbnQ7CiAgICAgICAgbXkg
				JHRvb2xzID0gJGNvbmZpZy0+Z2V0UmVxdWlyZWRQcm9wZXJ0eSgndG9vbHNfcm9v
				dCcpOwogICAgICAgIGlmICghZ3JlcCB7ICRfIGVxICR0b29scyB9IEBJTkMpIHsK
				ICAgICAgICAgICAgdW5zaGlmdCBASU5DLCAkdG9vbHM7CiAgICAgICAgfQogICAg
				ICAgIGlmIChkZWZpbmVkICRfcHJvamVjdFJvb3QgJiYgIWdyZXAgeyAkXyBlcSAk
				X3Byb2plY3RSb290IH0gQElOQykgewogICAgICAgICAgICB1bnNoaWZ0IEBJTkMs
				ICRfcHJvamVjdFJvb3Q7CiAgICAgICAgfQogICAgfQoKICAgICAgICAjCiAgICAg
				ICAgIyBEZXByZWNhdGVkIGludGVyZmFjZQogICAgICAgICMKCiAgICAjIFJldHVy
				bnMgdHJ1ZSBpZiB0aGUgbmFtZWQgY29uZmlndXJhdGlvbiB2YXJpYWJsZSBoYXMg
				YmVlbiBhc3NpZ25lZCBhCiAgICAjIHZhbHVlIChwb3NzaWJseSB1bmRlZikuCiAg
				ICAjCiAgICAjIFBhcmFtZXRlcnM6CiAgICAjICAgJG5hbWUgLSBBIGNvbmZpZ3Vy
				YXRpb24gdmFyaWFibGUgbmFtZS4KICAgIHN1YiBkZWZpbmVkIHsKICAgICAgICBt
				eSAoJGNsYXNzLCAkbmFtZSkgPSBAXzsKICAgICAgICAkY2xhc3MtPl9sb2FkIGlm
				ICFkZWZpbmVkICRfdmFsdWVzOwogICAgICAgIHJldHVybiBleGlzdHMgJF92YWx1
				ZXMtPnskbmFtZX0gPyAxIDogMDsKICAgIH0KCiAgICAjIFJldHVybnMgdGhlIHZh
				bHVlIG9mIHRoZSBuYW1lZCBjb25maWd1cmF0aW9uIHZhcmlhYmxlLgogICAgIwog
				ICAgIyBQYXJhbWV0ZXJzOgogICAgIyAgICRuYW1lIC0gQSBjb25maWd1cmF0aW9u
				IHZhcmlhYmxlIG5hbWUuCiAgICAjIFRocm93czogSWYgdGhlIHZhcmlhYmxlIGhh
				cyBub3QgYmVlbiBzZXQuCiAgICBzdWIgZ2V0IHsKICAgICAgICBteSAoJGNsYXNz
				LCAkbmFtZSkgPSBAXzsKICAgICAgICAkY2xhc3MtPl9sb2FkIGlmICFkZWZpbmVk
				ICRfdmFsdWVzOwogICAgICAgIGV4aXN0cyAkX3ZhbHVlcy0+eyRuYW1lfSB8fAog
				ICAgICAgICAgICBkaWUgIlRoZSBjb25maWcgdmFyaWFibGUgJyRuYW1lJyBpcyBu
				b3Qgc2V0IjsKICAgICAgICByZXR1cm4gJF92YWx1ZXMtPnskbmFtZX07CiAgICB9
				CgogICAgIyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgY29uZmlndXJh
				dGlvbiB2YXJpYWJsZSwgaWYgaXQgaGFzIGJlZW4KICAgICMgc2V0LCBhbmQgdGhl
				IHNwZWNpZmllZCBkZWZhdWx0IHZhbHVlIG90aGVyd2lzZS4KICAgICMKICAgICMg
				UGFyYW1ldGVyczoKICAgICMgICAkbmFtZSAtIEEgY29uZmlndXJhdGlvbiB2YXJp
				YWJsZSBuYW1lLgogICAgIyAgICRkZWZhdWx0IC0gVGhlIGRlZmF1bHQgdmFsdWUu
				CiAgICBzdWIgZ2V0SWYgewogICAgICAgIG15ICgkY2xhc3MsICRuYW1lLCAkZGVm
				YXVsdCkgPSBAXzsKICAgICAgICAkY2xhc3MtPl9sb2FkIGlmICFkZWZpbmVkICRf
				dmFsdWVzOwogICAgICAgIHJldHVybiBleGlzdHMgJF92YWx1ZXMtPnskbmFtZX0g
				PwogICAgICAgICAgICAkX3ZhbHVlcy0+eyRuYW1lfToKICAgICAgICAgICAgJGRl
				ZmF1bHQ7CiAgICB9CgogICAgIyBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgbmFtZXMg
				b2YgYWxsIGNvbmZpZ3VyYXRpb24gdmFyaWFibGVzLgogICAgc3ViIHByb3BlcnRp
				ZXMgewogICAgICAgIG15ICgkY2xhc3MpID0gQF87CiAgICAgICAgJGNsYXNzLT5f
				bG9hZCBpZiAhZGVmaW5lZCAkX3ZhbHVlczsKICAgICAgICByZXR1cm4ga2V5cyAl
				eyRfdmFsdWVzfTsKICAgIH0KCiAgICAjIENhdXNlcyBjb25maWd1cmF0aW9uIHNl
				dHRpbmdzIHRvIGJlIHJlbG9hZGVkIHVwb24gbmV4dCBhY2Nlc3MuCiAgICBzdWIg
				Y2xlYXIgewogICAgICAgIG15ICgkY2xhc3MpID0gQF87CiAgICAgICAgJF92YWx1
				ZXMgPSAkX2N1cnJlbnQgPSB1bmRlZjsKICAgIH0KCiAgICAjIExvYWRzIGNvbmZp
				Z3VyYXRpb24gc2V0dGluZ3MuCiAgICBzdWIgX2xvYWQgewogICAgICAgIG15ICgk
				Y2xhc3MpID0gQF87CiAgICAgICAgbXkgJHRvb2xzUm9vdCA9ICRFTlZ7Q09ERVJB
				R0VfVE9PTFNfUk9PVH0gfHwgREVGQVVMVF9UT09MU19ST09UOwogICAgICAgIF9z
				ZXQoJGNsYXNzLCAncHJvamVjdF9yb290JywgJF9wcm9qZWN0Um9vdCk7CiAgICAg
				ICAgX3NldCgkY2xhc3MsICd0b29sc19yb290JywgJHRvb2xzUm9vdCk7CiAgICAg
				ICAgaWYgKGRlZmluZWQgJF9wcm9qZWN0Um9vdCAmJiAtZiAiJF9wcm9qZWN0Um9v
				dC8uY29kZXJhZ2UvY29uZmlnLnBlcmwiKSB7CiAgICAgICAgICAgIHJlcXVpcmUg
				IiRfcHJvamVjdFJvb3QvLmNvZGVyYWdlL2NvbmZpZy5wZXJsIjsKICAgICAgICAg
				ICAgd2hpbGUgKG15ICgkbiwgJHYpID0gZWFjaCAlQ29kZVJhZ2U6Ol9jb25maWcp
				IHsKICAgICAgICAgICAgICAgIF9zZXQoJGNsYXNzLCAkbiwgJHYpOwogICAgICAg
				ICAgICB9CiAgICAgICAgfQogICAgfQoKICAgICMgU2V0cyB0aGUgdmFsdWUgb2Yg
				dGhlIG5hbWVkIGNvbmZpZ3VyYXRpb24gdmFyaWFibGUuCiAgICBzdWIgX3NldCB7
				CiAgICAgICAgbXkgKCRjbGFzcywgJG5hbWUsICR2YWx1ZSkgPSBAXzsKICAgICAg
				ICAkX3ZhbHVlcy0+eyRuYW1lfSA9ICR2YWx1ZTsKICAgICAgICBpZiAoaW5kZXgo
				JG5hbWUsICcuJykgPT0gLTEpIHsKICAgICAgICAgICAgbm8gc3RyaWN0OwogICAg
				ICAgICAgICAkeyJDb2RlUmFnZTo6JG5hbWUifSA9ICR2YWx1ZTsKICAgICAgICB9
				CiAgICB9CgogICAgIyBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1
				ZSwgZm9yIHVzZSBpbiBlcnJvciBtZXNzYWdlcwogICAgIwogICAgIyBQYXJhbWV0
				ZXJzOgogICAgIyAgICR2YWx1ZSAtIFRoZSB2YWx1ZQogICAgIyBSZXR1cm5zOiBz
				dHJpbmcKICAgIHN1YiBfZ2V0VHlwZSB7CiAgICAgICAgbXkgKCRjbGFzcywgJHZh
				bHVlKSA9IEBfOwogICAgICAgIG15ICRyZWYgPSByZWYgJHZhbHVlOwogICAgICAg
				IHJldHVybiAkcmVmID8gJHJlZiA6ICdzY2FsYXInOwogICAgfQoKICAgIEJFR0lO
				IHsgQ29kZVJhZ2U6OkNvbmZpZy0+Ym9vdHN0cmFwOyB9Cn0KCjE7Cg==
__ENDRESOURCE__;
			break;
		case 'builddb':
			$content = <<< __ENDRESOURCE__
				IyEvYmluL3NoCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
				IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMg
				V3JhcHBlciBzY3JpcHQgZm9yIGJ1aWxkZGIucGhwCiMKIyBGaWxlOiAgICAgICAg
				Q29kZVJhZ2UvQnVpbGQvUmVzb3VyY2UvYnVpbGRkYgojIERhdGU6ICAgICAgICBT
				YXQgU2VwIDI3IDExOjQ0OjMzIE1EVCAyMDA4CiMgTm90aWNlOiAgICAgIFRoaXMg
				ZG9jdW1lbnQgY29udGFpbnMgY29uZmlkZW50aWFsIGluZm9ybWF0aW9uIGFuZAoj
				ICAgICAgICAgICAgICB0cmFkZSBzZWNyZXRzCiMKIyBDb3B5cmlnaHQ6ICAgMjAx
				NSBDb3Vuc2VsTm93LCBMTEMKIyBBdXRob3I6ICAgICAgSm9uYXRoYW4gVHVya2Fu
				aXMKIyBMaWNlbnNlOiAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZAojCiMjIyMjIyMj
				IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
				IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpydW4tY29kZXJhZ2UgYnVpbGRkYiAi
				JEAiCg==
__ENDRESOURCE__;
			break;
		case 'builddb.bat':
			$content = <<< __ENDRESOURCE__
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6OjoKOjoKOjogV3JhcHBlciBz
				Y3JpcHQgZm9yIGJ1aWxkZGIucGhwCjo6Cjo6IEZpbGU6ICAgICAgICBDb2RlUmFn
				ZS9CdWlsZC9SZXNvdXJjZS9idWlsZGRiLmJhdAo6OiBEYXRlOiAgICAgICAgU3Vu
				IEphbiAgNCAyMzo0NzozNCBNU1QgMjAwOQo6OiBOb3RpY2U6ICAgICAgVGhpcyBk
				b2N1bWVudCBjb250YWlucyBjb25maWRlbnRpYWwgaW5mb3JtYXRpb24gYW5kCjo6
				ICAgICAgICAgICAgICB0cmFkZSBzZWNyZXRzCjo6Cjo6IENvcHlyaWdodDogICAy
				MDA4IENvZGVSYWdlCjo6IEF1dGhvcjogICAgICBKb25hdGhhbiBUdXJrYW5pcwo6
				OiBMaWNlbnNlOiAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZAo6Ogo6Ojo6Ojo6Ojo6
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6OgoKQGVjaG8gb2ZmCnJ1bi1jb2RlcmFnZS5i
				YXQgYnVpbGRkYiAlKgo=
__ENDRESOURCE__;
			break;
		case 'builddb.php':
			$content = <<< __ENDRESOURCE__
				PD9waHAKCi8qKgogKiBXcmFwcGVyIGZvciBDb2RlUmFnZS9EYi9TY2hlbWEvYnVp
				bGRkYi5waHAKICoKICogRmlsZTogICAgICAgIENvZGVSYWdlL0J1aWxkL1Jlc291
				cmNlL2J1aWxkZGIucGhwCiAqIERhdGU6ICAgICAgICBTYXQgU2VwIDI3IDExOjQ0
				OjQ5IE1EVCAyMDA4CiAqIE5vdGljZTogICAgICBUaGlzIGRvY3VtZW50IGNvbnRh
				aW5zIGNvbmZpZGVudGlhbCBpbmZvcm1hdGlvbgogKiAgICAgICAgICAgICAgYW5k
				IHRyYWRlIHNlY3JldHMKICoKICogQGNvcHlyaWdodCAgIDIwMTUgQ291bnNlbE5v
				dywgTExDCiAqIEBhdXRob3IgICAgICBKb25hdGhhbiBUdXJrYW5pcwogKiBAbGlj
				ZW5zZSAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZAogKi8KCi8qKgogKiBAaWdub3Jl
				CiAqLwpyZXF1aXJlX29uY2UoJ0NvZGVSYWdlL0RiL1NjaGVtYS9idWlsZGRiLnBo
				cCcpOwoKPz4K
__ENDRESOURCE__;
			break;
		case 'decode-id':
			$content = <<< __ENDRESOURCE__
				IyEvYmluL2VudiBwaHAKPD9waHAKCnJlcXVpcmVfb25jZSgnQ29kZVJhZ2UucGhw
				Jyk7CnJlcXVpcmVfb25jZSgnQ29kZVJhZ2UvQWNjZXNzLnBocCcpOwoKaWYgKHNp
				emVvZigkYXJndikgIT0gMikgewogICAgJGVycm9yID0gZm9wZW4oJ3BocDovL3N0
				ZGVycicsICd3Jyk7CiAgICBmd3JpdGUoJGVycm9yLCAiVXNhZ2U6IGRlY29kZS1p
				ZCBPQkpFQ1RfSURcbiIpOwogICAgZXhpdCgxKTsKfQokaWQgPSAkYXJndlsxXTsK
				ZWNobyBDb2RlUmFnZVxBY2Nlc3NcUmVzb3VyY2VJZDo6ZGVjb2RlKCRpZCk7Cg==
__ENDRESOURCE__;
			break;
		case 'encode-id':
			$content = <<< __ENDRESOURCE__
				IyEvYmluL2VudiBwaHAKPD9waHAKCnJlcXVpcmVfb25jZSgnQ29kZVJhZ2UucGhw
				Jyk7CnJlcXVpcmVfb25jZSgnQ29kZVJhZ2UvQWNjZXNzLnBocCcpOwoKaWYgKHNp
				emVvZigkYXJndikgIT0gMikgewogICAgJGVycm9yID0gZm9wZW4oJ3BocDovL3N0
				ZGVycicsICd3Jyk7CiAgICBmd3JpdGUoJGVycm9yLCAiVXNhZ2U6IGVuY29kZS1p
				ZCBJTlRFR0VSXG4iKTsKICAgIGV4aXQoMSk7Cn0KJGlkID0gJGFyZ3ZbMV07CmVj
				aG8gQ29kZVJhZ2VcQWNjZXNzXFJlc291cmNlSWQ6OmVuY29kZSgkaWQpOwo=
__ENDRESOURCE__;
			break;
		case 'makeme':
			$content = <<< __ENDRESOURCE__
				IyEvYmluL3NoCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
				IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMg
				V3JhcHBlciBzY3JpcHQgZm9yIG1ha2VtZS5waHAKIwojIEZpbGU6ICAgICAgICBD
				b2RlUmFnZS9CdWlsZC9SZXNvdXJjZS9tYWtlbWUKIyBEYXRlOiAgICAgICAgU3Vu
				IEphbiAgNCAyMzo0NzozNCBNU1QgMjAwOQojIE5vdGljZTogICAgICBUaGlzIGRv
				Y3VtZW50IGNvbnRhaW5zIGNvbmZpZGVudGlhbCBpbmZvcm1hdGlvbiBhbmQKIyAg
				ICAgICAgICAgICAgdHJhZGUgc2VjcmV0cwojCiMgQ29weXJpZ2h0OiAgIDIwMTUg
				Q291bnNlbE5vdywgTExDCiMgQXV0aG9yOiAgICAgIEpvbmF0aGFuIFR1cmthbmlz
				CiMgTGljZW5zZTogICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQKIwojIyMjIyMjIyMj
				IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
				IyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKcnVuLWNvZGVyYWdlIG1ha2VtZSAiJEAi
				Cg==
__ENDRESOURCE__;
			break;
		case 'makeme.bat':
			$content = <<< __ENDRESOURCE__
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6OjoKOjoKOjogV3JhcHBlciBz
				Y3JpcHQgZm9yIG1ha2VtZS5waHAKOjoKOjogRmlsZTogICAgICAgIENvZGVSYWdl
				L0J1aWxkL1Jlc291cmNlL21ha2VtZS5iYXQKOjogRGF0ZTogICAgICAgIFN1biBK
				YW4gIDQgMjM6NDc6MzQgTVNUIDIwMDkKOjogTm90aWNlOiAgICAgIFRoaXMgZG9j
				dW1lbnQgY29udGFpbnMgY29uZmlkZW50aWFsIGluZm9ybWF0aW9uIGFuZAo6OiAg
				ICAgICAgICAgICAgdHJhZGUgc2VjcmV0cwo6Ogo6OiBDb3B5cmlnaHQ6ICAgMjAw
				OCBDb2RlUmFnZQo6OiBBdXRob3I6ICAgICAgSm9uYXRoYW4gVHVya2FuaXMKOjog
				TGljZW5zZTogICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQKOjoKOjo6Ojo6Ojo6Ojo6
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6OjoKCkBlY2hvIG9mZgpydW4tY29kZXJhZ2UuYmF0
				IG1ha2VtZSAlKgo=
__ENDRESOURCE__;
			break;
		case 'project.xsd':
			$content = <<< __ENDRESOURCE__
				PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCEtLQogIC8v
				Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8v
				Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogIC8vCiAgLy8gTG9jYWwgY29w
				eSBvZiBodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UKICAvLwog
				IC8vIEZpbGU6ICAgICAgICBDb2RlUmFnZS9CdWlsZC9SZXNvdXJjZS9wcm9qZWN0
				LnhzZAogIC8vIERhdGU6ICAgICAgICBNb24sIDI4IEphbiAwOCAwMzozMTo1MSAr
				MDAwMAogIC8vIE5vdGljZTogICAgICBUaGlzIGRvY3VtZW50IGNvbnRhaW5zIGNv
				bmZpZGVudGlhbCBpbmZvcm1hdGlvbiBhbmQKICAvLyAgICAgICAgICAgICAgdHJh
				ZGUgc2VjcmV0cwogIC8vCiAgLy8gQ29weXJpZ2h0OiAgIDIwMTUgQ291bnNlbE5v
				dywgTExDCiAgLy8gQXV0aG9yOiAgICAgIEpvbmF0aGFuIFR1cmthbmlzCiAgLy8g
				TGljZW5zZTogICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQKICAvLwogIC8vLy8vLy8v
				Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8v
				Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLwogIC0tPgo8c2NoZW1hIHhtbG5zPSJodHRw
				Oi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSIKICB4bWxuczp4c2Q9Imh0dHA6
				Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hIgogIHhtbG5zOnByPSJodHRwOi8v
				d3d3LmNvZGVyYWdlLmNvbS8yMDA4L3Byb2plY3QiCiAgdGFyZ2V0TmFtZXNwYWNl
				PSJodHRwOi8vd3d3LmNvZGVyYWdlLmNvbS8yMDA4L3Byb2plY3QiCiAgZWxlbWVu
				dEZvcm1EZWZhdWx0PSJxdWFsaWZpZWQiPgoKICA8IS0tIFNoYXJlZCBTaW1wbGUg
				VHlwZXMgLS0+CgogIDxzaW1wbGVUeXBlIG5hbWU9ImlkZW50aWZpZXIiPgogICAg
				PHJlc3RyaWN0aW9uIGJhc2U9InN0cmluZyI+CiAgICAgIDxwYXR0ZXJuIHZhbHVl
				PSJbX2EtekEtWl1bX2EtekEtWjAtOV0qIi8+CiAgICA8L3Jlc3RyaWN0aW9uPgog
				IDwvc2ltcGxlVHlwZT4KCiAgPHNpbXBsZVR5cGUgbmFtZT0iY29tcG91bmRJZGVu
				dGlmaWVyIj4KICAgIDxyZXN0cmljdGlvbiBiYXNlPSJzdHJpbmciPgogICAgICA8
				cGF0dGVybiB2YWx1ZT0iW19hLXpBLVpdW19hLXpBLVowLTldKihcLltfYS16QS1a
				XVtfYS16QS1aMC05XSopKiIvPgogICAgPC9yZXN0cmljdGlvbj4KICA8L3NpbXBs
				ZVR5cGU+CgogIDxzaW1wbGVUeXBlIG5hbWU9ImZyYW1ld29yayI+CiAgICA8YW5u
				b3RhdGlvbj4KICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgVGhlIG5hbWUg
				b2YgYSBmcmFtZXdvcmsgdGhhdCBtYWtlcyB1c2Ugb2YgcGx1Z2dhYmxlIHBhY2th
				Z2VzIG1vZHVsZXMsCiAgICAgICAgZS5nLiwgcGhwLCBwZWFyLCBvciBwZXJsCiAg
				ICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgIDwvYW5ub3RhdGlvbj4KICAgIDxyZXN0
				cmljdGlvbiBiYXNlPSJwcjppZGVudGlmaWVyIi8+CiAgPC9zaW1wbGVUeXBlPgoK
				ICA8IS0tIEF0dHJpYnV0ZXMgLS0+CgogIDxhdHRyaWJ1dGVHcm91cCBuYW1lPSJ0
				YXJnZXRBdHRyaWJ1dGVzIj4KICAgIDxhdHRyaWJ1dGUgbmFtZT0iaWQiIHR5cGU9
				InByOmlkZW50aWZpZXIiPgogICAgICA8YW5ub3RhdGlvbj4KICAgICAgICA8ZG9j
				dW1lbnRhdGlvbj4KICAgICAgICAgIFRoZSBuYW1lIG9mIGEgdGFyZ2V0LCBmb3Ig
				dXNlIG9uIGEgY29tbWFuZCBsaW5lIG9yIGluIGEgbGlzdAogICAgICAgICAgb2Yg
				dGFyZ2V0IGRlcGVuZGVuY2llcy4KICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAg
				ICAgIDwvYW5ub3RhdGlvbj4KICAgIDwvYXR0cmlidXRlPgogICAgPGF0dHJpYnV0
				ZSBuYW1lPSJkZXBlbmRzT24iPgogICAgICA8YW5ub3RhdGlvbj4KICAgICAgICA8
				ZG9jdW1lbnRhdGlvbj4KICAgICAgICAgIEEgbGlzdCBvZiB0aGUgbmFtZXMgb2Yg
				dGFyZ2V0cyB1cG9uIHdoaWNoIGEgdGFyZ2V0IGRlcGVuZHMuCiAgICAgICAgPC9k
				b2N1bWVudGF0aW9uPgogICAgICA8L2Fubm90YXRpb24+CiAgICAgIDxzaW1wbGVU
				eXBlPgogICAgICAgIDxsaXN0IGl0ZW1UeXBlPSJwcjppZGVudGlmaWVyIi8+CiAg
				ICAgIDwvc2ltcGxlVHlwZT4KICAgIDwvYXR0cmlidXRlPgogIDwvYXR0cmlidXRl
				R3JvdXA+CgogIDwhLS0gVG9wLWxldmVsIGVsZW1lbnQgLS0+CgogIDxlbGVtZW50
				IG5hbWU9InByb2plY3QiPgogICAgPGNvbXBsZXhUeXBlPgogICAgICA8c2VxdWVu
				Y2U+CiAgICAgICAgPGVsZW1lbnQgcmVmPSJwcjppbmZvIiBtaW5PY2N1cnM9IjAi
				Lz4KICAgICAgICA8ZWxlbWVudCBuYW1lPSJpbmNsdWRlIiBtaW5PY2N1cnM9IjAi
				PgogICAgICAgICAgPGNvbXBsZXhUeXBlPgogICAgICAgICAgICA8YXR0cmlidXRl
				IG5hbWU9InNyYyIgdHlwZT0iYW55VVJJIiB1c2U9InJlcXVpcmVkIj4KICAgICAg
				ICAgICAgICA8YW5ub3RhdGlvbj4KICAgICAgICAgICAgICAgIDxkb2N1bWVudGF0
				aW9uPgogICAgICAgICAgICAgICAgICBUaGUgcGF0aG5hbWUgb2YgYW4gWE1MIGRv
				Y3VtZW50ICBjb25mb3JtaW5nIHRvIHRoaXMgc2NoZW1hCiAgICAgICAgICAgICAg
				ICAgIHdob3NlIHJvb3QgZWxlbWVudCBpcyAncHJvamVjdCcgb3IgJ2NvbmZpZycu
				CiAgICAgICAgICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgICAgICAgICAg
				PC9hbm5vdGF0aW9uPgogICAgICAgICAgICA8L2F0dHJpYnV0ZT4KICAgICAgICAg
				IDwvY29tcGxleFR5cGU+CiAgICAgICAgPC9lbGVtZW50PgogICAgICAgIDxlbGVt
				ZW50IHJlZj0icHI6Y29uZmlnIiBtaW5PY2N1cnM9IjAiLz4KICAgICAgICA8ZWxl
				bWVudCByZWY9InByOnRvb2wiIG1pbk9jY3Vycz0iMCIgbWF4T2NjdXJzPSJ1bmJv
				dW5kZWQiLz4KICAgICAgICA8ZWxlbWVudCBuYW1lPSJ0YXJnZXRzIiBtaW5PY2N1
				cnM9IjAiPgogICAgICAgICAgPGNvbXBsZXhUeXBlPgogICAgICAgICAgICA8c2Vx
				dWVuY2U+CiAgICAgICAgICAgICAgPGFueSBtaW5PY2N1cnM9IjAiIG1heE9jY3Vy
				cz0idW5ib3VuZGVkIiBwcm9jZXNzQ29udGVudHM9InNraXAiLz4KICAgICAgICAg
				ICAgPC9zZXF1ZW5jZT4KICAgICAgICAgIDwvY29tcGxleFR5cGU+CiAgICAgICAg
				PC9lbGVtZW50PgogICAgICA8L3NlcXVlbmNlPgogICAgPC9jb21wbGV4VHlwZT4K
				ICA8L2VsZW1lbnQ+CgogIDxlbGVtZW50IG5hbWU9InRhcmdldCIgYWJzdHJhY3Q9
				InRydWUiLz4KCiAgPCEtLSBQcm9qZWN0IG1ldGFkYXRhIC0tPgoKICA8ZWxlbWVu
				dCBuYW1lPSJpbmZvIj4KICAgIDxhbm5vdGF0aW9uPgogICAgICA8ZG9jdW1lbnRh
				dGlvbj4KICAgICAgICBDb250YWlucyBwcm9qZWN0IG1ldGFkYXRhCiAgICAgIDwv
				ZG9jdW1lbnRhdGlvbj4KICAgIDwvYW5ub3RhdGlvbj4KICAgIDxjb21wbGV4VHlw
				ZT4KICAgICAgPGFsbD4KICAgICAgICA8ZWxlbWVudCBuYW1lPSJsYWJlbCIgbWlu
				T2NjdXJzPSIwIj4KICAgICAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgICAgICA8
				ZG9jdW1lbnRhdGlvbj4KICAgICAgICAgICAgICBBIGRlc2NyaXB0aXZlIG5hbWUg
				b2YgdGhlIHByb2plY3QKICAgICAgICAgICAgPC9kb2N1bWVudGF0aW9uPgogICAg
				ICAgICAgPC9hbm5vdGF0aW9uPgogICAgICAgIDwvZWxlbWVudD4KICAgICAgICA8
				ZWxlbWVudCBuYW1lPSJkZXNjcmlwdGlvbiIgbWluT2NjdXJzPSIwIj4KICAgICAg
				ICAgIDxhbm5vdGF0aW9uPgogICAgICAgICAgICA8ZG9jdW1lbnRhdGlvbj4KICAg
				ICAgICAgICAgICBBIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoZSBwcm9qZWN0
				CiAgICAgICAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgICAgICAgIDwvYW5ub3Rh
				dGlvbj4KICAgICAgICA8L2VsZW1lbnQ+CiAgICAgICAgPGVsZW1lbnQgbmFtZT0i
				dmVyc2lvbiIgbWluT2NjdXJzPSIwIj4KICAgICAgICAgIDxhbm5vdGF0aW9uPgog
				ICAgICAgICAgICA8ZG9jdW1lbnRhdGlvbj4KICAgICAgICAgICAgICBUaGUgZnVs
				bCB2ZXJzaW9uIG51bWJlciBvZiB0aGUgcHJvamVjdDsgYW55IGZvcm1hdCBpcyBh
				Y2NlcHRhYmxlCiAgICAgICAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgICAgICAg
				IDwvYW5ub3RhdGlvbj4KICAgICAgICA8L2VsZW1lbnQ+CiAgICAgICAgPGVsZW1l
				bnQgbmFtZT0iZGF0ZSIgdHlwZT0iZGF0ZVRpbWUiIG1pbk9jY3Vycz0iMCI+CiAg
				ICAgICAgICA8YW5ub3RhdGlvbj4KICAgICAgICAgICAgPGRvY3VtZW50YXRpb24+
				CiAgICAgICAgICAgICAgVGhlIHByb2plY3QgZGF0ZQogICAgICAgICAgICA8L2Rv
				Y3VtZW50YXRpb24+CiAgICAgICAgICA8L2Fubm90YXRpb24+CiAgICAgICAgPC9l
				bGVtZW50PgogICAgICAgIDxlbGVtZW50IG5hbWU9ImNvcHlyaWdodCIgbWluT2Nj
				dXJzPSIwIj4KICAgICAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgICAgICA8ZG9j
				dW1lbnRhdGlvbj4KICAgICAgICAgICAgICBDb3B5cmlnaHQgMjAxNSBDb3Vuc2Vs
				Tm93LCBMTEMKICAgICAgICAgICAgPC9kb2N1bWVudGF0aW9uPgogICAgICAgICAg
				PC9hbm5vdGF0aW9uPgogICAgICAgIDwvZWxlbWVudD4KICAgICAgICA8ZWxlbWVu
				dCBuYW1lPSJsaWNlbnNlIiBtaW5PY2N1cnM9IjAiPgogICAgICAgICAgPGFubm90
				YXRpb24+CiAgICAgICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgICAgICAg
				IExpY2Vuc2UgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb2plY3QKICAgICAgICAg
				ICAgPC9kb2N1bWVudGF0aW9uPgogICAgICAgICAgPC9hbm5vdGF0aW9uPgogICAg
				ICAgIDwvZWxlbWVudD4KICAgICAgICA8ZWxlbWVudCBuYW1lPSJhdXRob3IiIG1p
				bk9jY3Vycz0iMCI+CiAgICAgICAgICA8YW5ub3RhdGlvbj4KICAgICAgICAgICAg
				PGRvY3VtZW50YXRpb24+CiAgICAgICAgICAgICAgQSBzZW1pY29sb24tc2VwYXJh
				dGVkIGxpc3Qgb2YgYXV0aG9yIG5hbWUKICAgICAgICAgICAgPC9kb2N1bWVudGF0
				aW9uPgogICAgICAgICAgPC9hbm5vdGF0aW9uPgogICAgICAgIDwvZWxlbWVudD4K
				ICAgICAgICA8ZWxlbWVudCBuYW1lPSJsaW5rIiB0eXBlPSJhbnlVUkkiIG1pbk9j
				Y3Vycz0iMCI+CiAgICAgICAgICA8YW5ub3RhdGlvbj4KICAgICAgICAgICAgPGRv
				Y3VtZW50YXRpb24+CiAgICAgICAgICAgICAgVGhlIGxvY2F0aW9uIG9mIGFkZGl0
				aW9uYWwgcHJvamVjdCBpbmZvcm1hdGlvbgogICAgICAgICAgICA8L2RvY3VtZW50
				YXRpb24+CiAgICAgICAgICA8L2Fubm90YXRpb24+CiAgICAgICAgPC9lbGVtZW50
				PgogICAgICA8L2FsbD4KICAgIDwvY29tcGxleFR5cGU+CiAgPC9lbGVtZW50PgoK
				ICA8IS0tIFByb2plY3QgY29uZmlndXJhdGlvbiAtLT4KCiAgPGVsZW1lbnQgbmFt
				ZT0iY29uZmlnIiB0eXBlPSJwcjpjb25maWdHcm91cCI+CiAgICA8YW5ub3RhdGlv
				bj4KICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgQ29udGFpbnMgcHJvamVj
				dCBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uCiAgICAgIDwvZG9jdW1lbnRhdGlv
				bj4KICAgIDwvYW5ub3RhdGlvbj4KICA8L2VsZW1lbnQ+CgogIDxjb21wbGV4VHlw
				ZSBuYW1lPSJjb25maWdHcm91cCI+CiAgICA8YW5ub3RhdGlvbj4KICAgICAgPGRv
				Y3VtZW50YXRpb24+CiAgICAgICAgVGhlIHR5cGUgb2YgYSAicHI6Y29uZmlnIiBl
				bGVtZW50IG9yIGEgInByOmdyb3VwIiBkZXNjZW5kYW50IG9mIGEKICAgICAgICAi
				cHI6Y29uZmlnIiBlbGVtZW50CiAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgIDwv
				YW5ub3RhdGlvbj4KICAgIDxzZXF1ZW5jZT4KICAgICAgPGVsZW1lbnQgbmFtZT0i
				bGFiZWwiIG1pbk9jY3Vycz0iMCI+CiAgICAgICAgPGFubm90YXRpb24+CiAgICAg
				ICAgICA8ZG9jdW1lbnRhdGlvbj4KICAgICAgICAgICAgQSBkZXNjcmlwdGl2ZSBu
				YW1lIG9mIHRoZSBwcm9wZXJ0eQogICAgICAgICAgPC9kb2N1bWVudGF0aW9uPgog
				ICAgICAgIDwvYW5ub3RhdGlvbj4KICAgICAgPC9lbGVtZW50PgogICAgICA8ZWxl
				bWVudCBuYW1lPSJkZXNjcmlwdGlvbiIgbWluT2NjdXJzPSIwIj4KICAgICAgICA8
				YW5ub3RhdGlvbj4KICAgICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgICAg
				ICBBIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoZSBwcm9wZXJ0eQogICAgICAg
				ICAgPC9kb2N1bWVudGF0aW9uPgogICAgICAgIDwvYW5ub3RhdGlvbj4KICAgICAg
				PC9lbGVtZW50PgogICAgICA8Y2hvaWNlIG1pbk9jY3Vycz0iMCIgbWF4T2NjdXJz
				PSJ1bmJvdW5kZWQiPgogICAgICAgIDxlbGVtZW50IG5hbWU9Imdyb3VwIiB0eXBl
				PSJwcjpjb25maWdHcm91cCIvPgogICAgICAgIDxlbGVtZW50IG5hbWU9InByb3Bl
				cnR5IiB0eXBlPSJwcjpjb25maWdQcm9wZXJ0eSIvPgogICAgICA8L2Nob2ljZT4K
				ICAgIDwvc2VxdWVuY2U+CiAgICA8YXR0cmlidXRlIG5hbWU9Im5hbWUiIHR5cGU9
				InByOmNvbXBvdW5kSWRlbnRpZmllciIgdXNlPSJvcHRpb25hbCI+CiAgICAgIDxh
				bm5vdGF0aW9uPgogICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgICAgVGhl
				IGdyb3VwJ3MgY29udHJpYnV0aW9uIHRvIHRoZSBuYW1lcyBvZiBpdHMgZGVzY2Vu
				ZGFudCBwcm9wZXJ0aWVzOwogICAgICAgICAgZS5nLiwgaWYgdGhlIG5hbWUgb2Yg
				YSBncm91cCBpcyAiZGF0YVNvdXJjZS5tYWluIiBhbmQgaXQgaGFzIGEgY2hpbGQK
				ICAgICAgICAgIHByb3BlcnR5IG5hbWVkICJwYXNzd29yZCIsIHRoZSBmdWxseSBx
				dWFsaWZpZWQgcHJvcGVydHkgbmFtZSB3aWxsCiAgICAgICAgICBlbmQgd2l0aCAi
				ZGF0YVNvdXJjZS5tYWluLnBhc3N3b3JkIgogICAgICAgIDwvZG9jdW1lbnRhdGlv
				bj4KICAgICAgPC9hbm5vdGF0aW9uPgogICAgPC9hdHRyaWJ1dGU+CiAgPC9jb21w
				bGV4VHlwZT4KCiAgPGNvbXBsZXhUeXBlIG5hbWU9ImNvbmZpZ1Byb3BlcnR5Ij4K
				ICAgIDxhbm5vdGF0aW9uPgogICAgICA8ZG9jdW1lbnRhdGlvbj4KICAgICAgICBU
				aGUgdHlwZSBvZiBhICJwcjpwcm9wZXJ0eSIgZGVzY2VuZGFudCBvZiBhICJwcjpj
				b25maWciIGVsZW1lbnQKICAgICAgPC9kb2N1bWVudGF0aW9uPgogICAgPC9hbm5v
				dGF0aW9uPgogICAgPHNlcXVlbmNlPgogICAgICA8ZWxlbWVudCBuYW1lPSJsYWJl
				bCIgbWluT2NjdXJzPSIwIj4KICAgICAgICA8YW5ub3RhdGlvbj4KICAgICAgICAg
				IDxkb2N1bWVudGF0aW9uPgogICAgICAgICAgICBBIGRlc2NyaXB0aXZlIG5hbWUg
				b2YgdGhlIHByb3BlcnR5CiAgICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAg
				ICAgPC9hbm5vdGF0aW9uPgogICAgICA8L2VsZW1lbnQ+CiAgICAgIDxlbGVtZW50
				IG5hbWU9ImRlc2NyaXB0aW9uIiBtaW5PY2N1cnM9IjAiPgogICAgICAgIDxhbm5v
				dGF0aW9uPgogICAgICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgICAgIEEg
				ZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhlIHByb3BlcnR5CiAgICAgICAgICA8
				L2RvY3VtZW50YXRpb24+CiAgICAgICAgPC9hbm5vdGF0aW9uPgogICAgICA8L2Vs
				ZW1lbnQ+CiAgICA8L3NlcXVlbmNlPgogICAgPGF0dHJpYnV0ZSBuYW1lPSJuYW1l
				IiB0eXBlPSJwcjpjb21wb3VuZElkZW50aWZpZXIiIHVzZT0icmVxdWlyZWQiPgog
				ICAgICA8YW5ub3RhdGlvbj4KICAgICAgICA8ZG9jdW1lbnRhdGlvbj4KICAgICAg
				ICAgIFRoZSBwcm9wZXJ0eSBuYW1lCiAgICAgICAgPC9kb2N1bWVudGF0aW9uPgog
				ICAgICA8L2Fubm90YXRpb24+CiAgICA8L2F0dHJpYnV0ZT4KICAgIDxhdHRyaWJ1
				dGUgbmFtZT0idHlwZSIgdXNlPSJvcHRpb25hbCI+CiAgICAgIDxhbm5vdGF0aW9u
				PgogICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgICAgVGhlIHByb3BlcnR5
				IHR5cGUKICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgIDwvYW5ub3RhdGlv
				bj4KICAgICAgPHNpbXBsZVR5cGU+CiAgICAgICAgPHJlc3RyaWN0aW9uIGJhc2U9
				InN0cmluZyI+CiAgICAgICAgICA8ZW51bWVyYXRpb24gdmFsdWU9ImJvb2xlYW4i
				Lz4KICAgICAgICAgIDxlbnVtZXJhdGlvbiB2YWx1ZT0iaW50Ii8+CiAgICAgICAg
				ICA8ZW51bWVyYXRpb24gdmFsdWU9ImZsb2F0Ii8+CiAgICAgICAgICA8ZW51bWVy
				YXRpb24gdmFsdWU9InN0cmluZyIvPgogICAgICAgIDwvcmVzdHJpY3Rpb24+CiAg
				ICAgIDwvc2ltcGxlVHlwZT4KICAgIDwvYXR0cmlidXRlPgogICAgPGF0dHJpYnV0
				ZSBuYW1lPSJsaXN0IiB0eXBlPSJib29sZWFuIiB1c2U9Im9wdGlvbmFsIiBkZWZh
				dWx0PSJmYWxzZSI+CiAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgIDxkb2N1bWVu
				dGF0aW9uPgogICAgICAgICAgdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhlIHByb3Bl
				cnR5IGlzIGEgbGlzdCBvZiBzY2FsYXIgdmFsdWVzCiAgICAgICAgPC9kb2N1bWVu
				dGF0aW9uPgogICAgICA8L2Fubm90YXRpb24+CiAgICA8L2F0dHJpYnV0ZT4KICAg
				IDxhdHRyaWJ1dGUgbmFtZT0icmVxdWlyZWQiIHR5cGU9ImJvb2xlYW4iIHVzZT0i
				b3B0aW9uYWwiIGRlZmF1bHQ9ImZhbHNlIj4KICAgICAgPGFubm90YXRpb24+CiAg
				ICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgICB0cnVlIGlmIGEgdmFsdWUg
				bXVzdCBiZSBzdXBwbGllZCBmb3IgdGhlIHByb3BlcnR5LCBlaXRoZXIgaW4gdGhl
				CiAgICAgICAgICBjdXJyZW50IGNvbmZpZ3VyYXRpb24gZmlsZSBvciBlbHNld2hl
				cmUKICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgIDwvYW5ub3RhdGlvbj4K
				ICAgIDwvYXR0cmlidXRlPgogICAgPGF0dHJpYnV0ZSBuYW1lPSJzdGlja3kiIHR5
				cGU9ImJvb2xlYW4iIHVzZT0ib3B0aW9uYWwiIGRlZmF1bHQ9InRydWUiPgogICAg
				ICA8YW5ub3RhdGlvbj4KICAgICAgICA8ZG9jdW1lbnRhdGlvbj4KICAgICAgICAg
				IHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIHJlbWVt
				YmVyZWQgYW5kIGFwcGxpZWQgYXQKICAgICAgICAgIHRoZSBuZXh0IGJ1aWxkIGlm
				IGl0IGlzIG5vdCBleHBsaWNpdGx5IHNldAogICAgICAgIDwvZG9jdW1lbnRhdGlv
				bj4KICAgICAgPC9hbm5vdGF0aW9uPgogICAgPC9hdHRyaWJ1dGU+CiAgICA8YXR0
				cmlidXRlIG5hbWU9Im9iZnVzY2F0ZSIgdHlwZT0iYm9vbGVhbiIgdXNlPSJvcHRp
				b25hbCIgZGVmYXVsdD0iZmFsc2UiPgogICAgICA8YW5ub3RhdGlvbj4KICAgICAg
				ICA8ZG9jdW1lbnRhdGlvbj4KICAgICAgICAgIHRydWUgaWYgdGhlIHByb3BlcnR5
				J3MgdmFsdWUgc2hvdWxkIG5vdCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIKICAg
				ICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgIDwvYW5ub3RhdGlvbj4KICAgIDwv
				YXR0cmlidXRlPgogICAgPGF0dHJpYnV0ZSBuYW1lPSJ2YWx1ZSIgdHlwZT0ic3Ry
				aW5nIiB1c2U9Im9wdGlvbmFsIj4KICAgICAgPGFubm90YXRpb24+CiAgICAgICAg
				PGRvY3VtZW50YXRpb24+CiAgICAgICAgICBUaGUgcHJvcGVydHkgdmFsdWUKICAg
				ICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgIDwvYW5ub3RhdGlvbj4KICAgIDwv
				YXR0cmlidXRlPgogICAgPGF0dHJpYnV0ZSBuYW1lPSJzcGVjaWZpZWRBdCIgdHlw
				ZT0ic3RyaW5nIiB1c2U9Im9wdGlvbmFsIj4KICAgICAgPGFubm90YXRpb24+CiAg
				ICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgICA8IVtDREFUQVsKICAgICAg
				ICAgIFRoZSBsb2NhdGlvbiBvZiB0aGUgcHJvcGVydHkgc3BlY2lmaWNhdGlvbjsg
				dXNlZCBvbmx5IGJ5CiAgICAgICAgICBhdXRvLWdlbmVyYXRlZCBjb25maWd1cmF0
				aW9uIGZpbGVzIHRvIHJlY29yZCBhIGJ1aWxkIGNvbmZpZ3VyYXRpb247CiAgICAg
				ICAgICBjb25zaXN0cyBvZiBhIGZpbGUgcGF0aG5hbWUgb3Igb25lIG9mIHRoZSBz
				dHJpbmdzIDxjb21tYW5kLWxpbmU+IG9yCiAgICAgICAgICA8ZW52aXJvbm1lbnQ+
				CiAgICAgICAgICBdXT4KICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgIDwv
				YW5ub3RhdGlvbj4KICAgIDwvYXR0cmlidXRlPgogICAgPGF0dHJpYnV0ZSBuYW1l
				PSJzZXRBdCIgdHlwZT0ic3RyaW5nIiB1c2U9Im9wdGlvbmFsIj4KICAgICAgPGFu
				bm90YXRpb24+CiAgICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgICA8IVtD
				REFUQVsKICAgICAgICAgIFRoZSBzb3VyY2Ugb2YgdGhlIHByb3BlcnR5IHZhbHVl
				OyB1c2VkIG9ubHkgYnkgYXV0by1nZW5lcmF0ZWQKICAgICAgICAgIGNvbmZpZ3Vy
				YXRpb24gZmlsZXMgdG8gcmVjb3JkIGEgYnVpbGQgY29uZmlndXJhdGlvbjsgY29u
				c2lzdHMgb2YgYQogICAgICAgICAgZmlsZSBwYXRobmFtZSBvciBvbmUgb2YgdGhl
				IHN0cmluZ3MgPGNvbW1hbmQtbGluZT4gb3IKICAgICAgICAgIDxlbnZpcm9ubWVu
				dD4KICAgICAgICAgIF1dPgogICAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgICAg
				PC9hbm5vdGF0aW9uPgogICAgPC9hdHRyaWJ1dGU+CiAgICA8YXR0cmlidXRlIG5h
				bWU9ImVuY29kaW5nIiB1c2U9Im9wdGlvbmFsIj4KICAgICAgPGFubm90YXRpb24+
				CiAgICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgICBJbmRpY2F0ZXMgdGhl
				IGVuY29kaW5nIHNjaGVtZSB1c2VkIHRvIHJlY29yZCBiaW5hcnkgZGF0YSBvciBs
				aXN0cwogICAgICAgICAgb2YgcHJpbnRhYmxlIGNoYXJhY3RlcnMgd2hlbiBubyBz
				dWl0YWJsZSBzZXBhcmF0b3IgY2hhcmFjdGVyIGlzCiAgICAgICAgICBhdmFpbGFi
				bGUKICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgIDwvYW5ub3RhdGlvbj4K
				ICAgICAgPHNpbXBsZVR5cGU+CiAgICAgICAgPHJlc3RyaWN0aW9uIGJhc2U9InN0
				cmluZyI+CiAgICAgICAgICA8ZW51bWVyYXRpb24gdmFsdWU9Im5vbmUiLz4KICAg
				ICAgICAgIDxlbnVtZXJhdGlvbiB2YWx1ZT0iYmFzZTY0Ii8+CiAgICAgICAgPC9y
				ZXN0cmljdGlvbj4KICAgICAgPC9zaW1wbGVUeXBlPgogICAgPC9hdHRyaWJ1dGU+
				CiAgICA8YXR0cmlidXRlIG5hbWU9InNlcGFyYXRvciIgdXNlPSJvcHRpb25hbCI+
				CiAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAg
				ICAgICAgU2VwYXJhdG9yIGNoYXJhY3RlciB1c2VkIGZvciBlbmNvZGluZyBsaXN0
				czsgaWYgbm90IHNwZWNpZmllZCwKICAgICAgICAgIHN0cmluZ3Mgb2YgaW50ZXJu
				YWwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGFyZSBpbnRlcnByZXR0ZWQgYXMKICAg
				ICAgICAgIHNlcGFyYXRvcnMKICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAg
				IDwvYW5ub3RhdGlvbj4KICAgICAgPHNpbXBsZVR5cGU+CiAgICAgICAgPHJlc3Ry
				aWN0aW9uIGJhc2U9InN0cmluZyI+CiAgICAgICAgICA8bGVuZ3RoIHZhbHVlPSIx
				Ii8+CiAgICAgICAgPC9yZXN0cmljdGlvbj4KICAgICAgPC9zaW1wbGVUeXBlPgog
				ICAgPC9hdHRyaWJ1dGU+CiAgPC9jb21wbGV4VHlwZT4KCiAgPCEtLSBQYWNrYWdl
				cyBhbmQgY2hhbm5lbHMgLS0+CgogIDxlbGVtZW50IG5hbWU9InBhY2thZ2VHcm91
				cCIgc3Vic3RpdHV0aW9uR3JvdXA9InByOnRhcmdldCI+CiAgICA8YW5ub3RhdGlv
				bj4KICAgICAgPGRvY3VtZW50YXRpb24+QSBsaXN0IG9mIGZyYW1ld29yayBwYWNr
				YWdlcyBhbmQgY2hhbm5lbHM8L2RvY3VtZW50YXRpb24+CiAgICA8L2Fubm90YXRp
				b24+CiAgICA8Y29tcGxleFR5cGU+CiAgICAgIDxjaG9pY2UgbWluT2NjdXJzPSIw
				IiBtYXhPY2N1cnM9InVuYm91bmRlZCI+CiAgICAgICAgPGVsZW1lbnQgbmFtZT0i
				cGFja2FnZSI+CiAgICAgICAgICA8Y29tcGxleFR5cGU+CiAgICAgICAgICAgIDxz
				ZXF1ZW5jZSBtaW5PY2N1cnM9IjAiIG1heE9jY3Vycz0idW5ib3VuZGVkIj4KICAg
				ICAgICAgICAgICA8ZWxlbWVudCBuYW1lPSJwcm9wZXJ0eSI+CiAgICAgICAgICAg
				ICAgICA8Y29tcGxleFR5cGU+CiAgICAgICAgICAgICAgICAgIDxhdHRyaWJ1dGUg
				bmFtZT0ibmFtZSIgdHlwZT0icHI6aWRlbnRpZmllciIgdXNlPSJyZXF1aXJlZCIv
				PgogICAgICAgICAgICAgICAgICA8YXR0cmlidXRlIG5hbWU9InZhbHVlIiB0eXBl
				PSJzdHJpbmciIHVzZT0icmVxdWlyZWQiLz4KICAgICAgICAgICAgICAgIDwvY29t
				cGxleFR5cGU+CiAgICAgICAgICAgICAgPC9lbGVtZW50PgogICAgICAgICAgICA8
				L3NlcXVlbmNlPgogICAgICAgICAgICA8YXR0cmlidXRlIG5hbWU9Im5hbWUiIHR5
				cGU9InN0cmluZyIgdXNlPSJyZXF1aXJlZCI+CiAgICAgICAgICAgICAgPGFubm90
				YXRpb24+CiAgICAgICAgICAgICAgICA8ZG9jdW1lbnRhdGlvbj4KICAgICAgICAg
				ICAgICAgICAgVGhlIHBhY2thZ2UgbmFtZSwgaW4gYSBmcmFtZXdvcmstc3BlY2lm
				aWMgZm9ybWF0CiAgICAgICAgICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAg
				ICAgICAgICAgPC9hbm5vdGF0aW9uPgogICAgICAgICAgICA8L2F0dHJpYnV0ZT4K
				ICAgICAgICAgICAgPGF0dHJpYnV0ZSBuYW1lPSJtaW5WZXJzaW9uIiB0eXBlPSJz
				dHJpbmciPgogICAgICAgICAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgICAgICAg
				ICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgICAgICAgICAgIFRoZSBtaW5pbXVt
				IHBhY2thZ2UgdmVyc2lvbiwgaW4gYSBmcmFtZXdvcmstc3BlY2lmaWMgZm9ybWF0
				CiAgICAgICAgICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgICAgICAgICAg
				PC9hbm5vdGF0aW9uPgogICAgICAgICAgICA8L2F0dHJpYnV0ZT4KICAgICAgICAg
				ICAgPGF0dHJpYnV0ZSBuYW1lPSJtYXhWZXJzaW9uIiB0eXBlPSJzdHJpbmciPgog
				ICAgICAgICAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgICAgICAgICAgPGRvY3Vt
				ZW50YXRpb24+CiAgICAgICAgICAgICAgICAgIFRoZSBtYXhpbXVtIHBhY2thZ2Ug
				dmVyc2lvbiwgaW4gYSBmcmFtZXdvcmstc3BlY2lmaWMgZm9ybWF0CiAgICAgICAg
				ICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgICAgICAgICAgPC9hbm5vdGF0
				aW9uPgogICAgICAgICAgICA8L2F0dHJpYnV0ZT4KICAgICAgICAgICAgPGF0dHJp
				YnV0ZSBuYW1lPSJjaGFubmVsIiB0eXBlPSJhbnlVUkkiPgogICAgICAgICAgICAg
				IDxhbm5vdGF0aW9uPgogICAgICAgICAgICAgICAgPGRvY3VtZW50YXRpb24+CiAg
				ICAgICAgICAgICAgICAgIFRoZSBwYWNrYWdlIGNoYW5uZWwKICAgICAgICAgICAg
				ICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgICAgICAgICAgICA8L2Fubm90YXRpb24+
				CiAgICAgICAgICAgIDwvYXR0cmlidXRlPgogICAgICAgICAgPC9jb21wbGV4VHlw
				ZT4KICAgICAgICA8L2VsZW1lbnQ+CiAgICAgICAgPGVsZW1lbnQgbmFtZT0iY2hh
				bm5lbCI+CiAgICAgICAgICA8Y29tcGxleFR5cGU+CiAgICAgICAgICAgIDxhdHRy
				aWJ1dGUgbmFtZT0idXJsIiB0eXBlPSJhbnlVUkkiIHVzZT0icmVxdWlyZWQiPgog
				ICAgICAgICAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgICAgICAgICAgPGRvY3Vt
				ZW50YXRpb24+CiAgICAgICAgICAgICAgICAgIFRoZSBjaGFubmVsIFVSTAogICAg
				ICAgICAgICAgICAgPC9kb2N1bWVudGF0aW9uPgogICAgICAgICAgICAgIDwvYW5u
				b3RhdGlvbj4KICAgICAgICAgICAgPC9hdHRyaWJ1dGU+CiAgICAgICAgICAgIDxh
				dHRyaWJ1dGUgbmFtZT0idXNlcm5hbWUiIHR5cGU9InN0cmluZyI+CiAgICAgICAg
				ICAgICAgPGFubm90YXRpb24+CiAgICAgICAgICAgICAgICA8ZG9jdW1lbnRhdGlv
				bj4KICAgICAgICAgICAgICAgICAgVGhlIHVzZXJuYW1lLCBpZiBhbnksIHJlcXVp
				cmVkIGZvciB0aGUgcGFja2FnZSBtYW5hZ2VyIHRvCiAgICAgICAgICAgICAgICAg
				IGFjY2VzcyB0aGUgY2hhbm5lbAogICAgICAgICAgICAgICAgPC9kb2N1bWVudGF0
				aW9uPgogICAgICAgICAgICAgIDwvYW5ub3RhdGlvbj4KICAgICAgICAgICAgPC9h
				dHRyaWJ1dGU+CiAgICAgICAgICAgIDxhdHRyaWJ1dGUgbmFtZT0icGFzc3dvcmQi
				IHR5cGU9InN0cmluZyI+CiAgICAgICAgICAgICAgPGFubm90YXRpb24+CiAgICAg
				ICAgICAgICAgICA8ZG9jdW1lbnRhdGlvbj4KICAgICAgICAgICAgICAgICAgVGhl
				IHVzZXJuYW1lLCBpZiBhbnksIHJlcXVpcmVkIGZvciB0aGUgcGFja2FnZSBtYW5h
				Z2VyIHRvCiAgICAgICAgICAgICAgICAgIGFjY2VzcyB0aGUgY2hhbm5lbAogICAg
				ICAgICAgICAgICAgPC9kb2N1bWVudGF0aW9uPgogICAgICAgICAgICAgIDwvYW5u
				b3RhdGlvbj4KICAgICAgICAgICAgPC9hdHRyaWJ1dGU+CiAgICAgICAgICA8L2Nv
				bXBsZXhUeXBlPgogICAgICAgIDwvZWxlbWVudD4KICAgICAgPC9jaG9pY2U+CiAg
				ICAgIDxhdHRyaWJ1dGVHcm91cCByZWY9InByOnRhcmdldEF0dHJpYnV0ZXMiLz4K
				ICAgICAgPGF0dHJpYnV0ZSBuYW1lPSJmcmFtZXdvcmsiIHR5cGU9InByOmZyYW1l
				d29yayIgdXNlPSJyZXF1aXJlZCIvPgogICAgICA8YXR0cmlidXRlIG5hbWU9ImZy
				YW1ld29ya01pblZlcnNpb24iIHR5cGU9InN0cmluZyIvPgogICAgICA8YXR0cmli
				dXRlIG5hbWU9ImZyYW1ld29ya01heFZlcnNpb24iIHR5cGU9InN0cmluZyIvPgog
				ICAgPC9jb21wbGV4VHlwZT4KICA8L2VsZW1lbnQ+CgogIDwhLS0gVHlwZXMgYW5k
				IGVsZW1lbnRzIGZvciBhdXRvbWF0ZWQgdGVzdHMgLS0+CgogIDxlbGVtZW50IG5h
				bWU9InRlc3QiIHN1YnN0aXR1dGlvbkdyb3VwPSJwcjp0YXJnZXQiPgogICAgPGFu
				bm90YXRpb24+CiAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgIFJlcHJlc2Vu
				dHMgYSB0ZXN0IHN1aXRlCiAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgIDwvYW5u
				b3RhdGlvbj4KICAgIDxjb21wbGV4VHlwZT4KICAgICAgPGNob2ljZSBtaW5PY2N1
				cnM9IjAiIG1heE9jY3Vycz0idW5ib3VuZGVkIj4KICAgICAgICA8ZWxlbWVudCBy
				ZWY9InByOnN1aXRlIi8+CiAgICAgICAgPGVsZW1lbnQgbmFtZT0iaW5jbHVkZSI+
				CiAgICAgICAgICA8Y29tcGxleFR5cGU+CiAgICAgICAgICAgIDxhdHRyaWJ1dGUg
				bmFtZT0ic3JjIiB0eXBlPSJhbnlVUkkiIHVzZT0icmVxdWlyZWQiPgogICAgICAg
				ICAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgICAgICAgICAgPGRvY3VtZW50YXRp
				b24+CiAgICAgICAgICAgICAgICAgIFRoZSBwYXRobmFtZSBvZiBhbiBYTUwgZG9j
				dW1lbnQgIGNvbmZvcm1pbmcgdG8gdGhpcyBzY2hlbWEKICAgICAgICAgICAgICAg
				ICAgd2hvc2Ugcm9vdCBlbGVtZW50IGlzICd0ZXN0JwogICAgICAgICAgICAgICAg
				PC9kb2N1bWVudGF0aW9uPgogICAgICAgICAgICAgIDwvYW5ub3RhdGlvbj4KICAg
				ICAgICAgICAgPC9hdHRyaWJ1dGU+CiAgICAgICAgICA8L2NvbXBsZXhUeXBlPgog
				ICAgICAgIDwvZWxlbWVudD4KICAgICAgPC9jaG9pY2U+CiAgICAgIDxhdHRyaWJ1
				dGVHcm91cCByZWY9InByOnRhcmdldEF0dHJpYnV0ZXMiLz4KICAgIDwvY29tcGxl
				eFR5cGU+CiAgPC9lbGVtZW50PgoKICA8ZWxlbWVudCBuYW1lPSJzdWl0ZSI+CiAg
				ICA8YW5ub3RhdGlvbj4KICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgUmVw
				cmVzZW50cyBhIHRlc3Qgc3VpdGUgb3IgYSBsaW5rIHRvIGEgZG9jdW1lbnQgZGVm
				aW5pbmcgYSB0ZXN0IHN1aXRlLgogICAgICAgIElmIHRoZSBhdHRyaWJ1dGUgImNv
				bW1hbmQiIGlzIHByZXNlbnQsIGl0IG11c3QgYmUgdGhlIHNvbGUgYXR0cmlidXRl
				LgogICAgICAgIE90aGVyd2lzZSwgdGhlIGF0dHJpdGJ1dGUgImNsYXNzIiBtdXN0
				IGJlIHByZXNlbnQuCiAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgIDwvYW5ub3Rh
				dGlvbj4KICAgIDxjb21wbGV4VHlwZT4KICAgICAgPHNlcXVlbmNlPgogICAgICAg
				IDxlbGVtZW50IG5hbWU9InBhcmFtIiBtaW5PY2N1cnM9IjAiIG1heE9jY3Vycz0i
				dW5ib3VuZGVkIj4KICAgICAgICAgIDxhbm5vdGF0aW9uPgogICAgICAgICAgICA8
				ZG9jdW1lbnRhdGlvbj4KICAgICAgICAgICAgICBSZXByZXNlbnRzIGEgY29uc3Ry
				dWN0b3IgcGFyYW1ldGVyCiAgICAgICAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAg
				ICAgICAgIDwvYW5ub3RhdGlvbj4KICAgICAgICAgIDxjb21wbGV4VHlwZT4KICAg
				ICAgICAgICAgPGF0dHJpYnV0ZSBuYW1lPSJuYW1lIiB0eXBlPSJwcjppZGVudGlm
				aWVyIiB1c2U9InJlcXVpcmVkIj4KICAgICAgICAgICAgICA8YW5ub3RhdGlvbj4K
				ICAgICAgICAgICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgICAgICAgICAg
				ICBUaGUgcGFyYW1ldGVyIG5hbWUKICAgICAgICAgICAgICAgIDwvZG9jdW1lbnRh
				dGlvbj4KICAgICAgICAgICAgICA8L2Fubm90YXRpb24+CiAgICAgICAgICAgIDwv
				YXR0cmlidXRlPgogICAgICAgICAgICA8YXR0cmlidXRlIG5hbWU9InZhbHVlIiB1
				c2U9InJlcXVpcmVkIj4KICAgICAgICAgICAgICA8YW5ub3RhdGlvbj4KICAgICAg
				ICAgICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgICAgICAgICAgICBUaGUg
				cGFyYW1ldGVyIHZhbHVlCiAgICAgICAgICAgICAgICA8L2RvY3VtZW50YXRpb24+
				CiAgICAgICAgICAgICAgPC9hbm5vdGF0aW9uPgogICAgICAgICAgICA8L2F0dHJp
				YnV0ZT4KICAgICAgICAgIDwvY29tcGxleFR5cGU+CiAgICAgICAgPC9lbGVtZW50
				PgogICAgICA8L3NlcXVlbmNlPgogICAgICA8YXR0cmlidXRlIG5hbWU9ImNsYXNz
				UGF0aCIgdHlwZT0iYW55VVJJIiB1c2U9Im9wdGlvbmFsIj4KICAgICAgICA8YW5u
				b3RhdGlvbj4KICAgICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgICAgICBU
				aGUgbG9jYXRpb24gb2YgdGhlIHRlc3Qgc3VpdGUncyBjb2RlOyBtYXkgYmUgb21p
				dHRlZCBpZiB0aGUKICAgICAgICAgICAgc3VpdGUgY2FuIGJlIGZvdW5kIHdpdGgg
				YXV0b2xvYWQKICAgICAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgICAgICA8L2Fu
				bm90YXRpb24+CiAgICAgIDwvYXR0cmlidXRlPgogICAgICA8YXR0cmlidXRlIG5h
				bWU9ImNsYXNzIiB0eXBlPSJzdHJpbmciIHVzZT0ib3B0aW9uYWwiPgogICAgICAg
				IDxhbm5vdGF0aW9uPgogICAgICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAg
				ICAgIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyBpbXBsZW1lbnRpbmcgdGhlIHRlc3Qg
				c3VpdGUKICAgICAgICAgIDwvZG9jdW1lbnRhdGlvbj4KICAgICAgICA8L2Fubm90
				YXRpb24+CiAgICAgIDwvYXR0cmlidXRlPgogICAgICA8YXR0cmlidXRlIG5hbWU9
				Imxhbmd1YWdlIiB0eXBlPSJzdHJpbmciIGRlZmF1bHQ9InBocCI+CiAgICAgICAg
				PGFubm90YXRpb24+CiAgICAgICAgICA8ZG9jdW1lbnRhdGlvbj4KICAgICAgICAg
				ICAgVGhlIGxhbmd1YWdlIGluIHdoaWNoIHRoZSB0ZXN0IHN1aXRlIGlzIGltcGxl
				bWVudGVkCiAgICAgICAgICA8L2RvY3VtZW50YXRpb24+CiAgICAgICAgPC9hbm5v
				dGF0aW9uPgogICAgICA8L2F0dHJpYnV0ZT4KICAgICAgPGF0dHJpYnV0ZSBuYW1l
				PSJjb21tYW5kIiB0eXBlPSJzdHJpbmciIHVzZT0ib3B0aW9uYWwiPgogICAgICAg
				IDxhbm5vdGF0aW9uPgogICAgICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAg
				ICAgIFRoZSBjb21tYW5kIHRvIHJ1bgogICAgICAgICAgPC9kb2N1bWVudGF0aW9u
				PgogICAgICAgIDwvYW5ub3RhdGlvbj4KICAgICAgPC9hdHRyaWJ1dGU+CiAgICA8
				L2NvbXBsZXhUeXBlPgogIDwvZWxlbWVudD4KCiAgPCEtLSBCdWlsZCB0b29scyAt
				LT4KCiAgPGVsZW1lbnQgbmFtZT0idG9vbCI+CiAgICA8YW5ub3RhdGlvbj4KICAg
				ICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgRGVmaW5lcyBhIGJ1aWxkIHRvb2wg
				cmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIGVsZW1lbnRzIG9mIGNlcnRhaW4KICAg
				ICAgICB0eXBlcyBpbiBhIHByb2plY3QgZGVmaW5pdGlvbiBmaWxlCiAgICAgIDwv
				ZG9jdW1lbnRhdGlvbj4KICAgIDwvYW5ub3RhdGlvbj4KICAgIDxjb21wbGV4VHlw
				ZT4KICAgICAgPGF0dHJpYnV0ZSBuYW1lPSJjbGFzcyIgdHlwZT0icHI6Y29tcG91
				bmRJZGVudGlmaWVyIiB1c2U9InJlcXVpcmVkIj4KICAgICAgICA8YW5ub3RhdGlv
				bj4KICAgICAgICAgIDxkb2N1bWVudGF0aW9uPgogICAgICAgICAgICBUaGUgbmFt
				ZSBvZiBhIFBIUCBjbGFzcyBpbXBsZW1lbnRpbmcgQ29kZVJhZ2VcQnVpbGRcVG9v
				bAogICAgICAgICAgPC9kb2N1bWVudGF0aW9uPgogICAgICAgIDwvYW5ub3RhdGlv
				bj4KICAgICAgPC9hdHRyaWJ1dGU+CiAgICAgIDxhdHRyaWJ1dGUgbmFtZT0iY2xh
				c3NQYXRoIiB0eXBlPSJhbnlVUkkiPgogICAgICAgIDxhbm5vdGF0aW9uPgogICAg
				ICAgICAgPGRvY3VtZW50YXRpb24+CiAgICAgICAgICAgIFRoZSBsb2NhdGlvbiBv
				ZiB0aGUgZmlsZSBkZWZpbmluZyB0aGUgUEhQIGNsYXNzIHNwZWNpZmllZCBieQog
				ICAgICAgICAgICB0aGUgYXR0cmlieXRlICJjbGFzcyIsIGlmIGl0IGNhbm5vdCBi
				ZSBmb3VuZCBieSBhdXRvbG9hZGluZy4KICAgICAgICAgIDwvZG9jdW1lbnRhdGlv
				bj4KICAgICAgICA8L2Fubm90YXRpb24+CiAgICAgIDwvYXR0cmlidXRlPgogICAg
				PC9jb21wbGV4VHlwZT4KICA8L2VsZW1lbnQ+Cgo8L3NjaGVtYT4K
__ENDRESOURCE__;
			break;
		case 'run-coderage':
			$content = <<< __ENDRESOURCE__
				IyEvYmluL3NoCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
				IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMg
				RGVmaW5lcyBmdW5jdGlvbiB1c2VkIGJ5IENvZGVSYWdlIHNoZWxsIHNjcmlwdHMK
				IwojIEZpbGU6ICAgICAgICBDb2RlUmFnZS9CdWlsZC9SZXNvdXJjZS9ydW4tY29k
				ZXJhZ2UKIyBEYXRlOiAgICAgICAgU2F0IFNlcCAyNyAxMTo0NDozMyBNRFQgMjAw
				OAojIE5vdGljZTogICAgICBUaGlzIGRvY3VtZW50IGNvbnRhaW5zIGNvbmZpZGVu
				dGlhbCBpbmZvcm1hdGlvbiBhbmQKIyAgICAgICAgICAgICAgdHJhZGUgc2VjcmV0
				cwojCiMgQ29weXJpZ2h0OiAgIDIwMTUgQ291bnNlbE5vdywgTExDCiMgQXV0aG9y
				OiAgICAgIEpvbmF0aGFuIFR1cmthbmlzCiMgTGljZW5zZTogICAgIEFsbCByaWdo
				dHMgcmVzZXJ2ZWQKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
				IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoK
				IyBHbG9iYWxzCmNvZGVyYWdlX2ZpbGVzPSJCaW4gQ29kZVJhZ2UucGhwIgoKICAg
				ICMjIyMjIyMjIyMjIyMjIyMjIyMjCiAgICAjIGZpbmR0b29scwogICAgIyMjIyMj
				IyMjIyMjIyMjIyMjIyMKCiMgT3V0cHV0cyB0aGUgcGF0aCBvZiB0aGUgZGlyZWN0
				b3J5IGNvbnRhaW5pbmcgdGhlIENvZGVSYWdlIGJvb3RzdHJhcCBmaWxlcwpmaW5k
				dG9vbHMoKQp7CiAgICBsb2NhbCBwaHAgaW5jbHVkZSBwYXRoCgogICAgIyBGZXRj
				aCBQSFAgY29tbWFuZC1saW5lIGV4ZWN1dGFibGUKICAgIHBocD0kKGZpbmRwaHAp
				IHx8IHJldHVybiAxCgogICAgIyBGZXRjaCBQSFAgaW5jbHVkZSBwYXRoCiAgICBp
				bmNsdWRlPSQocGhwIC1yICJlY2hvIGluaV9nZXQoJ2luY2x1ZGVfcGF0aCcpOyIp
				CgogICAgZXZhbCBzZXQgLS0gXCIkKGVjaG8gIiRpbmNsdWRlIiB8IHNlZCAtZSdz
				LzovIiAiL2cnKVwiCiAgICBmb3IgcGF0aCBpbiAiJEAiIDsgZG8KICAgICAgICBp
				ZiB0ZXN0cGF0aCAiJHBhdGgiIDsgdGhlbgogICAgICAgICAgICBlY2hvICIkcGF0
				aCIKICAgICAgICAgICAgcmV0dXJuIDAKICAgICAgICBmaQogICAgZG9uZQogICAg
				ZXhpdCAxCn0KCiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAgIyBmaW5kcGhw
				CiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIwoKIyBSZXR1cm5zIHBhdGggb2YgdGhl
				IFBIUCBjb21tYW5kLWxpbmUtZXhlY3V0YWJsZQpmaW5kcGhwKCkKewogICAgbG9j
				YWwgcGhwPSQod2hpY2ggcGhwKQogICAgaWYgWyAteiAiJHBocCIgXSA7IHRoZW4K
				ICAgICAgICBlY2hvICJDYW4ndCBmaW5kIFBIUCBjb21tYW5kLWxpbmUgZXhlY3V0
				YWJsZS4iIFwKICAgICAgICAgICAgIlBsZWFzZSBhZGQgaXQgdG8geW91ciBQQVRI
				LiIgPiYyCiAgICAgICAgcmV0dXJuIDEKICAgIGZpCiAgICBsb2NhbCBzYXBpPSQo
				IiRwaHAiIC1yICJlY2hvIHBocF9zYXBpX25hbWUoKTsiKQogICAgaWYgWyAiJHNh
				cGkiICE9ICJjbGkiIF0gOyB0aGVuCiAgICAgICAgZWNobyAiUHJvZ3JhbSAnJHBo
				cCcgaW4gUEFUSCBpcyBub3QgdGhlIFBIUCBjb21tYW5kLWxpbmUiIFwKICAgICAg
				ICAgICAgImV4ZWN1dGFibGUuIiA+JjIKICAgICAgICByZXR1cm4gMQogICAgZmkK
				ICAgIGVjaG8gIiRwaHAiCn0KCiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIwogICAg
				IyB0ZXN0cGF0aAogICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMKCiMgVXNhZ2U6IHRl
				c3QtcGF0aCBwYXRoCiMgUmV0dXJucyAwIGlmIHRoZSBnaXZlbiBwYXRoIGlzIHRo
				ZSByb290IGRpcmVjdG9yeSBvZiB0aGUgQ29kZVJhZ2Ugc2hhcmVkIHRvb2xzCnRl
				c3RwYXRoKCkKewogICAgbG9jYWwgcGF0aD0iJDEiIGZpbGUKICAgIGZvciBmaWxl
				IGluICRjb2RlcmFnZV9maWxlcyA7IGRvCiAgICAgICAgaWYgISBbIC1lICIkcGF0
				aC8kZmlsZSIgXSA7IHRoZW4KICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICBm
				aQogICAgZG9uZQogICAgcmV0dXJuIDAKfQoKICAgICMjIyMjIyMjIyMjIyMjIyMj
				IyMjCiAgICAjIFNjcmlwdCBCb2R5CiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIwoK
				CnRvb2w9IiQxIgpzaGlmdAoKaWYgISBwYXRoPSQoZmluZHRvb2xzKSA7IHRoZW4K
				ICAgIGVjaG8gIkNhbid0IGZpbmQgQ29kZVJhZ2UgdG9vbHMgaW4gUEhQIGluY2x1
				ZGUgcGF0aCIgPiYyCiAgICBleGl0CmZpCgpwaHAgIiRwYXRoL0Jpbi8kdG9vbC5w
				aHAiICIkQCIK
__ENDRESOURCE__;
			break;
		case 'run-coderage.bat':
			$content = <<< __ENDRESOURCE__
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6OjoKOjoKOjogRXhlY3V0ZXMg
				dGhlIHRvb2wgUEhQIHNwZWNpZmllZCBvbiB0aGUgY29tbWFuZCBsaW5lLgo6Ogo6
				OiBGaWxlOiAgICAgICAgQ29kZVJhZ2UvQnVpbGQvUmVzb3VyY2UvcnVuLWNvZGVy
				YWdlLmJhdAo6OiBEYXRlOiAgICAgICAgU3VuIEphbiAgNCAyMzo0NzozNCBNU1Qg
				MjAwOQo6OiBOb3RpY2U6ICAgICAgVGhpcyBkb2N1bWVudCBjb250YWlucyBjb25m
				aWRlbnRpYWwgaW5mb3JtYXRpb24gYW5kCjo6ICAgICAgICAgICAgICB0cmFkZSBz
				ZWNyZXRzCjo6Cjo6IENvcHlyaWdodDogICAyMDA4IENvZGVSYWdlCjo6IEF1dGhv
				cjogICAgICBKb25hdGhhbiBUdXJrYW5pcwo6OiBMaWNlbnNlOiAgICAgQWxsIHJp
				Z2h0cyByZXNlcnZlZAo6Ogo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6
				Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6
				OgoKQGVjaG8gb2ZmCgpzZXQgVE9PTE5BTUU9JTEKc2V0IENPREVSQUdFX0ZJTEVT
				PUJpbiBDb2RlUmFnZS5waHAKCjo6IEZpbmQgcGhwLmV4ZSBhbmQgc3RvcmUgaXQg
				aW4gUEhQX0NMSQpmb3IgJSVYIGluIChwaHAuZXhlKSBkbyBzZXQgUEhQX0NMST0l
				JX4kUEFUSDpYCmlmICIlUEhQX0NMSSUiIGVxdSAiIiAoCiAgICBlY2hvIENhbid0
				IGZpbmQgUEhQIGNvbW1hbmQtbGluZSBleGVjdXRhYmxlLgogICAgZWNobyBQbGVh
				c2UgYWRkIGl0IHRvIHlvdXIgUEFUSAogICAgZ290byBFTkQKKQoKOjogTWFrZSBz
				dXJlIFBIUF9DTEkgaXMgcmVhbGx5IHRoZSBjb21tYW5kLWxpbmUgZXhlY3V0YWJs
				ZQpmb3IgL0YgInVzZWJhY2txIiAlJVggaW4gKGBwaHAgLXIgImVjaG8gcGhwX3Nh
				cGlfbmFtZSgpOyJgKSBkbyBzZXQgU0FQST0lJVgKaWYgIiVTQVBJJSIgbmVxICJj
				bGkiICgKICAgIGVjaG8gUHJvZ3JhbSAnJVBIUF9DTEklJyBpbiBQQVRIIGlzIG5v
				dCB0aGUgUEhQIGNvbW1hbmQtbGluZSBleGVjdXRhYmxlCiAgICBnb3RvIEVORAop
				Cgo6OiBGaW5kIFBIUCBpbmNsdWRlX3BhdGggYW5kIHN0b3JlIGl0IGluIElOQ0xV
				REVfUEFUSApmb3IgL0YgInVzZWJhY2txIiAlJVggaW4gKGBwaHAgLXIgImVjaG8g
				aW5pX2dldCgnaW5jbHVkZV9wYXRoJyk7ImApIGRvIHNldCBJTkNMVURFX1BBVEg9
				JSVYCgo6OiBTZWFyY2ggZm9yIENvZGVSYWdlLnBocCBpbiBJTkNMVURFX1BBVEgs
				IGFuZCBzdG9yZSB0aGUgY29udGFpbmluZyBkaXJlY3RvcnkKOjogaW4gQ09ERVJB
				R0UKZm9yICUlWCBpbiAoQ29kZVJhZ2UucGhwKSBkbyBzZXQgQ09ERVJBR0U9JSV+
				ZHAkSU5DTFVERV9QQVRIOlgKCjo6IENoZWNrIHRoYXQgZWFjaCBmaWxlIGluIENP
				REVSQUdFX0ZJTEVTIGV4aXN0cyBpbiB0aGUgZGlyZWN0b3J5IENPREVSQUdFCmZv
				ciAlJVggaW4gKCVDT0RFUkFHRV9GSUxFUyUpIGRvICgKICAgIGlmIG5vdCBleGlz
				dCAlQ09ERVJBR0UlXCUlWCAoCiAgICAgICAgZWNobyBDYW4ndCBmaW5kIENvZGVS
				YWdlIHRvb2xzIGluIFBIUCBpbmNsdWRlIHBhdGgKICAgICAgICBnb3RvIEVORAog
				ICAgKQopCgo6OiBDb25zdHJ1Y3QgY29tbWFuZCBsaW5lCnNldCBhcmd2PXBocCAl
				Q09ERVJBR0UlQmluXCVUT09MTkFNRSUucGhwCjpzdGFydAppZiAvaSBfJTIgZXF1
				IF8gZ290byBlbmQKc2V0IGFyZ3Y9JWFyZ3YlICUyCnNoaWZ0CmdvdG8gOnN0YXJ0
				CjplbmQKCjo6IENsZWFyIGVudmlyb25tZW50CnNldCBDT0RFUkFHRT0Kc2V0IENP
				REVSQUdFX0ZJTEVTPQpzZXQgSU5DTFVERV9QQVRIPQpzZXQgUEhQX0NMST0Kc2V0
				IFNBUEk9CnNldCBUT09MTkFNRT0KCjo6IFJ1biBjb21tYW5kIGxpbmUKJWFyZ3Yl
				Cgo6RU5ECg==
__ENDRESOURCE__;
			break;
		default:
			throw new \Exception("No such resource: $file");
		}
		return base64_decode($content);
	}
	static function loadFile(\Makeme\Build\Run $run, $file)
	{
		$temp = \Makeme\File\temp();
		$contents = self::load($run, $file);
		file_put_contents($temp, $contents);
		return $temp;
	}
}

namespace Makeme\File;

function searchIncludePath($path, $ignoreRelativePaths = false)
{
	$include = ini_get('include_path');
	$search = [];
	foreach (explode(PATH_SEPARATOR, ini_get('include_path')) as $p) {
		if (isAbsolute($p)) {
			$search[] = $p;
		} elseif (!$ignoreRelativePaths) {
			if ($p2 = find($p, getcwd(), false, false))
				$search[] = $p2;
		}
	}
	return find($path, $search, false, false);
}
namespace Makeme\File;
function isAbsolute($path)
{
	return \Makeme\Util\os() == 'posix' ?
		$path && $path[0] == '/' :
		$path && $path[0] == '/' ||
			$path && $path[0] == '\\' ||
			strlen($path) > 1 && ctype_alpha($path[0]) && $path[1] == ':';
}
namespace Makeme\Util;
function os()
{
	static $os;
	if (!$os)
		$os = strcasecmp(substr(PHP_OS, 0, 3), 'WIN') == 0 ?
			'windows' :
			'posix';
	return $os;
}
namespace Makeme\File;

use Makeme\Config;

function find(
	$path, $search = null, $searchProjectRoot = null, $throwOnError = false)
{
	$c = $path[0];
	if ( $c == '/' || $c == '\\' ||
		 ( strlen($path) > 1 && $path[1] == ':' &&
		   ( ord($c) >= 65 && ord($c) < 91 ||
			 ord($c) >= 97 && ord($c) < 123 ) ) )
	{
		return file_exists($path) ? $path : null;
	}

	if ($searchProjectRoot === null)
		$searchProjectRoot = $search === null;
	$search =
		$search !== null ?
			(is_string($search) ? [$search] : $search) :
			[];
	if ($searchProjectRoot) {
		$config = Config::current();
		$project_root = $config->getRequiredProperty('project_root');
		$tools_root = $config->getRequiredProperty('tools_root');
		array_push($search, $project_root);
		if ($tools_root != $project_root)
			array_push($search, $tools_root);
	}
	foreach ($search as $dir)
		if (file_exists("$dir/$path"))
			return "$dir/$path";
	if ($throwOnError) {
		$paths = sizeof($search) ?
			" (searching '" . join("', '", $search) . "')" :
			'';
		throw new \Exception("No such file: $path{$paths}");
	}
	return null;
}
namespace Makeme;

use Exception;
use Throwable;
class Error extends Exception {
	const DEFAULT_MESSAGE = 'An error occurred';
	const DEFAULT_STATUS = 'INTERNAL_ERROR';
	private $details;
	private $status;
	private $inner;
	private $logged = false;
	private $trace;
	private static $statusCodes;
	function __construct()
	{
		$args = func_get_args();
		$options = is_array($args[0]) ?
			$args[0] :
			[
				'message' => $args[0],
				'code' => isset($args[1]) ? $args[1] : null,
				'inner' => isset($args[2]) ? $args[2] : null
			];
		if (isset($options['status'])) {
			self::loadStatusCodes();
			if ( sizeof(self::$statusCodes) > 0 &&
				 !isset(self::$statusCodes[$options['status']]) )
			{
				throw new Error("Unknown status code: {$options['status']}");
			}
		}
		if (!isset($options['status'])) {
			if ( isset($options['inner']) &&
				 $options['inner'] instanceof Error )
			{
				$options['status'] = $options['inner']->status();
			} else {
				$options['status'] = self::DEFAULT_STATUS;
			}
		}
		if (!isset($options['message']))
			$options['message'] = self::translateStatus($options['status']);
		if (!isset($options['details']))
			$options['details'] = $options['message'];
		if (!isset($options['inner']))
			$options['inner'] = null;
		parent::__construct($options['message'], 0, $options['inner']);
		$this->details = $options['details'];
		$this->status = $options['status'];
	}
	function message()
	{
		return $this->getMessage();
	}
	function details()
	{
		return $this->details;
	}
	function status()
	{
		return $this->status;
	}
	function statusEquals($code)
	{
		self::loadStatusCodes();
		if ( sizeof(self::statusCodes) > 0 &&
			 !isset(self::$statusCodes[$code]) )
		{
			throw new Error("Unknown status code: $code");
		}
		return $this->code == $code;
	}
	function inner()
	{
		return $this->getPrevious();
	}
	function trace()
	{
		return $this->trace ? $this->trace : $this->getTrace();
	}
	function logged()
	{
		return $this->logged;
	}
	function setLogged()
	{
		$this->logged = true;
	}
	function log($log)
	{
		if (!$this->logged) {
			$this->logged = true;
			if ($inner = $this->inner()) {
				if ($inner instanceof Error)
					$inner->log($log);
				else
					$log->logError($inner);
			}
			$log->logError($this);
		}
	}
	static function wrap(Throwable $error)
	{
		return $error instanceof Error ?
			$error :
			new Error([
					'status' => 'INTERNAL_ERROR',
					'inner' => $error
				]);
	}
	static function translateStatus($code)
	{
		self::loadStatusCodes();
		return isset(self::$statusCodes[$code]) ?
			self::$statusCodes[$code]['message'] :
			self::DEFAULT_MESSAGE;
	}
	static function registerStatus($code, $message)
	{
		if (isset(self::$statusCodes[$code]))
			throw new Error("The status '$code' is already defined");
		self::$statusCodes[$code] =
			[
				'code' => $code,
				'message' => $message
			];
	}
	private static function loadStatusCodes()
	{
		if (self::$statusCodes === null) {
			require_once('CodeRage.php');
			self::$statusCodes = [];
			$config = Config::current();
			$definitions =
				$config->getRequiredProperty('project_root') .
				'/.coderage/error.php';
			if (file_exists($definitions)) {
				File\checkReadable($definitions);
				include($definitions);
			}
		}
	}
	function nativeDataEncode(Util\NativeDataEncoder $encoder)
	{
		$result = (object)
			[
				'status' => $this->status,
				'message' => $this->message
			];
		if ($this->details != $this->message)
			$result->details = $this->details;
		if ($this->inner !== null)
			$result->inner = $this->inner;
		return $result;
	}
	function __call($method, $args)
	{
		$args; // Suppress 'unused function parameter' warning
		if ($method == 'throw') {
			$trace = debug_backtrace();
			array_shift($trace);
			$this->trace = $trace;
			throw $this;
		} else {
			throw new Exception("No such method: Makeme\\Error::$method");
		}
	}
	function __toString()
	{
		$result = '';
		for ( $error = $this, $i = 0;
			  $error instanceof Error;
			  $error = $error->inner(), ++$i )
		{
			if ($i == 0) {
				$result .= 'Status: ';
			} else {
				$result .= ' ---> ';
			}
			$result .= $error->status;
		}
		$result .= "\n\n";
		for ( $error = $this, $i = 0;
			  $error instanceof Error;
			  $error = $error->inner(), ++$i )
		{
			if ($i == 0) {
				$result .= 'Message: ';
			} else {
				$result .= ' ---> ';
			}
			$result .= $error->details;
		}
		$result .= "\n\n";
		for ( $error = $this, $i = 1, $lastTrace = null;
			  $error instanceof Error;
			  $error = $error->inner(), ++$i )
		{
			$trace = $error->getTraceAsString();
			$result .= "Stack Trace $i:\n";
			$result .= $trace != $lastTrace ?
				$error->getTraceAsString() . "\n" :
				"<same as above>\n";
			$lastTrace = $trace;
		}
		return $result;
	}
}
namespace Makeme\File;

function checkReadable($path)
{
	checkFile($path, 0b100);
}
namespace Makeme\Util;

use Makeme\Error;
function validate($value, $type, $label, $nothrow = false)
{
	static $matchType;
	if ($matchType === null) {
		$atom =
			'(boolean|int|float|number|string|scalar|array|list|map|object|callable|regex|
				  \\\?[_a-zA-Z][_a-zA-Z0-9]*(\\\[_a-zA-Z][_a-zA-Z0-9]*)*)
			   (\\|(boolean|int|float|number|string|scalar|array|list|map|object|callable|regex|
				  \\\?[_a-zA-Z][_a-zA-Z0-9]*(\\\[_a-zA-Z][_a-zA-Z0-9]*)*))*';
		$collection = "((array|list|map)\[$atom\])";
		$matchType =
			"/^(boolean|int|float|number|string|scalar|$collection|object|callable|regex|
				  \\\?[_a-zA-Z][_a-zA-Z0-9]*(\\\[_a-zA-Z][_a-zA-Z0-9]*)*)
			   (\\|(boolean|int|float|number|string|scalar|$collection|object|callable|regex|
				  \\\?[_a-zA-Z][_a-zA-Z0-9]*(\\\[_a-zA-Z][_a-zA-Z0-9]*)*))*$/x";

	}
	if (!is_string($type))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' =>
					'Invalid type: expected string; found ' .
					printScalar($type)
			]);
	if (!preg_match($matchType, $type))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' => "Invalid type list: $type"
			]);
	if (!is_string($label))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' =>
					'Invalid label: expected string; found ' .
					printScalar($label)
			]);
	$valid = false;
	$types = explode('|', $type);
	$listItemTypes = $mapItemTypes = [];
	foreach ($types as $i => $t) {
		if ($t == 'array') {
			$listItemTypes = $mapItemTypes = null;
			break;
		}
		if (strncmp($t, 'list', 4) == 0 && $listItemTypes !== null) {
			$len = strlen($t);
			if ($len == 4) {
				$listItemTypes = null;
				continue;
			}
			$listItemTypes[] = substr($t, 5, $len - 6);
		}
		if (strncmp($t, 'map', 3) == 0 && $mapItemTypes !== null) {
			$len = strlen($t);
			if ($len == 3) {
				$mapItemTypes = null;
				continue;
			}
			$mapItemTypes[] = substr($t, 4, $len - 5);
		}
	}
	foreach (explode('|', $type) as $t) {
		$item = null;
		if (($pos = strpos($t, '[')) !== false) {
			$item = substr($t, $pos +1, strlen($t) - $pos - 2);
			$t = substr($t, 0, $pos);
		}
		switch ($t) {
		case 'boolean':
			if (is_bool($value)) {
				$valid = true;
				break 2;
			}
			break;
		case 'int':
			if (is_int($value)) {
				$valid = true;
				break 2;
			}
			break;
		case 'float':
			if (is_float($value)) {
				$valid = true;
				break 2;
			}
			break;
		case 'number':
			if (is_int($value) || is_float($value)) {
				$valid = true;
				break 2;
			}
			break;
		case 'string':
			if (is_string($value)) {
				$valid = true;
				break 2;
			}
			break;
		case 'scalar':
			if (is_scalar($value)) {
				$valid = true;
				break 2;
			}
			break;
		case 'array':
		case 'list':
		case 'map':
			break;
		case 'object':
			if (is_object($value)) {
				$valid = true;
				break 2;
			}
			break;
		case 'callable':
			if (is_callable($value)) {
				$valid = true;
				break 2;
			}
			break;
		case 'regex':
			if (is_string($value)) {
				$handler = new ErrorHandler;
				$handler->_preg_match($value, "");
				if (!$handler->errno()) {
					$valid = true;
					break 2;
				}
			}
			break;
		default:
			if ($value instanceof $t) {
				$valid = true;
				break 2;
			}
			break;
		}
	}
	if (!$valid && is_array($value)) {
		for (;;) {
			if ($listItemTypes === null && $mapItemTypes === null) {
				$valid = true;
				break;
			}
			$isIndexed = isIndexed($value);
			if ( $listItemTypes === null && $isIndexed ||
				 $mapItemTypes === null && (empty($value) || !$isIndexed) )
			{
				$valid = true;
				break;
			}
			if ($listItemTypes !== null && $isIndexed) {
				$goodTypes = [];
				foreach ($listItemTypes as $t)
					$goodTypes[$t] = true;
				foreach ($value as $v)
					foreach ($listItemTypes as $t)
						if ($goodTypes[$t] && !validate($v, $t, '', true))
							$goodTypes[$t] = false;
				foreach ($goodTypes as $v) {
					if ($v) {
						$valid = true;
						break;
					}
				}
			}
			if ($mapItemTypes !== null && (empty($value) || !$isIndexed)) {
				$goodTypes = [];
				foreach ($mapItemTypes as $t)
					$goodTypes[$t] = true;
				foreach ($value as $v)
					foreach ($mapItemTypes as $t)
						if ($goodTypes[$t] && !validate($v, $t, '', true))
							$goodTypes[$t] = false;
				foreach ($goodTypes as $v) {
					if ($v) {
						$valid = true;
						break;
					}
				}
			}
			break;
		}
	}

	if (!$valid && !$nothrow) {
		$found = is_scalar($value) ?
			$value :
			printScalar($value);
		if (is_array($value)) {
			$isIndexed = isIndexed($value);
			if ( (!$isIndexed || empty($value)) &&
				 ($listItemTypes === null || count($listItemTypes) > 0) )
			{
				$found = 'map';
			} elseif ( $isIndexed &&
					   ($mapItemTypes === null || count($mapItemTypes) > 0) )
			{
				$found = 'list';
			}
		}
		$types =
			map(
				function($t)
				{
					if (strncmp($t, 'list[', 5) == 0) {
						return "list with item type '" .
							   substr($t, 5, strlen($t) - 6) . "'";
					} elseif (strncmp($t, 'map[', 4) == 0) {
						return "map with item type '" .
							   substr($t, 4, strlen($t) - 5) . "'";
					} else {
						return $t;
					}
				},
				$types
			);
		$count = count($types);
		$expected = null;
		switch ($count) {
		case 1:
			$expected = $types[0];
			break;
		case 2:
			$expected = "$types[0] or $types[1]";
			break;
		default:
			$expected =
				join(', ', array_slice($types, 0, $count - 1)) .
				', or ' . $types[$count - 1];
			break;
		}
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'message' => "Invalid $label",
				'details' => "Invalid $label: expected $expected; found $found"
			]);
	}

	return $valid;
}
function processOption(
	array &$options, $name, $type, $params = null, $deprecated1 = false,
	$deprecated2 = null)
{
	if ($params === null || !is_array($params) || func_num_args() >= 5) {
		$params =
			[
				'label' => $params,
				'required' => $deprecated1,
			];
		if (func_num_args() == 6)
			$params['default'] = $deprecated2;
	}
	if (!is_string($name))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' =>
					'Invalid option name: expected string; found ' .
					printScalar($name)
			]);
	if (!is_string($type))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' =>
					'Expected type: expected string; found ' .
					printScalar($type)
			]);
	if (!is_array($params))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' =>
					'Expected array of parameters: found ' .
					printScalar($params)
			]);
   if (!empty($params) && isIndexed($params))
	   throw new
		   Error([
			   'status' => 'INVALID_PARAMETER',
			   'details' =>
				   'Expected associative array of parameters: found indexed ' .
				   'array'
		   ]);
	if (!isset($params['label']))
		$params['label'] = $name;
	if (!isset($params['required']))
		$params['required'] = false;
	if (!is_string($params['label']))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' =>
					'Invalid label: expected string; found ' .
					printScalar($params['label'])
			]);
	if (!is_bool($params['required']))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' =>
					'Invalid required flag: expected boolean; found ' .
					printScalar($params['required'])
			]);
	if (!isset($options[$name])) {
		if ($params['required']) {
			throw new
				Error([
					'status' => 'MISSING_PARAMETER',
					'message' => "Missing {$params['label']}"
				]);
		} elseif (!array_key_exists('default', $params)) {
			return null;
		} else {
			$options[$name] = $params['default'];
			if ($options[$name] === null)
				return null;
		}
	}
	validate($options[$name], $type, $params['label']);

	return $options[$name];
}
function uniqueOption(array $options, array $names)
{
	$count = count($names);
	if ($count < 2)
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' => "Expected two or more option names; found $count"
			]);
	$found = [];
	foreach ($names as $name) {
		if (isset($options[$name])) {
			$found[] = $name;
			if (count($found) == 2)
				break;
		}
	}
	switch (count($found)) {
	case 0:
		$list = $count == 2 ?
			"'{$names[0]}' or '{$names[1]}'" :
			"'" . join("', '", array_slice($names, 0, $count - 1)) .
				", or '{$names[$count - 1]}'";
		throw new
			Error([
				'status' => 'MISSING_PARAMETER',
				'message' => "Missing $list"
			]);
	case 1:
		return $found[0];
	case 2:
	default:
		throw new
			Error([
				'status' => 'INCONSISTENT_PARAMETERS',
				'message' =>
					"The options '{$found[0]}' and '{$found[1]}' are " .
					"incompatible"
			]);
	}
}
namespace Makeme\Util;
function printScalar($arg)
{
	if (is_object($arg))
		return get_class($arg);
	if (is_array($arg))
		return 'array';
	if (is_string($arg))
		return '"' . str_replace('"', '\\"', $arg) . '"';
	if ($arg === null)
		return 'null';
	if (is_bool($arg))
		return ($arg ? 'true' : 'false');
	return (string) $arg;
}


namespace Makeme\Util;

function map($callback, array $array, $sep = null)
{
	$result = [];
	foreach ($array as $i => $v)
		$result[$i] = $callback($v);
	return $sep !== null ? join($sep, $result) : $result;
}
namespace Makeme\Util;
function isIndexed(array $array)
{
	$index = 0;
	foreach ($array as $n => $v)
		if ($n !== $index++)
			return false;
	return true;
}
namespace Makeme\Util;

use Exception;
use Throwable;
use Makeme\Error;
const ERROR_HANDLER_NOTICE = E_NOTICE | E_USER_NOTICE | E_STRICT;
const ERROR_HANDLER_WARNING = E_WARNING | E_CORE_WARNING | E_COMPILE_WARNING | E_USER_WARNING;
const ERROR_HANDLER_ERROR = E_ERROR | E_PARSE | E_CORE_ERROR | E_COMPILE_ERROR |
		E_RECOVERABLE_ERROR | E_USER_ERROR;
final class ErrorHandler {
	private $level;
	private $ignorePattern;
	private $ignoreCallback;
	private $properties;
	function __construct($options = null)
	{
		if (!is_array($options))
			$options = ['level' => $options];
		if ( isset($options['ignorePattern']) &&
			 isset($options['ignoreCallback']) )
		{
			throw new
				Error([
					'status' => 'INCONSISTENT_PARAMETERS',
					'message' =>
						"The options 'ignorePattern' and " .
						"'ignoreCallback'"
				]);
		}
		$this->level = isset($options['level']) ?
			$options['level'] :
			( defined('E_DEPRECATED') ?
				E_ALL & ~E_STRICT & ~E_DEPRECATED & ~E_USER_DEPRECATED :
				E_ALL & ~E_STRICT );
		$this->ignorePattern = isset($options['ignorePattern']) ?
			$options['ignorePattern'] :
			null;
		$this->ignoreCallback = isset($options['ignoreCallback']) ?
			$options['ignoreCallback'] :
			null;
	}
	function errno()
	{
		return $this->properties ? $this->properties['errno'] : null;
	}
	function errstr()
	{
		return $this->properties ? $this->properties['errstr'] : null;
	}
	function errfile()
	{
		return $this->properties ? $this->properties['errfile'] : null;
	}
	function errline()
	{
		return $this->properties ? $this->properties['errline'] : null;
	}
	function errcontext()
	{
		return $this->properties ? $this->properties['errcontext'] : null;
	}
	function hasError()
	{
		return ($this->errno & ERROR_HANDLER_ERROR) != 0;
	}
	function hasWarning()
	{
		return ($this->errno & ERROR_HANDLER_WARNING) != 0;
	}
	function hasNotice()
	{
		return ($this->errno & ERROR_HANDLER_NOTICE) != 0;
	}
	function reset()
	{
		$this->properties = null;
	}
	function call()
	{
		$args = func_get_args();
		return $this->callUserFunction(...$args);
	}
	function callUserFunction()
	{
		$args = func_get_args();
		$func = array_shift($args);
		return $this->callUserFunctionArray($func, $args);
	}
	function callUserFunctionArray($func, $args)
	{
		$this->reset();
		set_error_handler([$this, 'handleError'], $this->level);
		$result = null;
		try {
			$result = @call_user_func_array($func, $args);
		} catch (ErrorHandlerException $e) {
			$result = false;
		} catch (Throwable $e) {
			restore_error_handler();
			throw $e;
		}
		restore_error_handler();
		return $result;
	}
	function formatError($message = null)
	{
		return $this->errno() ?
			($message ?  "$message: " : '') .
				$this->errorCategory($this->errno()) .
				": {$this->errstr()} in {$this->errfile()} " .
				"on line {$this->errline()}" :
			$message;
	}
	function handleError($errno, $errstr, $errfile, $errline, $errcontext)
	{
		if ($this->ignorePattern && preg_match($this->ignorePattern, $errstr))
			return;
		if (($callback = $this->ignoreCallback) && $callback($errstr))
			return;
		if ($errno & $this->level) {
			$this->properties =
				[
					'errno' => $errno,
					'errstr' => $errstr,
					'errfile' => $errfile,
					'errline' => $errline,
					'errcontext' => $errcontext
				];
			throw new ErrorHandlerException;
		}
	}
	public function __call($name, $arguments)
	{
		if (strlen($name) < 2 || $name[0] != '_')
			throw new Error("Invalid method: '$name'");
		$func = substr($name, 1);
		if (function_exists($func)) {
			return $this->callUserFunctionArray($func, $arguments);
		} elseif (sizeof($arguments) > 0) {
			$callback = [array_shift($arguments), $func];
			if (is_callable($callback)) {
				return $this->callUserFunctionArray($callback, $arguments);
			} else {
				throw new
					Error(
						"The array [" . printScalar($callback[0]) .
						",'{$callback[1]}'] is not a valid callback"
					);
			}
		} else {
			throw new Error("'$name' is not callable");
		}
	}
	static function errorCategory($errno)
	{
		$category =
			[ // From pearcmd.php
				E_ERROR => 'Error',
				E_WARNING => 'Warning',
				E_PARSE => 'Parsing Error',
				E_NOTICE => 'Notice',
				E_CORE_ERROR => 'Core Error',
				E_CORE_WARNING => 'Core Warning',
				E_COMPILE_ERROR => 'Compile Error',
				E_COMPILE_WARNING => 'Compile Warning',
				E_USER_ERROR => 'User Error',
				E_USER_WARNING => 'User Warning',
				E_USER_NOTICE => 'User Notice',
				E_STRICT => 'Strict Standards',
				E_RECOVERABLE_ERROR => 'Recoverable Error',
			];
		if (defined('E_DEPRECATED')) {
			$category[E_DEPRECATED] = 'Deprecation Warning';
			$category[E_USER_DEPRECATED] = 'User Deprecation Warning';
		}
		return $category[$errno];
	}
}

class ErrorHandlerException extends Exception { }
namespace Makeme\File;

use Makeme\Error;
use function Makeme\Util\validate;
function checkFile($path, $mode = null)
{
	validate($path, 'string', 'file path');
	if (!file_exists($path))
		throw new
			Error([
				'status' => 'OBJECT_DOES_NOT_EXIST',
				'message' => "No such file: $path"
			]);
	if (!is_file($path))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'message' =>
					"The file '$path' is " .
					(is_dir($file) ? 'a directory' : 'not a plain file')
			]);
	if ($mode !== null) {
		validate($mode, 'int', 'file mode');
		if (($mode & 1) !== 0 && !is_executable($path))
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "The file '$path' is not executable"
				]);
		if (($mode & 2) !== 0 && !is_writable($path))
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "The file '$path' is not writable"
				]);
		if (($mode & 4) !== 0 && !is_readable($path))
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "The file '$path' is not readable"
				]);
	}
}
namespace Makeme;

use Makeme\Log\IProvider;
final class Log {
	const ERROR = 1;
	const WARNING = 2;
	const INFO = 3;
	const VERBOSE = 4;
	const DEBUG = 5;
	const SESSION_ID_LENGTH = 50;
	const MATCH_PROVIDER_CLASS = '/^log\.provider\.([^.]+)\.class$/';
	const MATCH_PROVIDER_LEVEL = '/^log\.provider\.([^.]+)\.level$/';
	const MATCH_PROVIDER_PARAM = '/^log\.provider\.([^.]+)\.param\.([^.]+)$/';
	public function __construct()
	{
		$this->impl = new Log\Impl;
	}
	public function getStream($level)
	{
		return $this->impl->getStream($level);
	}
	public function logError($message)
	{
		if ($this->getStream(Log::ERROR))
			$this->impl->write(Log::ERROR, $message, null, 2);
	}
	public function logWarning($message)
	{
		if ($stream = $this->getStream(Log::WARNING))
			$this->impl->write(Log::WARNING, $message, null, 2);
	}
	public function logMessage($message)
	{
		if ($stream = $this->getStream(Log::INFO))
			$this->impl->write(Log::INFO, $message, null, 2);
	}
	public function registerProvider(IProvider $provider, $level)
	{
		$this->impl->registerProvider($provider, $level);
	}
	public function unregisterProvider(IProvider $provider)
	{
		$this->impl->unregisterProvider($provider);
	}
	public function sessionId()
	{
		return $this->impl->sessionId();
	}
	public function setSessionId($sessionId)
	{
		$this->impl->setSessionId($sessionId);
	}
	public function tags()
	{
		return $this->impl->tags();
	}
	public function setTag($tag)
	{
		$this->impl->setTag($tag);
	}
	public function clearTag($tag)
	{
		$this->impl->clearTag($tag);
	}
	public static function current()
	{
		if (self::$current === null)
			self::$current = self::create(Config::current());
		return self::$current;
	}
	public static function setCurrent($current)
	{
		self::$current = $current;
	}
	public static function create(Config $config)
	{
		$log = new Log;
		$classes = $levels = $params = [];
		foreach ($config->propertyNames() as $name) {
			if (strncmp($name, 'log.provider.', 13) != 0)
				continue;
			$value = $config->getProperty($name);
			$match = null;
			if (preg_match(self::MATCH_PROVIDER_CLASS, $name, $match)) {
				$classes[$match[1]] = $value;
			} if (preg_match(self::MATCH_PROVIDER_LEVEL, $name, $match)) {
				$levels[$match[1]] = $value;
			} elseif (preg_match(self::MATCH_PROVIDER_PARAM, $name, $match))
			{
				$params[$match[1]][$match[2]] = $value;
			}
		}
		foreach ($classes as $name => $class) {
			if (!isset($levels[$name]))
				throw new
					Error([
						'status' => 'CONFIGURATION_ERROR',
						'defailts' =>
							"No level specified for log provider '$name'"
					]);
			$level = is_numeric($levels[$name]) ?
				(int)$levels[$name] :
				self::translateLevel($levels[$name]);
			$provider =
				Util\loadComponent([
					'class' => $class,
					'params' => isset($params[$name]) ?
						$params[$name] :
						[]
				]);
			$log->registerProvider($provider, $level);
		}
		return $log;
	}
	public static function translateLevel($level)
	{
		if (is_int($level)) {
			switch ($level) {
			case self::ERROR: return "ERROR";
			case self::WARNING: return "WARNING";
			case self::INFO: return "INFO";
			case self::VERBOSE: return "VERBOSE";
			case self::DEBUG: return "DEBUG";
			default:
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "Invalid log level: $level"
					]);
			}
		} else {
			$level = strtoupper($level);
			switch ($level) {
			case "ERROR": return self::ERROR;
			case "WARNING": return self::WARNING;
			case "INFO": return self::INFO;
			case "VERBOSE": return self::VERBOSE;
			case "DEBUG": return self::DEBUG;
			default:
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' =>
							"Invalid log level: " .
							Util\printObject($level)
					]);
			}
		}
	}
	private static $current;
}
namespace Makeme\Util;

use Makeme\Error;

function loadComponent($options)
{
	$className = loadComponentDefinition($options);
	$params = isset($options['params']) ? $options['params'] : [];
	return new $className($params);
}
function loadComponentDefinition($options)
{
	$class = isset($options['class']) ? $options['class'] : null;
	$classPath = isset($options['classPath']) ? $options['classPath'] : null;
	$checkSyntax = isset($options['checkSyntax']) ?
		$options['checkSyntax'] :
		false;
	if (!$class)
		throw new
			Error([
				'status' => 'MISSING_PARAMETER',
				'details' => "Missing 'class'"
			]);
	if ( !preg_match(
			  '/^[_a-zA-Z][_a-zA-Z0-9]*(\.[_a-zA-Z][_a-zA-Z0-9]*)*$/',
			  $class
		 ) )
	{
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'details' => "Invalid class: $class"
			]);
	}
	$parts = explode('.', $class);
	$className = join('\\', $parts);
	$classFile = join('/', $parts) . '.php';
	$search = $classPath ?
		[$classPath] :
		explode(PATH_SEPARATOR, ini_get('include_path'));
	static $success = [];
	$key = "$class#$classPath";
	if (!isset($success[$key])) {
		foreach ($search as $p) {
			$path = "$p/$classFile";
			if (!file_exists($path))
				continue;
			\Makeme\File\checkReadable($path);
			if ($checkSyntax) {
				$output = null;
				try {
					$esc = addcslashes($path, "'");
					$script =
						"require_once('CodeRage.php'); require_once('$esc');";
					$php = isset($options['php']) ?
						$options['php'] :
						'php';
					$command =
						escapeExecutable($php) .
						' -r ' . escapeShellArg($script);
					$output = system($command);
				} catch (Throwable $e) {
					throw new
						Error("Failed checking syntax of '$path'");
				}
			}
			safeRequireOnce($path);
			$success[$key] = true;
			break;
		}
		if (!isset($success[$key]))
			$success[$key] = false;
	}
	if ($success[$key])
		return $className;
	throw new
		Error([
			'status' => 'INVALID_PARAMETER',
			'details' => "Failed loading component '$class'"
		]);
}
namespace Makeme\Util;
function system($command, &$exitStatus = null)
{
	$args = func_get_args();
	$throwOnError = count($args) == 1;
	ob_start();
	$status = null;
	passthru($command, $status);
	$output = ob_get_contents();
	ob_end_clean();
	if ($status != 0 && $throwOnError) {
		$message = "Failed executing \"$command\"";
		$output = strlen($output) <= 1000 ?
			$output :
			substr($output, 0, 1000) . ' ...';
		$message .= " (exit status $status) (output '$output')";
		throw new \Exception($message);
	} else {
		$exitStatus = $status;
	}
	return $output;
}
namespace Makeme\Util;

function escapeShellArg($arg)
{
	return os() == 'windows' ?
		'"' . str_replace('"', '"^""', $arg) . '"' :
		"'" . str_replace("'", "'\"'\"'", $arg) . "'";
}
namespace Makeme\Util;

function escapeExecutable($executable)
{
	if (os() == 'windows') {
		$path = '"' . str_replace('"', '"^""', $executable) . '"';
		$result = exec("@echo off & for %X in ($path) do echo %~fsX");
		return $result;
	} else {
		return "'" . str_replace("'", "'\"'\"'", $executable) . "'";
	}
}
namespace Makeme\Util;
function safeInclude($path, $level = null)
{
	_safeIncludeImpl($path, $level, 'include');
}
function safeIncludeOnce($path, $level = null)
{
	_safeIncludeImpl($path, $level, 'include_once');
}
function safeRequire($path, $level = null)
{
	_safeIncludeImpl($path, $level, 'require');
}
function safeRequireOnce($path, $level = null)
{
	_safeIncludeImpl($path, $level, 'require_once');
}

function _safeIncludeImpl($path, $level, $type)
{
	if ($level === null) {
		$level = defined('E_DEPRECATED') ?
			E_ALL & ~E_STRICT & ~E_DEPRECATED & ~E_USER_DEPRECATED :
			E_ALL & ~E_STRICT;
	}
	$include =
		function($path, $type)
		{
			switch ($type) {
			case 'include':
				include($path);
				break;
			case 'include_once':
				include_once($path);
				break;
			case 'require':
				require($path);
				break;
			case 'require_once':
			default:
				require_once($path);
				break;
			}
		};
	$handler = new ErrorHandler;
	$handler->callUserFunctionArray($include, [$path, $type], $level);
}
namespace Makeme\Log;

use Makeme\Error;
use Makeme\Log;
final class Impl {
	public function __construct()
	{
		static $sessionId;
		if ($sessionId === null)
			$sessionId = \Makeme\Util\randomString(Log::SESSION_ID_LENGTH);
		$this->sessionId = $sessionId;
		for ($z = Log::ERROR; $z <= Log::DEBUG; ++$z)
			$this->streams[$z] = null;
	}
	public function getStream($level)
	{
		return $this->streams[$level];
	}
	public function registerProvider(IProvider $provider, $level)
	{
		$this->providers[] = [$provider, $level];
		while ($level >= Log::ERROR && $this->streams[$level] === null) {
			$this->streams[$level] = new Stream($level, $this);
			--$level;
		}
	}
	public function unregisterProvider(IProvider $provider) {
		for ($i = 0, $n = count($this->providers); $i < $n; ++$i) {
			if ($this->providers[$i][0] === $provider) {
				array_splice($this->providers, $i, 1);
				break;
			}
		}
	}
	public function sessionId()
	{
		return $this->sessionId;
	}
	public function setSessionId($sessionId)
	{
		$this->sessionId = $sessionId;
	}
	public function tags()
	{
		return $this->tags;
	}
	public function setTag($tag)
	{
		if (strlen($tag) == 0) {
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'details' => 'Empty log tag'
				]);
		}
		if ( strpos($tag, '[') !== false ||
			 strpos($tag, ']') !== false ||
			 preg_match('/[^[:print:]]$/', $tag) )
		{
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'details' => "Invalid log tag: $tag"
				]);
		}
		if (!in_array($tag, $this->tags)) {
			$this->tags[] = $tag;
			sort($this->tags);
		}
	}
	public function clearTag($tag)
	{
		if (($pos = array_search($tag, $this->tags)) !== null)
			array_splice($this->tags, $pos, 1);
	}
	function write($level, $message, $data, $depth)
	{
		$timestamp = (new \DateTime)->setTimestamp(\Makeme\Util\Time::real());
		$trace = debug_backtrace();
		$file = isset($trace[$depth]['file']) ?
			$trace[$depth]['file'] :
			null;
		$line = isset($trace[$depth]['line']) ?
			$trace[$depth]['line'] :
			null;
		$entry =
			new Entry(
					$this->sessionId,
					$this->tags,
					$timestamp,
					$level,
					$message,
					$file,
					$line,
					$data
				);
		for ($z = count($this->providers) - 1; $z >= 0; --$z) {
			list ($p, $l) = $this->providers[$z];
			if ($l < $level)
				continue;
			try {
				$p->dispatchEntry($entry);
			} catch (\Throwable $e) {
				array_splice($this->providers, $z, 1);
				$this->write(
					Log::ERROR,
					"Log provider " . $p->name() . " failed: $e",
					null,
					0
				);
			}
		}
	}
	private $sessionId;
	private $tags = [];
	private $streams = [];
	private $providers = [];
}
namespace Makeme\Util;
final class Time {
	public static function get()
	{
		if (self::$offset === null) {
			$config = \Makeme\Config::current();
			$offset = $config->getProperty('coderage.util.time.offset', 0);
			self::$offset = ctype_digit($offset) ? (int) $offset : 0;
		}
		return time() + self::$offset;
	}
	public static function set($time)
	{
		validate($time, 'int', 'timestamp');
		self::$offset = $time - time();
	}
	public static function reset() { self::$offset = 0; }
	public static function real() { return time(); }
	private static $offset;
}
namespace Makeme\Util;

const RND_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890';
const RND_NUM_CHARS = 62;
function randomString($length, $alphabet = null)
{
	$size = null;
	if ($alphabet !== null) {
		$size = strlen($alphabet);
	} else {
		$alphabet = RND_CHARS;
		$size = RND_NUM_CHARS;
	}
	$name = '';
	for ($z = $length - 1; $z != -1; --$z)
		$name .= substr($alphabet, mt_rand(0, $size - 1), 1);
	return $name;
}
namespace Makeme\Log;
class Stream {
	public function __construct($level, $impl)
	{
		$this->level = $level;
		$this->impl = $impl;
	}
	function write($message, $data = [])
	{
		$this->impl->write($this->level, $message, $data, 1);
	}
	private $level;
	private $impl;
}
namespace Makeme\Log;

use DateTime;
use Makeme\Error;
use Makeme\Log;
final class Entry {
	const TIMESTAMP = 1;
	const SESSION_ID = 2;
	const TAGS = 4;
	const FILE_AND_LINE = 8;
	const EXCEPTION_DETAILS = 16;
	const DATA = 32;
	const NORMALIZE_SPACE = 64;
	const ALL = 63;
	const ALL_EXCEPT_SESSION = 61;
	const MATCH_TIMESTAMP =
	'/^\[(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})[-+]\d{2}:\d{2}\] (.*)/';
	const MATCH_SESSION_ID = '/^([a-zA-Z0-9]{12}) (.*)/';
	const MATCH_TAGS = '/^(?:((?:\[[^]]+?\])*) )?(.*)/';
	const MATCH_FILE_AND_LINE = '/^([^:]+):(\d+|\?) (.*)/';
	const MATCH_LEVEL = '/^(?:(ERROR|WARNING): )?(.*)/';
	public function __construct($sessionId, $tags, $timestamp, $level, $message,
			$file, $line, $data)
	{
		$this->sessionId = $sessionId;
		$this->tags = $tags;
		$this->timestamp = $timestamp;
		$this->level = $level;
		$this->message = $message;
		$this->file = $file;
		$this->line = $line;
		$this->data = $data;
	}
	public function sessionId()
	{
		return $this->sessionId;
	}
	public function tags()
	{
		return $this->tags;
	}
	public function timestamp()
	{
		return $this->timestamp;
	}
	public function level()
	{
		return $this->level;
	}
	public function message()
	{
		return $this->message;
	}
	public function file()
	{
		return $this->file;
	}
	public function line()
	{
		return $this->line;
	}
	public function data()
	{
		return $this->data;
	}
	public function formatEntry($format)
	{
		$line = '';
		if (($format & Entry::TIMESTAMP) != 0)
			$line .= '[' . self::formatTimestamp($this->timestamp) . '] ';
		if (($format & Entry::SESSION_ID) != 0)
			$line .= $this->sessionId . ' ';
		if (($format & Entry::TAGS) != 0 && count($this->tags) > 0)
			$line .= '[' . join('][', $this->tags) . '] ';
		if (($format & Entry::FILE_AND_LINE) != 0) {
			$line .= $this->file !== null ?
			$this->file :
			'?';
			$line .= ':';
			$line .= $this->line !== null ?
			$this->line :
			'?';
			$line .= ' ';
		}
		if ($this->level <= Log::WARNING)
			$line .= Log::translateLevel($this->level) . ': ';
		$line .= self::formatMessage($this->message, $format);
		if (($format & Entry::DATA) != 0 && !empty($this->data)) {
			$line .= "  Additional information:\n";
			foreach ($this->data as $n => $v) {
				$v = self::normalizeSpace($v);
				$line .= "  $n = $v\n";
			}
		}
		return $line;
	}
	public static function formatTimestamp(DateTime $timestamp)
	{
		return $timestamp->format(DATE_W3C);
	}
	public static function formatMessage($message, $format = 0)
	{
		$text = !$message instanceof \Exception ?
		rtrim($message) . "\n" :
		( ($format & Entry::EXCEPTION_DETAILS) != 0 ?
				"\n" . self::formatException($message, '  ') :
				rtrim($message->getMessage()) . "\n" );
		if (($format & Entry::NORMALIZE_SPACE) != 0)
			$text = self::normalizeSpace($text);
		return $text;
	}
	public static function formatException($e, $indent = '')
	{
		if (!$e instanceof Error)
			$e =
				new Error([
						'status' => 'INTERNAL_ERROR',
						'message' => $e->getMessage()
					]);
			$message = rtrim($e->message());
			$details = rtrim($e->details());
			$result =
			"{$indent}Exception {\n" .
			"{$indent}  status:   " . $e->status() . "\n" .
			"{$indent}  message:  $message\n" .
			( $details != $message ?
					"{$indent}  details:  $details\n" :
					"" ) .
					"{$indent}  trace:\n" .
					self::formatStackTrace($e->trace(), $indent . '    ');
			if ($e->inner() && $e->inner() !== $e) {
				$result .=
				"{$indent}  inner:\n" .
				self::formatException($e->inner(), $indent . '    ') . "\n";
			}
			$result .= "$indent}";
			return $result;
	}
	public static function formatStackTrace($stackTrace, $indent = '')
	{
		$result = '';
		for ($z = 0, $n = count($stackTrace); $z < $n; ++$z) {
			$frame = $stackTrace[$z];
			$result .=
			$indent . '#' . ($z + 1) . ' ' .
			(!empty($frame['class']) ? "{$frame['class']}::" : '') .
			(!empty($frame['function']) ?
					"{$frame['function']}()" :
					'code' ) .
					(!empty($frame['line']) ?
							" called at line {$frame['line']}" :
							"" ) .
							(!empty($frame['file']) ?
									" in {$frame['file']}" :
									'');
			$result .= "\n";
		}
		return $result;
	}
	public static function normalizeSpace($value)
	{
		return
		str_replace(
				["\r\n", "\r", "\n", "\t"],
				['\n', '\n', '\n', '\t'],
				trim($value)
		);
	}
	public static function parseEntry($entry, $format)
	{
		$timestamp = $sessionId = $tags = $file = $line =
		$level = $message = $match = null;
		if (($format & Entry::TIMESTAMP) != 0) {
			if (preg_match(self::MATCH_TIMESTAMP, $entry, $match)) {
				$timestamp = new DateTime($match[1]);
				$entry = $match[2];
			} else {
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'details' => 'Missing timestamp'
					]);
			}
		}
		if (($format & Entry::SESSION_ID) != 0) {
			if (preg_match(self::MATCH_SESSION_ID, $entry, $match)) {
				$sessionId = $match[1];
				$entry = $match[2];
			} else {
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'details' => 'Missing session ID'
					]);
			}
		}
		if (preg_match(self::MATCH_TAGS, $entry, $match)) {
			$length = strlen($match[1]);
			$tags = $length > 0 ?
			explode('][', substr($match[1], 1, $length - 2)) :
			[];
			$entry = $match[2];
		} else {
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'details' => 'Missing file and line'
				]);
		}
		if (($format & Entry::FILE_AND_LINE) != 0) {
			if (preg_match(self::MATCH_FILE_AND_LINE, $entry, $match)) {
				$file = $match[1];
				$line = $match[2];
				$entry = $match[3];
			} else {
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'details' => 'Missing file and line'
					]);
			}
		}
		if (preg_match(self::MATCH_LEVEL, $entry, $match)) {
			$level = strlen($match[1]) > 0 ?
			Log::translateLevel($match[1]) :
			Log::INFO;
			$entry = $match[2];
		} else {
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'details' => 'Missing file and line'
				]);
		}
		$message = $entry;
		return new
		Entry(
				$sessionId,
				$tags,
				$timestamp,
				$level,
				$message,
				$file,
				$line,
				null
		);
	}
	private $sessionId;
	private $tags;
	private $timestamp;
	private $level;
	private $message;
	private $file;
	private $line;
	private $data;
}
namespace Makeme\Build;
function updateIncludePath()
{
	$oldcwd = getcwd();
	for ( $cur = null, $next = $oldcwd;
		  $cur != $next &&
			  !is_file('./project.xml') &&
			  !is_file('./project.ini') &&
			  !is_file('./project-root') &&
			  !is_file('./website-root');
		  $cur = $next, $next = getcwd() )
	{
		chdir('..');
	}
	if ($cur != $next) {
		$root = str_replace('\\', '/', $next);
		$path = ini_get('include_path');
		$sep = PATH_SEPARATOR;
		ini_set('include_path', "$root$sep$path");
	}
	chdir($oldcwd);
}
namespace Makeme\Util;

use Makeme\Error;
interface Properties {
	function propertyNames();
	function hasProperty($name);
	function getProperty($name, $nothrow = false);
	function &getPropertyRef($name);
	function setProperty($name, $value);
	function setPropertyRef($name, &$value);
}

class BasicProperties implements Properties {
	private $properties = [];
	private $parent;
	function __construct($parent = null)
	{
		$this->parent = $parent;
	}
	function setParentBundle(Properties $parent)
	{
		$this->parent = $parent;
	}
	function propertyNames()
	{
		return $this->parent ?
			array_merge($this->properties, $this->parent->propertyNames()) :
			array_keys($this->properties);
	}
	function hasProperty($name)
	{
		return key_exists($name, $this->properties) ||
			   $this->parent && $this->parent->hasProperty($name);
	}
	function getProperty($name, $nothrow = false)
	{
		$value = key_exists($name, $this->properties) ?
			$this->properties[$name] :
			( $this->parent && $this->parent->hasProperty($name) ?
				  $this->parent->getProperty($name) :
				  null );
		if (!$nothrow && $value === null)
			throw new Error("Missing property $name");
		return $value;
	}
	function &getPropertyRef($name)
	{
		if (key_exists($name, $this->properties)) {
			return $this->properties[$name];
		} elseif ($this->parent && $this->parent->hasProperty($name)) {
			return $this->parent->getPropertyRef($name);
		} else {
			throw new Error("Missing property $name");
		}
	}
	function setProperty($name, $value)
	{
		$this->properties[$name] = $value;
	}
	function setPropertyRef($name, &$value)
	{
		$this->properties[$name] =& $value;
	}
}
class ReadonlyProperties implements Properties {
	private $properties;
	private $hashKey;
	function __construct($properties)
	{
		$this->properties = $properties;
	}
	function propertyNames()
	{
		return array_keys($this->properties);
	}
	function hasProperty($name)
	{
		return key_exists($name, $this->properties);
	}
	function getProperty($name, $nothrow = false)
	{
		$value = key_exists($name, $this->properties) ?
			$this->properties[$name] :
			null;
		if (!$nothrow && $value === null)
			throw new Error("Missing property $name");
		return $value;
	}
	function &getPropertyRef($name)
	{
		if (!key_exists($name, $this->properties))
			throw new Error("Missing property $name");
		return $this->properties[$name];
	}
	function setProperty($name, $value)
	{
		throw new Error("Attempt to modidy read-only property bundle");
	}
	function setPropertyRef($name, &$value)
	{
		throw new Error("Attempt to modidy read-only property bundle");
	}
	function hashKey()
	{
		return $this->hashKey;
	}
	function setHashKey($hashKey)
	{
		$this->hashKey = $hashKey;
	}
}
class PropertiesSet {
	private $members = [];
	private $stringCodes = [];
	private $nextId = 0;
	function contains($properties)
	{
		$hashKey = $this->getHashKey($properties);
		return key_exists($hashKey, $this->members);
	}
	function lookup($properties)
	{
		$hashKey = $this->getHashKey($properties);
		return key_exists($hashKey, $this->members) ?
			$this->members[$hashKey] :
			null;
	}
	function size() { return sizeof($this->members); }
	function members() { return array_values($this->members); }
	function add(ReadonlyProperties $properties)
	{
		$hashKey = $this->getHashKey($properties);
		if (key_exists($hashKey, $this->members))
			$this->members[$hashKey]->setHashKey(null);
		$this->members[$hashKey] = $properties;
	}
	function remove(ReadonlyProperties $properties)
	{
		$hashKey = $properties->hashKey();
		$properties->setHashKey(null);
		unset($this->members[$hashKey]);
	}
	private function getHashKey($properties)
	{
		$hashKey = null;
		if (is_object($properties) && $properties->hashKey !== null) {
			$hashKey = $properties->hashKey();
		} else {
			$hashKey =  $this->calculateHashKey($properties);
			if (is_object($properties))
				$properties->setHashKey($hashKey);
		}
		return $hashKey;
	}
	private function calculateHashKey($properties)
	{
		$map = [];
		foreach ($properties as $n => $v) {
			if (!is_string($n))
				throw new Error(
							  'Invalid property name: ' .
							  printScalar($n)
						  );
			if (!is_string($v))
				throw new Error(
							  'Invalid property value: ' .
							  printScalar($v)
						  );
			$nid = $vid = null;
			if (isset($this->stringCodes[$n])) {
				$nid = $this->stringCodes[$n];
			} else {
				$this->stringCodes[$n] = $nid = ++$this->nextId;
			}
			if (isset($this->stringCodes[$v])) {
				$vid = $this->stringCodes[$v];
			} else {
				$this->stringCodes[$v] = $vid = ++$this->nextId;
			}
			$map[$nid] = $vid;
		}
		ksort($map);
		$hashKey = '';
		foreach ($map as $nid => $vid)
			$hashKey .= "$nid:$vid;";

		return $hashKey;
	}
}
namespace Makeme\Build;

use Throwable;
use Makeme\Build\Config\Property;
use Makeme\Build\Config\Reader\File;
use Makeme\Error;
use Makeme\Log;
use function Makeme\Text\split;
use Makeme\Util\ErrorHandler;

class Run extends \Makeme\Util\BasicProperties {
	const GENERATED_FILE_LOG = '.coderage/files.log';
	private $projectRoot;
	private $commandLine;
	private $log;
	private $buildConfig;
	private $projectConfig;
	private $targets;
	private $binaryPath = PHP_BINARY;
	private $files = [];
	private $handler;
	private $timestamp;
	function __construct($projectRoot = null, $commandLine = null,
		$log = null, $buildConfig = null, $projectConfig = null,
		$targets = null)
	{
		$this->projectRoot = $projectRoot;
		$this->commandLine = $commandLine;
		$this->log = $log;
		$this->buildConfig = $buildConfig;
		$this->projectConfig = $projectConfig;
		$this->targets = $targets !== null ?
			new TargetSet($this, $targets) :
			null;
		$this->handler = new ErrorHandler;
		$this->timestamp = \Makeme\Util\Time::real();
	}
	function commandLine()
	{
		return $this->commandLine;
	}
	function projectRoot()
	{
		return $this->projectRoot;
	}
	function log()
	{
		return $this->log;
	}
	function getStream($level)
	{
		return $this->log->getStream($level);
	}
	function buildConfig()
	{
		return $this->buildConfig;
	}
	function projectConfig()
	{
		return $this->projectConfig;
	}
	function targets()
	{
		return $this->targets;
	}
	function binaryPath()
	{
		return $this->binaryPath;
	}
	function timestamp()
	{
		return $this->timestamp;
	}
	function generateFile($path, $content, $type = null)
	{
		if ($str = $this->getStream(Log::DEBUG))
			$str->write("Generating file: $path");
		\Makeme\File\generate($path, $content, $type);
		$this->recordGeneratedFile($path);
	}
	function recordGeneratedFile($path)
	{
		if ($str = $this->getStream(Log::DEBUG))
			$str->write("Recording generated file: $path");
		if (!\Makeme\File\isAbsolute($path))
			throw new
				Error(
					"Failed recording generated file: expected absolute " .
					"path; found $path"
				);
		$this->files[] = realpath($path);
	}
	function execute()
	{
		$level = E_ALL & ~(E_NOTICE | E_USER_NOTICE | E_STRICT);
		if (defined('E_DEPRECATED'))
			$level &= ~(E_DEPRECATED | E_USER_DEPRECATED);
		set_error_handler([$this, 'handleError'], $level);
		try {
			$result = $this->doExecute();
			restore_error_handler();
			return $result;
		} catch (Throwable $e) {
			restore_error_handler();
			$this->log->logError($e);
			return false;
		}
	}
	protected function doExecute()
	{
		try {
			$this->commandLine = new CommandLine;
			$this->commandLine->parse();
			$this->commandLine->setAction();
			if ($this->commandLine->action()->name() == 'help') {
				$this->commandLine->action()->execute($this);
				return true;
			}
			$this->projectRoot = getcwd();
			$this->buildConfig = BuildConfig::load($this->projectRoot);
			$this->log = $this->commandLine->createLog($this->projectRoot);
			if (!ini_get('date.timezone')) {
				$zone = DEFAULT_TIMEZONE;
				date_default_timezone_set($zone);
				if ($str = $this->getStream(Log::INFO))
					$str->write("Using timezone $zone");
			}
			if ($str = $this->getStream(Log::INFO))
				$str->write("Validating command line");
			$this->commandLine->action()->checkCommandLine($this);


			if ($this->commandLine->action()->name() == 'info') {
				$this->commandLine->action()->execute($this);
				return true;
			}
			$this->updateConfig();

		} catch (Throwable $e) {
			$this->logError($e);
			return false;
		}
		$status = true;
		try {
			$action = $this->commandLine()->action();
			if ($str = $this->getStream(Log::INFO))
				$str->write("Executing build action '" . $action->name() . "'");
			$action->execute($this);
		} catch (Throwable $e) {
			$status = false;
			$this->logError($e);
		}
		try {
			$this->recordGeneratedFiles();
		} catch (Throwable $e) {
			$status = false;
			$this->logError($e);
		}
		if (self::errorCount())
			$status = false;
		$this->buildConfig->setStatus($status);
		try {
			if ($this->buildConfig->projectConfigFile()) {
				if ($str = $this->getStream(Log::INFO))
					$str->write("Saving build configuration");
				$this->buildConfig->save($this->projectRoot);
			}
		} catch (Throwable $e) {
			$status = false;
			$this->logError($e);
		}

		$count = self::errorCount();
		if ($str = $this->getStream(Log::INFO))
			$str->write("There were $count error(s)");
		return $status;
	}
	function build()
	{
		\Makeme\Config::clear();
		$targets = sizeof($this->commandLine()->arguments()) ?
			$this->commandLine()->arguments() :
			[];
		$this->targets = new TargetSet($this, $targets);
		try {
			$this->targets->execute();
		} catch (Throwable $e) {
			$this->targets = null;
			throw $e;
		}
		$this->targets = null;
	}
	function handleError($errno, $errstr, $errfile, $errline)
	{
		throw new
			Error(
				ErrorHandler::errorCategory($errno) .
					": $errstr in $errfile on line $errline"
			);
	}
	function loadPackageManagers()
	{
		  $managers = [];
		  if (isBootstrapping()) {
			  foreach (get_declared_classes() as $class) {
				  $match = [];
				  if ( preg_match(
						   '/^Makeme\\\Build\\\Packages\\\([^_]+)\\\Manager$/',
						   $class,
						   $match ) )
				  {
					  $managers[] = new $class($this);
				  }
			  }
		  } else {
			$handler = new ErrorHandler;
			$packagesDir =
				$this->buildConfig()->toolsPath() .
				"/CodeRage/Build/Packages";
			$dir = $handler->_opendir($packagesDir);
			if ($handler->errno())
				throw new Error("Failed reading directory: $packagesDir");
			while (($file = @readdir($dir)) !== false) {
				if ($file != 'Test' && is_dir("$packagesDir/$file")) {
					$class = "Makeme\\Build\\Packages\\$file\\Manager";
					if (!class_exists($class)) {
						$classPath = "$packagesDir/$file/Manager.php";
						\Makeme\File\checkReadable($classPath);
						require_once($classPath);
						if (!class_exists($class))
							throw new
								Error(
									"Invalid framework '$framework'; no such " .
									"class: $class"
								);

					}
					$managers[] = new $class($this);
				}
			}
			@closedir($dir);
		  }
		return $managers;
	}
	private function updateConfig()
	{
		if ($str = $this->getStream(Log::INFO))
			$str->write("Updating build configuration");
		$oldConfig = $this->buildConfig;
		$newConfig =
			BuildConfig::create(
				$this->commandLine,
				$this->projectRoot
			);
		$newConfig->inheritConfigFiles($oldConfig);
		$newConfig->inheritRepositoryInfo($oldConfig);
		$newConfig->inheritCommandLineProperties($oldConfig);
		$newConfig->inheritEnvironmentProperties($oldConfig);
		$this->buildConfig = $newConfig;
		if ( $this->commandLine->action()->requiresProjectConfig($this) &&
			 $this->buildConfig->projectConfigFile())
		{
			$path = $this->buildConfig->projectConfigFile()->path();
			if (pathinfo($path, PATHINFO_EXTENSION) == 'xml') {
				$dom = \Makeme\Xml\loadDom($path);
				$doc = $dom->documentElement;
				$ns = NAMESPACE_URI;
				if ($doc->localName == 'project' && $doc->namespaceURI == $ns) {
					if ($k = \Makeme\Xml\firstChildElement($doc, 'info', $ns)) {
					   $info = Info::fromXml($k);
					   $this->buildConfig->setProjectInfo($info);
					}
				}
			}
			if ($this->needNewProjectConfig($oldConfig)) {
				$this->updateProjectConfig($newConfig);
			} else {
				$this->loadProjectConfig();
			}
			$newConfig->setCommandLineProperties($this->projectConfig);
			$newConfig->setEnvironmentProperties($this->projectConfig);
		}
	}
	private function needNewProjectConfig(BuildConfig $oldConfig)
	{
		if ( !$oldConfig->projectConfigFile() ||
			 sizeof($this->commandLine->getValue('set', true)) > 0 ||
			 sizeof($this->commandLine->getValue('unset', true)) > 0 ||
			 sizeof($this->commandLine->getValue('config')) ||
			 !file_exists("$this->projectRoot/.coderage/config.xml") )
		{
			return true;
		}
		$lastBuild = $oldConfig->timestamp();
		$old = $oldConfig->systemConfigFile();
		$new = $this->buildConfig->systemConfigFile();
		if ($this->configFileChanged($old, $new, $lastBuild))
			return true;
		$old = $oldConfig->projectConfigFile();
		$new = $this->buildConfig->projectConfigFile();
		if ($this->configFileChanged($old, $new, $lastBuild))
			return true;
		$old = $oldConfig->additionalConfigFiles();
		$new = $this->buildConfig->additionalConfigFiles();
		if (sizeof($old) != sizeof($new))
			return true;
		for ($z = 0, $n = sizeof($old); $z < $n; ++$z)
			if ($this->configFileChanged($old[$z], $new[$z], $lastBuild))
				return true;
		return false;
	}
	private function configFileChanged($old, $new, $lastBuild)
	{
		return ($old === null) != ($new === null) ||
			   $new && $new->path() != $old->path() ||
			   $new && $new->timestamp() > $lastBuild;
	}
	private function loadProjectConfig()
	{
		try {
			if ($str = $this->getStream(Log::INFO))
				$str->write("Loading project configuration");
			$file = "$this->projectRoot/.coderage/config.xml";
			$reader = new File($this, $file);
			$this->projectConfig = $reader->read();
		} catch (Throwable $e) {
			throw new
				Error(
					'Failed loading project configuration: ' . $e->getMessage()
				);
		}
	}
	private function updateProjectConfig(BuildConfig $newConfig)
	{
		if ($str = $this->getStream(Log::INFO))
			$str->write("Updating project configuration");
		$config = $this->generateProjectConfig($newConfig);
		$this->projectConfig = $config;
		$backend = ($prop = $config->lookupProperty('backend_language')) ?
			$prop->value() :
			'';
		$languages = split($backend);
		$languages[] = 'xml';
		if (!in_array('php', $languages))
			$languages[] = 'php';
		foreach ($languages as $lang) {
			if ($str = $this->getStream(Log::INFO))
				$str->write("Generating $lang configuration");
			$file = 'CodeRage/Build/Config/Writer/' . ucfirst($lang) . '.php';
			if ($search = \Makeme\File\searchIncludePath($file))
					  require_once($search);
			$class = 'Makeme\\Build\\Config\\Writer\\' . ucfirst($lang);
			if (!class_exists($class))
				if ($str = $this->log->getStream(Log::ERROR)) {
					$str->write("Invalid backend language: $lang");
					continue;
				}
			$writer = new $class;
			$path = "$this->projectRoot/.coderage/config.$lang";
			$writer->write($config, $path);
			$this->recordGeneratedFile($path);
		}
	}
	private function generateProjectConfig(BuildConfig $newConfig)
	{
		if ($str = $this->getStream(Log::INFO))
			$str->write("Generating project configuration");

		$configs = [];
		$reader = new Config\Reader\Environment;
		array_unshift($configs, $reader->read());
		if ($file = $newConfig->systemConfigFile()) {
			$reader = new File($this, $file->path());
			array_unshift($configs, $reader->read());
		}
		if ($file = $newConfig->projectConfigFile()) {
			$reader = new File($this, $file->path());
			$projectConfig = $reader->read();
			if ($info = $newConfig->projectInfo())
				foreach (split(Info::PROPERTIES) as $p) {
					  if ($info->$p())
							$projectConfig->addProperty(
								new Property(
										"project.$p",
										STRING | ISSET_,
										$info->$p(), $file->path(), $file->path()
									)
							);
				}
			array_unshift($configs, $projectConfig);
		}
		foreach (array_reverse($newConfig->additionalConfigFiles()) as $file) {
			$reader = new File($this, $file->path());
			array_unshift($configs, $reader->read());
		}
		$unset = $this->unsetCommandLineVariables();
		if ($this->buildConfig) {
			  $cmdline = new Config\Basic;
			  foreach ($this->buildConfig->commandLineProperties() as $n => $v)
			  {
				  if (!in_array($n, $unset)) {
					  $cmdline->addProperty(
						  new Property(
								  $n,
								  STRING | ISSET_,
								  $v,
								  COMMAND_LINE,
								  COMMAND_LINE
							  )
					  );
				  }
			  }
			array_unshift($configs, $cmdline);
		}
		$reader = new Config\Reader\CommandLine($this->commandLine);
		array_unshift($configs, $reader->read());
		$result =  new Config\Compound($configs);
		if ($result->lookupProperty('tools_root') === null)
			$result->addProperty(
				new Property(
						'tools_root', STRING | ISSET_,
									$newConfig->toolsPath(), null, null
					)
			);
		validateProjectConfig($result);

		return $result;
	}
	private function recordGeneratedFiles()
	{
		if (sizeof($this->files) == 0)
			return;
		$path = $this->projectRoot .'/' . self::GENERATED_FILE_LOG;
		if (!file_exists($path))
			touch($path);
		$path = realpath($path);
		if ($str = $this->getStream(Log::VERBOSE))
			$str->write("Saving list of generated files to '$path'");
		$content = \Makeme\File\getContents($path);
		foreach (explode("\n", rtrim($content)) as $f)
			$this->files[] = $f;
		$this->files = array_unique($this->files);
		$content = join("\n", $this->files);
		if (!$this->handler->_file_put_contents($path, $content))
			if ($str = $this->log->getStream(Log::ERROR))
				$str->write(
					$this->handler->formatError(
						'Failed saving list of generated files'
					)
				);
	}
	private function unsetCommandLineVariables()
	{
		$properties = [];
		if ($values = $this->commandLine->getValue('u', true)) {
			$pattern = '/^[_a-z][_a-z0-9]*(?:\.[_a-z][_a-z0-9]*)*$/i';
			foreach ($values as $v) {
				if (preg_match($pattern, $v)) {
					$properties[] = $v;
				} else {
					throw new Error("Invalid option: -u $v");
				}
			}
		}
		return $properties;
	}
	private function logError(Throwable $e)
	{
		if ($this->log) {
			if ($e instanceof Error)
				$e->log($this->log);
			elseif ($stream = $this->log->getStream(Log::ERROR))
				$stream->write($e->getMessage());
		} else {
			echo $e->message() . "\n";
		}
	}
	private static function errorCount()
	{
		return
			\Makeme\Log\Provider\Counter::getCount([
				'tag' => 'Build',
				'maxLevel' => Log::ERROR
			]);
	}
}
namespace Makeme\Xml;

use Makeme\Error;
use function Makeme\File\checkReadable;

function loadDom($file, $schema = null, $options = 0)
{
	return _loadDomImpl($file, 'location', $schema, $options);
}
function loadDomXml($xml, $schema = null, $options = 0)
{
	return _loadDomImpl($xml, 'string', $schema, $options);
}
function _loadDomImpl($value, $type, $schema = null, $options = 0)
{
	if ($type == 'location')
		checkReadable($value, null, null, true);
	$doc = new \DOMDocument;
	$handler = new \Makeme\Util\ErrorHandler;
	$method = $type == 'location' ?
		'_load' :
		'_loadXml';
	$success = $handler->$method($doc, $value, $options);
	if ($handler->errno())
		throw new
			Error([
				'status' => 'UNEXPECTED_CONTENT',
				'details' =>
					$handler->formatError(
						"Failed parsing " .
						($type == 'location' ? "'$value'" : "XML")
					)
			]);
	if (!$success)
		throw new
			Error([
				'status' => 'UNEXPECTED_CONTENT',
				'details' =>
					"Failed parsing " .
					($type == 'location' ? "'$value'" : "XML")
			]);
	if ($schema) {
		$path = null;
		if (!($path = \Makeme\File\find($schema, null, null, true)))
			throw new
				Error([
					'status' => 'OBJECT_DOES_NOT_EXIST',
					'details' =>
						"Failed validating " .
						($type == 'location' ? "'$value'" : "XML") .
						": the file '$schema' does not exist"
				]);
		checkReadable($path);
		$success = $handler->_schemaValidate($doc, $path);
		if ($handler->errno())
			throw new
				Error([
					'status' => 'UNEXPECTED_CONTENT',
					'details' =>
						$handler->formatError(
							"Failed validating " .
							($type == 'location' ? "'$value'" : "XML") .
							" against schema '$schema'"
						)
				]);
		if (!$success)
			throw new
				Error([
					'status' => 'UNEXPECTED_CONTENT',
					'details' =>
						"Failed validating " .
						($type == 'location' ? "'$value'" : "XML") .
						" against schema '$schema'"
				]);
	}
	return $doc;
}
namespace Makeme\Xml;
function firstChildElement(
	\DOMElement $elt, $localName, $namespace = null)
{
	$kids = $elt->childNodes;
	for ($z = 0, $n = $kids->length; $z < $n; ++$z) {
		$k = $kids->item($z);
		if ( $k->nodeType == XML_ELEMENT_NODE &&
			 ($localName === null || $k->localName == $localName) &&
			 ($namespace === null || $k->namespaceURI === $namespace) )
		{
			return $k;
		}
	}
	return null;
}
namespace Makeme\Text;
function split($str, $pattern = '/\s+/', $trim = true)
{
	return $trim ?
		( !$str || ctype_space($str) ?
			  [] :
			  preg_split($pattern, trim($str)) ) :
		preg_split($pattern, $str);
}
namespace Makeme\Log;
interface IProvider {
	function name();
	function dispatchEntry(Entry $entry);
}
namespace Makeme\Log\Provider;

use Makeme\Log;

final class Counter implements \Makeme\Log\IProvider {

	public function name() { return 'counter'; }
	public function dispatchEntry(\Makeme\Log\Entry $entry)
	{
		$level = $entry->level();
		$tags = $entry->tags();
		if (!isset(self::$count[$level]))
			self::$count[$level] = 0;
		++self::$count[$level];
		foreach ($tags as $t) {
			if (!isset(self::$countByTag[$t]))
				self::$countByTag[$t] = [];
			if (!isset(self::$countByTag[$t][$level]))
				self::$countByTag[$t][$level] = 0;
			++self::$countByTag[$t][$level];
		}
	}
	public static function getCount($options)
	{
		$options +=
			[
				'tag' => null,
				'minLevel' => Log::ERROR,
				'maxLevel' => Log::DEBUG
			];
		if ($options['maxLevel'] < $options['minLevel'])
			throw new
				\Makeme\Error([
					'status' => 'INCONSISTENT_PARAMETERS',
					'details' => 'Maximum level is lower than minimum level'
				]);
		$result = 0;
		for ($z = $options['minLevel']; $z <= $options['maxLevel']; ++$z)
			$result += isset($options['tag']) ?
				( isset(self::$countByTag[$options['tag']][$z]) ?
					  self::$countByTag[$options['tag']][$z] :
					  0 ) :
				( isset(self::$count[$z]) ?
					  self::$count[$z] :
					  0 );
		return $result;
	}
	private static $count = [];
	private static $countByTag = [];
}
namespace Makeme\File;

function getContents(
	$path, $flags = null, $context = null, $offset = 0, $maxlen = null)
{
	checkReadable($path);
	$contents = $maxlen !== null ?
		file_get_contents($path, $flags, $context, $offset, $maxlen) :
		file_get_contents($path, $flags, $context, $offset);
	if ($contents === false)
		throw new \Makeme\Error("Failed reading file: $path");
	return $contents;
}
namespace Makeme\File;

use Makeme\Error;

function generate($path, $content, $type = null)
{
	$guess = $type === null;
	if ($guess) {
		$match = null;
		if (!preg_match('#[^/\\.]\.([^/\\.]+)$#', $path, $match))
			throw new
				Error([
					'status' => 'INCONSISTENT_PARAMETERS',
					'details' => "Can't guess type of file '$path'"
				]);
		$type = $match[1];
	}
	$prefix = null;
	$warning = 'AUTOMATICALLY GENERATED BY CODERAGE TOOLS - DO NOT EDIT';
	$timestamp = date(DATE_W3C);
	$copyright = 'Copyright CodeRage';
	$n = \Makeme\Util\os() == 'posix' ? "\n" : "\r\n";
	switch (strtolower($type)) {
	case 'bat':
		$prefix = ":: $warning$n:: $timestamp$n::$copyright$n";
		break;
	case 'c':
	case 'cs':
	case 'css':
	case 'c++':
	case 'java':
	case 'js':
		$prefix = "/* $warning */$n/* $timestamp */$n/* $copyright */$n";
		break;
	case 'htm':
	case 'html':
		$prefix =
			"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"
				\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">$n" .
			"<!-- $warning -->$n<!-- $timestamp -->$n<!-- $copyright -->$n";
		break;
	case 'ini':
		$prefix = "; $warning$n; $timestamp$n; $copyright$n";
		break;
	case 'php':
		$prefix =
			"<?php$n/* $warning */$n/* $timestamp */$n/* $copyright */$n";
		$content = preg_replace('/^<\?php[^\n]*\n/', '', $content);
		break;
	case 'pl':
	case 'pm':
	case 'py':
		$prefix = "# $warning$n# $timestamp$n# $copyright$n";
		break;
	case 'xml':
		$prefix =
			   '<?xml version="1.0" encoding="UTF-8"?>' . "$n$n" .
			   "<!-- $warning -->$n<!-- $timestamp -->$n" .
			   "<!-- $copyright -->$n";
		break;
	default:
		$msg = $guess ?
		   "Can't guess type of file '$path'" :
		   "Unknown file type: $type";
		throw new
			Error([
				'status' => 'INCONSISTENT_PARAMETERS',
				'details' => $msg
			]);
	}
	$suffix = $type == "php" ? "$n?>$n" : "";
	$content = str_replace("\r", '', $content);
	if ($n == "\r\n")
		$content = str_replace("\n", "\r\n", $content);
	mkdir(dirname($path));
	if (!@file_put_contents($path, "$prefix$content$suffix"))
		throw new
			Error([
				status => 'FILESYSTEM_ERROR',
				details => "Failed writing to file '$path'"
			]);
}
namespace Makeme\File;
function mkdir($dir, $mode = 0777)
{
	if (file_exists($dir))
		return true;
	$isUnc = strlen($dir) >= 2 &&
	   ( $dir[0] == '\\' && $dir[1] == '\\' ||
		 $dir[0] == '/' && $dir[1] == '/' );
	$driveSpec =
		strcasecmp(substr(PHP_OS, 0, 3), 'WIN') == 0 &
		strlen($dir) >= 2 && ctype_alpha($dir[0]) && $dir[1] == ':' ?
			substr($dir, 0, 2) :
			'';
	$isAbs = strlen($dir) >= 1 && ($dir[0] == '\\' || $dir[0] == '/') ||
		$driveSpec;

	$parts = preg_split('{[/\\\\]+}', $dir);
	if (!$parts[0] || $driveSpec)
		array_shift($parts);
	if ($isUnc && sizeof($parts) <= 1)
		return false;
	$prefix = $isUnc ? '\\\\' : ( $isAbs ? "$driveSpec/" : '');
	$handler = new \Makeme\Util\ErrorHandler;
	for ($z = 0, $n = sizeof($parts); $z < $n; ++$z) {
		$prefix .= $z > 0 ? "/{$parts[$z]}" : $parts[$z];
		if ($isUnc && $z <= 1) {
			if ($z == 1 && !file_exists($prefix))
			   return false;
		} elseif (!is_dir($prefix)) {
			if (!$handler->_mkdir($prefix, 0777) || $handler->errno())
				return false;
		}
	}
	return true;
}
namespace Makeme\Build;
function isBootstrapping()
{
	return strncmp(__NAMESPACE__, 'Code', 4) != 0;
}
namespace Makeme\Build;

use Makeme\Error;

class Info {

	const PROPERTIES =
		'label description version date copyright license author link';
	private static $keys;
	private $label;
	private $description;
	private $version;
	private $date;
	private $copyright;
	private $license;
	private $author;
	private $link;
	function __construct($properties = [])
	{
		if (!self::$keys) {
			self::$keys = [];
			foreach (\Makeme\Text\split(self::PROPERTIES) as $p)
				self::$keys[$p] = 1;
		}
		foreach ($properties as $n => $v) {
			if (isset(self::$keys[$n])) {
				if (!is_string($v))
					throw new
						Error(
							"Invalid value of property '$n': expected " .
							"string; found" . \Makeme\Util\printScalar($v)
						);
				$this->$n = $v;
			} else {
				throw new Error("Invalid property name: $n");
			}
		}
	}
	function label()
	{
		return $this->label;
	}
	function description()
	{
		return $this->description;
	}
	function version()
	{
		return $this->version;
	}
	function date()
	{
		return $this->date;
	}
	function copyright()
	{
		return $this->copyright;
	}
	function license()
	{
		return $this->license;
	}
	function author()
	{
		return $this->author;
	}
	function link()
	{
		return $this->link;
	}
	static function create($properties = [])
	{
		if ( !isset($properties['description']) &&
			 isset($properties['label']) )
		{
			$properties['description'] = $properties['label'];
		}
		if (!isset($properties['author']))
			$properties['author'] = 'CodeRage';
		if (!isset($properties['copyright']))
			$properties['copyright'] = date('Y') . ' CodeRage';
		if (!isset($properties['license']))
			$properties['license'] = 'All rights reserved';
		return new Info($properties);
	}
	static function fromXml(\DOMElement $info)
	{
		$properties = [];
		foreach (\Makeme\Xml\childElements($info) as $k)
			$properties[$k->localName] = $k->nodeValue;
		return new Info($properties);
	}

}
namespace Makeme\Xml;
function getAttribute(\DOMElement $elt, $name, $default = null)
{
	return $elt->hasAttribute($name) ?
		$elt->getAttribute($name) :
		$default;
}
namespace Makeme\Xml;
function childContent(\DOMElement $elt, $localName)
{
	return ($kid = firstChildElement($elt, $localName)) ?
		textContent($kid) :
		'';
}
namespace Makeme\Build;
const COMMAND_LINE = 1;
const ENVIRONMENT = 2;
const CONSOLE = 3;
const ISSET_ = 4;
const BOOLEAN = ISSET_ << 1;
const INT = BOOLEAN << 1;
const FLOAT = INT << 1;
const STRING = FLOAT << 1;
const LIST_ = STRING << 1;
const REQUIRED = LIST_ << 1;
const STICKY = REQUIRED << 1;
const OBFUSCATE = STICKY << 1;

const TYPE_MASK = BOOLEAN | INT |
		FLOAT | STRING;
const CONFIG_ENVIRONMENT_PREFIX = 'coderage_';
const NAMESPACE_URI = 'http://www.coderage.com/2008/project';
const REPO_URL = 'git@github.com:BKWatch/CodeRage';
const REPO_BRANCH = 'master';
const DEFAULT_TIMEZONE = 'America/Denver';
namespace Makeme\Build\Config;
interface Reader {
	function read();
}
namespace Makeme\Build\Config\Reader;

use DOMElement;
use const Makeme\Build\BOOLEAN;
use Makeme\Build\Config\Basic;
use Makeme\Build\Config\Property;
use function Makeme\Build\Config\convert;
use const Makeme\Build\FLOAT;
use const Makeme\Build\INT;
use const Makeme\Build\ISSET_;
use const Makeme\Build\LIST_;
use const Makeme\Build\NAMESPACE_URI;
use const Makeme\Build\STRING;
use Makeme\Error;
use Makeme\Util\ErrorHandler;
use function Makeme\Xml\childElements;
use function Makeme\Xml\getAttribute;
use function Makeme\Xml\getBooleanAttribute;

class File implements \Makeme\Build\Config\Reader {
	const VALIDATE_NAME = '/^([_a-z][_a-z0-9]*(?:\.[_a-z][_a-z0-9]*)*)$/i';
	private $run;
	private $path;
	private $properties;
	function __construct(\Makeme\Build\Run $run, $path)
	{
		$this->run = $run;
		$this->path = $path;
		\Makeme\File\checkReadable($path);
		switch (pathinfo($path, PATHINFO_EXTENSION)) {
		case 'xml':
			$this->readXmlFile($path);
			break;
		case 'ini':
			$this->readIniFile();
			break;
		case '':
		case 'php':
			$this->readPhpFile();
			break;
		default:
			throw new Error("Unknown config file type: $path");
		}
	}
	function read()
	{
		return $this->properties;
	}
	private function readXmlFile($path)
	{
		$schema = \Makeme\Build\Resource_::loadFile($this->run, 'project.xsd');
		$dom = \Makeme\Xml\loadDom($path, $schema);
		$root = $dom->documentElement;
		if ( $root->localName != 'project' &&
				 $root->localName != 'config' ||
			 $root->namespaceURI != NAMESPACE_URI )
		{
			$element =
				($root->namespaceURI ? "$root->namespaceURI:" : '') .
				$root->localName;
			throw new
				Error(
					"Invalid configuration file '$path': expected '" .
					NAMESPACE_URI . ":project' or '" .
					NAMESPACE_URI . ":config'; found " .
					"'$element'"
				);
		}
		$properties = new Basic;
		if ($root->localName == 'project') {
			foreach (childElements($root, 'include') as $inc) {
				$src = $inc->getAttribute('src');
				$file = \Makeme\File\find($src, dirname($path), false);
				if (!$file)
					throw new
						Error(
							"Failed parsing config file '$path': no such " .
							"file: '$src'"
						);
				$reader = new File($this->run, $file);
				$props = $reader->read();
				foreach ($props->propertyNames() as $n)
					$properties->addProperty($props->lookupProperty($n));
			}
		}
		$config = $root->localName == 'config' ?
			$root :
			\Makeme\Xml\firstChildElement($root, 'config');
		if ($config)
			foreach (self::readGroup($config, $path) as $p)
				$properties->addProperty($p);
		$this->properties = $properties;
	}
	private function readIniFile()
	{
		$path = $this->path;
		$handler = new ErrorHandler;
		$values = $handler->_parse_ini_file($path);
		if ($values === false || $handler->errno())
			throw new
				Error(
					$handler->formatError("Failed parsing config file '$path'")
				);
		if (sizeof($values) == 0) {
			$content = @file_get_contents($path);
			if (preg_match('/^\s*[^;[]/', $content))
				throw new Error("Failed parsing config file '$path'");
		}
		$props = new Basic;
		foreach ($values as $n => $v) {
			if (!preg_match(self::VALIDATE_NAME, $n))
				throw new Error("Invalid variable name: $n");
			$flags = null;
			switch (gettype($v)) {
			case 'boolean':
				$flags = BOOLEAN;
				break;
			case 'int':
				$flags = INT;
				break;
			case 'double':
				$flags = FLOAT;
				break;
			case 'string':
				$flags = STRING;
				break;
			default:
				throw new
					Error(
						"Invalid value for property '$n': " .
						\Makeme\Util\printScalar($v)
					);
			}
			$flags |= ISSET_;
			$props->addProperty(
				new Property($n, $flags, $v, $path, $path)
			);
		}
		$this->properties = $props;
	}
	private function readPhpFile()
	{
		$path = $this->path;
		$namespace = NAMESPACE_URI;
		$file = addcslashes($path, "'\\");
		$command =
			'php -nr "function f($f){if (!@include($f)) exit(1); echo\'' .
			'<config xmlns=\"' . $namespace . '\">\';foreach(get_defined_vars' .
			'()as$p=>$v){if(substr($p,0,4)==\'CFG_\')echo\'<property name=' .
			'\"\'.substr($p,4).\'\" value=\"\'.(is_bool($v)?intval($v):(' .
			'is_null($v)?\'null\':htmlentities($v))).\'\" type=\"\'.(((' .
			'$t=gettype($v))==\'integer\')?\'int\':$t).\'\"/>\';}echo\'' .
			'</config>\';}f(\'' . $file . '\');"';
		if (\Makeme\Util\os() == 'posix')
			$command = str_replace('$', '\\$', $command);
		ob_start();
		$status = null;
		@system($command, $status);
		$xml = ob_get_contents();
		ob_end_clean();
		if ($status != 0)
			throw new Error("Failed parsing config file '$path'");
		$temp = \Makeme\File\temp('', 'xml');
		$handler = new ErrorHandler;
		$handler->_file_put_contents($temp, $xml);
		if ($handler->errno())
			throw new Error('Failed writing temporary XML configuration');
		$this->readXmlFile($temp);
	}
	private function readGroup(DOMElement $group, $baseUri, $prefix = null)
	{
		$result = [];
		foreach (childElements($group) as $elt) {
			switch ($elt->localName) {
			case 'group':
				$name = getAttribute($elt, 'name');
				if ($group->localName == 'group' && $name === null)
					throw new
						Error(
							"Missing 'name' attribute on 'group' element " .
							"in " . \Makeme\Xml\documentPath($group)
						);
				$props =
					self::readGroup(
						$elt, $baseUri, self::applyPrefix($prefix, $name)
					);
				foreach ($props as $p)
					$result[] = $p;
				break;
			case 'property':
				$result[] = self::readProperty($elt, $prefix);
				break;
			default:
				break;
			}
		}
		return $result;
	}
	private function readProperty(DOMElement $property, $prefix = null)
	{
		$name =
			self::applyPrefix(
				$prefix, getAttribute($property, 'name')
			);
		$flags = 0;
		$value = null;
		if (getBooleanAttribute($property, 'list', false))
			$flags |= LIST_;
		if ($property->hasAttribute('value')) {
			$flags |= ISSET_;
			$value = getAttribute($property, 'value');
			$encoding = getAttribute($property, 'encoding');
			if ($flags & LIST_) {
				if ($sep = getAttribute($property, 'separator')) {
					$value = explode($sep, $value);
				} else {
					$value = \Makeme\Text\split($value);
				}
				if ($encoding == 'base64')
					$value = array_map('base64_decode', $value);
			} elseif ($encoding == 'base64') {
				$value = base64_decode($value);
			}
		}
		if ($type = getAttribute($property, 'type')) {
			switch ($type) {
			case 'boolean':
				$flags |= BOOLEAN;
				break;
			case 'int':
				$flags |= INT;
				break;
			case 'float':
				$flags |= FLOAT;
				break;
			case 'string':
				$flags |= STRING;
				break;
			default:
				throw new \Exception("Unknown property type: $type");
			}
			$target = $flags & \Makeme\Build\TYPE_MASK;
			if ($flags & LIST_) {
				for ($z = 0, $n = sizeof($value); $z < $n; ++$z)
					$value[$z] = convert($value[$z], $target);
			} else {
				$value = convert($value, $target);
			}
		}
		if (getBooleanAttribute($property, 'required', false))
			$flags |= \Makeme\Build\REQUIRED;
		if (getBooleanAttribute($property, 'sticky', false))
			$flags |= \Makeme\Build\STICKY;
		if (getBooleanAttribute($property, 'obfuscate', false))
			$flags |= \Makeme\Build\OBFUSCATE;
		$specifiedAt =
			getAttribute($property, 'specifiedAt', $this->path);
		$setAt = null;
		if ($flags & ISSET_) {
			$attr = getAttribute($property, 'setAt', $this->path);
			switch ($attr) {
			case '<command-line>':
				$setAt = \Makeme\Build\COMMAND_LINE;
				break;
			case '<environment>':
				$setAt = \Makeme\Build\ENVIRONMENT;
				break;
			case '<console>':
				$setAt = \Makeme\Build\CONSOLE;
				break;
			default:
				break;
			}
		} elseif ($property->hasAttribute('setAt')) {
			throw new
				Error(
					"Invalid attribute 'setAt' for property '$name': no " .
					"value specified for property"
				);
		}

		return new
			Property(
				$name, $flags, $value, $specifiedAt, $setAt
			);
	}
	private function applyPrefix($prefix, $name)
	{
		return $prefix === null ?
			$name :
			( $name === null ?
				  $prefix :
				  "$prefix.$name" );
	}
}
namespace Makeme\Xml;

function getBooleanAttribute(\DOMElement $elt, $name, $default = null)
{
	if ($elt->hasAttribute($name)) {
		$value = $elt->getAttribute($name);
		return $value == 'true' || $value == '1';
	} elseif ($default === null) {
		throw new \Makeme\Error("Missing boolean attribute '$name'");
	} else {
		return $default;
	}
}
namespace Makeme\Xml;
function documentPath(\DOMDocument $dom)
{
	return ($uri = $dom->documentURI) ?
		urldecode(parse_url($uri, PHP_URL_PATH)) :
		null;
}
namespace Makeme\Xml;
function childElements(
	\DOMElement $elt, $localName = null, $namespace = null)
{
	$result = [];
	$kids = $elt->childNodes;
	for ($z = 0, $n = $kids->length; $z < $n; ++$z) {
		$k = $kids->item($z);
		if ( $k->nodeType == XML_ELEMENT_NODE &&
			 ($localName === null || $k->localName == $localName) &&
			 ($namespace === null || $k->namespaceURI === $namespace) )
		{
			$result[] = $k;
		}
	}
	return $result;
}
namespace Makeme\File;

use Makeme\Error;

function temp($prefix = '', $ext = null, $cleanup = false)
{
	static $paths;
	if ($paths === null) {
		$paths = [];
		register_shutdown_function('Makeme\File\temp', null, null, true);
	}
	if ($cleanup) {
		foreach ($paths as $p)
			if (file_exists($p))
				@unlink($p);
		return;
	}
	$dir = systemTempDir();
	$path = null;
	if ($ext !== null) {
		if ($ext)
			$ext = ".$ext";
		$rand = $prefix;
		for ($z = 0; $z < 10; ++$z) {
			$rand .= \Makeme\Util\randomString(10);
			if (!file_exists($file = "$dir/$rand$ext")) {
				@touch($file);
				@chmod($file, 0600);
				if ( is_file($file) &&
					 ( \Makeme\Util\os() == 'windows' ||
					   (fileperms($file) & 0777) == 0600 ) )
				{
					$path = $file;
					break;
				}
			}
		}
		if (!$path)
			throw new Error("Failed creating temporary file: $file");
	} else {
		if ($p = tempnam(systemTempDir(), $prefix)) {
			$paths[] = $p;
			return $p;
		} else {
			throw new Error('Failed creating temporary file.');
		}
	}

	$paths[] = $path;
	return $path;
}
namespace Makeme\File;

function systemTempDir()
{
	static $dir;
	if ($dir === null) {
		$file = md5(uniqid(rand(), true));
		$tmp = @tempnam($file, '');
		if ($tmp !== false && file_exists($tmp)) {
			$dir = dirname(realpath($tmp));
			@unlink($tmp);
		} else {
			throw new \Makeme\Error('Failed determining temp directory');
		}
	}
	return $dir;
}
namespace Makeme\Build\Config;

use const Makeme\Build\BOOLEAN;
use const Makeme\Build\COMMAND_LINE;
use const Makeme\Build\CONSOLE;
use const Makeme\Build\ENVIRONMENT;
use const Makeme\Build\FLOAT;
use const Makeme\Build\INT;
use const Makeme\Build\ISSET_;
use const Makeme\Build\LIST_;
use const Makeme\Build\STRING;
use const Makeme\Build\TYPE_MASK;
use Makeme\Error;
use function Makeme\Util\printScalar;

class Property {
	private $name;
	private $flags;
	private $value;
	private $specifiedAt;
	private $setAt;
	function __construct($name, $flags, $value, $specifiedAt, $setAt)
	{
		if (!is_string($name))
			throw new
				Error(
					'Invalid property name: expected string; found ' .
					printScalar($name)
				);
		$type = ($flags & TYPE_MASK);
		if (pow(2, floor(log($type, 2))) != $type)
			throw new Error("Invalid flags: $flags");
		if ($flags & ISSET_) {
			if ($flags & LIST_) {
				if (!is_array($value))
					throw new
						Error(
							"Invalid value for property '$name': expected " .
							"array; found " . printScalar($value)
						);
				foreach ($value as $v)
					if (!$this->checkValue($v, $type))
						throw new
							Error(
								"Invalid value for property '$name': " .
								" expected " . $this->translateType($type) .
								"; found " . printScalar($v)
							);
			} elseif (!$this->checkValue($value, $type)) {
				throw new
					Error(
						"Invalid value for property '$name': expected " .
						$this->translateType($type) . "; found " .
						printScalar($value)
					);
			}
		} elseif ($value !== null) {
			throw new
				Error(
					"Invalid value for property '$name': expected null; " .
					"found " . printScalar($value)
				);
		}
		if ( $specifiedAt != null &&
			 !is_string($specifiedAt) &&
			 $specifiedAt !== COMMAND_LINE &&
			 $specifiedAt !== ENVIRONMENT &&
			 $specifiedAt !== CONSOLE )
		{
			throw new
				Error(
					"Invalid value for 'specifiedAt': " .
					printScalar($specifiedAt)
				);
		}
		if ($setAt !== null) {
			if ( !is_string($setAt) &&
				 $setAt !== COMMAND_LINE &&
				 $setAt !== ENVIRONMENT &&
				 $setAt !== CONSOLE )
			{
				throw new
					Error(
						"Invalid value for 'setAt': " .
						printScalar($setAt)
					);
			}
			if (($flags & ISSET_) == 0)
				throw new
					Error(
						"Invalid value for 'setAt': expected null; found $setAt"
					);
		}
		$this->name = $name;
		$this->flags = $flags;
		$this->value = $value;
		$this->specifiedAt = $specifiedAt;
		$this->setAt = $setAt;
	}
	function name() { return $this->name; }
	function type()
	{
		return ($this->flags & TYPE_MASK);
	}
	function isList() { return ($this->flags & LIST_) != 0; }
	function required()
	{
		return ($this->flags & \Makeme\Build\REQUIRED) != 0;
	}
	function sticky()
	{
		return ($this->flags & \Makeme\Build\STICKY) != 0;
	}
	function obfuscate()
	{
		return ($this->flags & \Makeme\Build\OBFUSCATE) != 0;
	}
	function isSet_()
	{
		return ($this->flags & ISSET_) != 0;
	}
	function value() { return $this->value; }
	function specifiedAt() { return $this->specifiedAt; }
	function setAt() { return $this->setAt; }
	function __call($method, $args)
	{
		switch ($method) {
		case 'isSet':
			return $this->isSet_();
		default:
			throw new
				Error(
					"No such method: Makeme\\Build\\Config\\Property::$method"
				);
		}
	}
	static function translateType($type)
	{
		switch ($type) {
		case BOOLEAN:
			return 'boolean';
		case INT:
			return 'int';
		case FLOAT:
			return 'float';
		case STRING:
			return 'string';
		default:
			throw new Error("Unknown type: $type");
		}
	}
	static function translateLocation($location)
	{
		if (is_string($location))
			return $location;
		switch ($location) {
		case COMMAND_LINE:
			return '<command-line>';
		case ENVIRONMENT:
			return '<environment>';
		case CONSOLE:
			return '<console>';
		default:
			throw new Error("Unknown location: $location");
		}
	}
	private static function checkValue($value, $type)
	{
		switch ($type) {
		case BOOLEAN:
			return is_bool($value);
		case INT:
			return is_int($value);
		case FLOAT:
			return is_int($value) || is_float($value) && is_finite($value);
		case STRING:
		case 0:
			return is_string($value);
		default:
			throw new Error("Unknown type: $type");
		}
	}
}
namespace Makeme\Build\Config;

use Exception;

function convert($value, $type)
{
	if (is_string($value)) {
		switch ($type) {
		case \Makeme\Build\BOOLEAN:
			$value = strtolower($value);
			if ($value == 'true' || $value == 'yes' || $value == '1') {
				return true;
			} elseif ($value == 'false' || $value == 'no' || $value == '0') {
				return false;
			} else {
				throw new
					Exception(
						"Cannot convert value: expected boolean; found '$value'"
					);
			}
		case \Makeme\Build\INT:
			if (!is_numeric($value) || strval(intval($value)) != $value)
				throw new
					Exception(
						"Cannot convert value: expected integer; found '$value'"
					);
			return intval($value);
		case \Makeme\Build\FLOAT:
			if (!is_numeric($value))
				throw new
					Exception(
						"Cannot convert value: expected floating point value;" .
						" found '$value'"
					);
			return floatval($value);
		default:
			return $value;
		}
	} else {
		return $value;
	}
}
namespace Makeme\Build\Config;

use Makeme\Build\ProjectConfig;

class Basic implements ProjectConfig {
	private $properties = [];
	function __construct($properties = [])
	{
		if (is_array($properties)) {
			foreach ($properties as $p)
				$this->addProperty($p);
		} elseif ($properties instanceof ProjectConfig) {
			foreach ($properties->propertyNames() as $n)
				$this->addProperty(clone $properties->lookupProperty($n));
		} else {
			throw new
				\Makeme\Error(
				   'Invalid argument to Makeme\Build\Config\Basic:: ' .
				   '__construct(): ' . \Makeme\Util\printScalar($properties)
				);
		}
	}
	function propertyNames() { return array_keys($this->properties); }
	function lookupProperty($name)
	{
		return isset($this->properties[$name]) ?
			$this->properties[$name] :
			null;
	}
	function addProperty(Property $property)
	{
		$name = $property->name();
		if (isset($this->properties[$name]))
			throw new \Exception("The property '$name' already exists");
		$this->properties[$name] = $property;
	}
}
namespace Makeme\Build;
interface ProjectConfig {
	function propertyNames();
	function lookupProperty($name);
	function addProperty(Config\Property $property);
}

function validateProjectConfig(ProjectConfig $config)
{
	  foreach ($config->propertyNames() as $name) {
		  $property = $config->lookupProperty($name);
		  if ($property->required() && !$property->isSet())
			  throw new
				  \Makeme\Error(
					  "Missing value for required property '$name' " .
					  "specified at " . $property->specifiedAt()
				  );
	  }
}
namespace Makeme\Build\Config\Reader;

use const Makeme\Build\CONFIG_ENVIRONMENT_PREFIX;

class Environment implements \Makeme\Build\Config\Reader {
	function read()
	{
		$props = new \Makeme\Build\Config\Basic;
		$prefixLen = strlen(CONFIG_ENVIRONMENT_PREFIX);
		$pattern = '/^[_a-z][_a-z0-9]*(?:\.[_a-z][_a-z0-9]*)*$/';
		foreach ($_SERVER as $name => $value) {
			if (getenv($name) !== $value)
				continue;
			$name = strtolower($name);
			if (strncmp($name, CONFIG_ENVIRONMENT_PREFIX, $prefixLen))
				continue;
			$dotted = str_replace( '__', '.', substr($name, $prefixLen));
			if (!preg_match($pattern, $dotted))
				throw new \Makeme\Error("Invalid environment variable name: $name");
			$props->addProperty(
				new \Makeme\Build\Config\Property(
						$dotted, \Makeme\Build\ISSET_, $value, 0, \Makeme\Build\ENVIRONMENT
					)
			);
		}
		return $props;
	}
}
namespace Makeme\Build\Config\Reader;

class CommandLine implements \Makeme\Build\Config\Reader {
	private $commandLine;
	function __construct(\Makeme\Build\CommandLine $commandLine)
	{
		$this->commandLine = $commandLine;
	}
	function read()
	{
		$properties = new \Makeme\Build\Config\Basic;
		$pattern = '/^([_a-z][_a-z0-9]*(?:\.[_a-z][_a-z0-9]*)*)=(.*)$/i';
		if ($values = $this->commandLine->getValue('s', true)) {
			foreach ($values as $v) {
				if (preg_match($pattern, $v, $match)) {
					$properties->addProperty(
						new \Makeme\Build\Config\Property(
								$match[1],
								\Makeme\Build\ISSET_,
								$match[2],
								0,
								\Makeme\Build\COMMAND_LINE
							)
					);
				} else {
					throw new \Makeme\Error("Invalid option: -s $v");
				}
			}
		}
		return $properties;
	}
}
namespace Makeme\Build\Config;

use const Makeme\Build\ISSET_;
use const Makeme\Build\LIST_;
use const Makeme\Build\REQUIRED;
use const Makeme\Build\TYPE_MASK;
use Exception;

class Compound extends Basic {
	function __construct($bundles = [])
	{
		parent::__construct([]);
		$this->constructProperties($bundles);
	}
	private function constructProperties($bundles)
	{
		$merge = [];
		foreach ($bundles as $b)
			$merge[] = $b->propertyNames();
		$names = array_unique(call_user_func_array('array_merge', $merge));
		foreach ($names as $n) {
			$flags = 0;
			$specifiedAt = $setAt = $value = null;
			$count = sizeof($bundles);
			for ($z = $count - 1; $z != -1; --$z) {
				$b = $bundles[$z];
				$p = $b->lookupProperty($n);
				if (!$p)
					continue;
				if ( $z < $count - 1 &&
					 ( ( ($flags & LIST_) == 0 &&
						 $p->isList() &&
						 is_string($specifiedAt) ) ||
					   ( ($flags & LIST_) != 0 &&
						 !$p->isList() &&
						 is_string($p->specifiedAt()) ) ) )
				{
					$loc1 =
						Property::translateLocation(
							$specifiedAt
						);
					$loc2 =
						Property::translateLocation(
							$p->specifiedAt()
						);
					$list = $p->isList() ? $loc2 : $loc1;
					$scalar = $p->isList() ? $loc1 : $loc2;
					throw new
						Exception(
							"Inconsistent specification for property '$n':" .
							" property is a list at '$list' but a scalar at " .
							"'$scalar'"
						);
				}
				if ($p->isList())
					$flags |= LIST_;
				if ($p->type()) {
					$type = $flags & TYPE_MASK;
					if ( $z < $count - 1 &&
						 $type != 0 &&
						 $type != $p->type() &&
						 is_string($specifiedAt) &&
						 is_string($p->specifiedAt()) )
					{
						$type1 = Property::translateType($type);
						$type2 =
							Property::translateType($p->type());
						$loc1 =
							Property::translateLocation(
								$specifiedAt
							);
						$loc2 =
							Property::translateLocation(
								$p->specifiedAt()
							);
						throw new
							Exception(
								"Inconsistent specification for property " .
								"'$n': property is $type1 at '$loc1' but " .
								"$type2 at '$loc2'"
							);
					}
					$flags |= $p->type();
					$specifiedAt = $p->specifiedAt();
				}
				if ($p->required()) {
					$flags |= REQUIRED;
					$specifiedAt = $p->specifiedAt();
				}
				if ($p->sticky()) {
					$flags |= \Makeme\Build\STICKY;
					$specifiedAt = $p->specifiedAt();
				}
				if ($p->obfuscate()) {
					$flags |= \Makeme\Build\OBFUSCATE;
					$specifiedAt = $p->specifiedAt();
				}
				if ($p->isSet()) {
					$flags |= ISSET_;
					$setAt = $p->setAt();
					$value = $p->value();
				}
				if ($flags & ISSET_) {
					$type = $flags & TYPE_MASK;
					if ( ($flags & LIST_) != 0 &&
						 is_string($value) )
					{
						$value = \Makeme\Text\split($value);
					}
					if ($flags & LIST_) {
						for ($w = 0, $m = sizeof($value); $w < $m; ++$w)
							$value[$w] =
								convert($value[$w], $type);
					} else {
						$value = convert($value, $type);
					}
				}
			}

			if (($flags & TYPE_MASK) == 0)
				$flags |= \Makeme\Build\STRING;
			if ( ($flags & REQUIRED) != 0 &&
				 ($flags & ISSET_) == 0 )
			{
				throw new
					Exception("Missing value for required property '$n'");
			}
			$this->addProperty(
				new Property(
						$n, $flags, $value, $specifiedAt, $setAt
					)
			);
		}
	}
}
namespace Makeme\Util;

use Throwable;
use Makeme\Error;
use function Makeme\Text\wrap;

class CommandLine {
	const LINE_LENGTH = 70;
	function __construct(...$params)
	{
		$options = null;
		switch (count($params)) {
		case 0:
			$options =
				[
					'name' => 'command',
					'synopsis' => '[OPTIONS] ARGS...'
				];
			break;
		case 1:
			if (is_array($params[0])) {
				$options = $params[0];
				break;
			}
		case 2:
		case 3:
			$synopsis = $params[0];
			validate($synopsis, 'string', 'synopsis');
			$space = strpos($synopsis, ' ');
			if ($space === false)
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "Missing command name in synopsis"
					]);
			$description = isset($params[1]) ?
				$params[1] :
				null;
			if ($description !== null)
				validate($description, 'string', 'description');
			$example = isset($params[2]) ?
				$params[2] :
				null;
			if ($example !== null)
				validate($synopsis, 'string', 'example');
			$options =
				[
					'name' => substr($synopsis, 0, $space),
					'synopsis' => substr($synopsis, $space + 1),
					'description' => $description,
					'example' => $example
				];
			break;
		default:
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => 'Too many constructor arguments'
				]);
		}
		static $names =
			[
				'name' => 1,
				'description' => 1,
				'notes' => 1,
				'synopsis' => 1,
				'example' => 1,
				'executor' => 1,
				'helpless' => 1,
				'options' => 1,
				'subcommands' => 1,
				'version' => 1,
				'copyright' => 1,
				'bugEmail' => 1,
				'formatter' => 1
			];
		foreach ($options as $n => $v)
			if (!isset($names[$n]))
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "Illegal option: $n"
					]);
		processOption($options, 'name', 'string', null, true);
		if ($options['name'][0] == '-')
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "Command names may not begin with '-'"
				]);
		processOption($options, 'description', 'string');
		processOption($options, 'notes', 'string');
		if (isset($options['synopsis']) && is_string($options['synopsis']))
			$options['synopsis'] = [$options['synopsis']];
		processOption($options, 'synopsis', 'array');
		if (isset($options['examples']) && is_string($options['examples']))
			$options['examples'] = [$options['examples']];
		processOption($options, 'executor', 'callable');
		processOption($options, 'formatter', 'callable');
		processOption($options, 'helpless', 'boolean', null, false, false);
		processOption($options, 'options', 'array', null, false, []);
		processOption($options, 'subcommands', 'array', null, false, []);
		processOption($options, 'version', 'string');
		processOption($options, 'copyright', 'string');
		processOption($options, 'bugEmail', 'string');
		if (!isset($options['formatter']))
			$options['formatter'] =
				function($command) { return $command->usage(); };
		processOption($options, 'formatter', 'callable');
		foreach ($names as $n => $v)
			if (isset($options[$n]) && $n != 'options' && $n != 'subcommands')
				$this->$n = $options[$n];
		foreach ($options['options'] as $o)
			$this->addOption($o);
		foreach ($options['subcommands'] as $c)
			$this->addSubCommand($c);
	}

						/*
						 * Public accessor methods
						 */
	public final function name() { return $this->name; }
	public final function description() { return $this->description; }
	public final function setDescription($description)
	{
		$this->description = $description;
	}
	public final function notes() { return $this->notes; }
	public final function setNotes($notes)
	{
		$this->notes = $notes;
	}
	public final function synopsis() { return $this->synopsis; }
	public final function addSynopsis($synopsis)
	{
		$this->synopsis[] = $synopsis;
	}
	public final function example() { return $this->examples; }
	public final function addExample($example)
	{
		$this->examples[] = $example;
	}
	public final function executor() { return $this->executor; }
	public final function setExecutor($executor)
	{
		$this->executor = $executor;
	}
	public final function helpless() { return $this->helpless; }
	public final function setHelpless($helpless)
	{
		if ($this->preParsed)
			throw new
				Error([
					'status' => 'STATE_ERROR',
					'message' =>
						'Helplessness may not be modified after a command ' .
						'line has been parsed or after automatic usage ' .
						'information has been generated'
				]);
		$this->helpless = $helpless;
	}
	public final function version() { return $this->version; }
	public final function setVersion($version)
	{
		if ($this->preParsed)
			throw new
				Error([
					'status' => 'STATE_ERROR',
					'message' =>
						'Version may may not be modified after a command ' .
						'line has been parsed or after automatic usage ' .
						'information has been generated'
				]);
		$this->version = $version;
	}
	public final function copyright() { return $this->copyright; }
	public final function setCopyright($copyright)
	{
		$this->copyright = $copyright;
	}
	public final function bugEmail() { return $this->bugEmail; }
	public final function setBugEmail($bugEmail)
	{
		$this->bugEmail = $bugEmail;
	}
	public final function formatter() { return $this->formatter; }
	public final function setFormatter($formatter)
	{
		$this->formatter = $formatter;
	}

						/*
						 * Option management methods
						 */
	public final function options()
	{
		return $this->options;
	}
	public final function hasOption($option)
	{
		return strlen($option) > 1 ?
			isset($this->longForms[$option]) :
			isset($this->shortForms[$option]);
	}
	public final function lookupOption($option)
	{
		switch (strlen($option)) {
		case 0:
			throw new
				Error([
					'status' => 'MISSING_PARAMETER',
					'message' => 'Missing option name'
				]);
		case 1:
			if (!isset($this->shortForms[$option]))
				throw new
					Error([
						'status' => 'OBJECT_DOES_NOT_EXIST',
						'message' => "No such option: -$option"
					]);
			return $this->shortForms[$option];
		default:
			if (!isset($this->longForms[$option]))
				throw new
					Error([
						'status' => 'OBJECT_DOES_NOT_EXIST',
						'message' => "No such option: --$option"
					]);
			return $this->longForms[$option];
		}
	}
	public final function addOption($opt)
	{
		if (is_array($opt))
			$opt = new CommandLineOption($opt);
		validate($opt, 'Makeme\\Util\\CommandLineOption', 'option');
		$long = $short = null;
		if (($long = $opt->longForm()) && isset($this->longForms[$long]))
			throw new
				Error([
					'status' => 'OBJECT_EXISTS',
					'message' => "Duplicate option: --$long"
				]);
		if (($short = $opt->shortForm()) && isset($this->shortForms[$short]))
			throw new
				Error([
					'status' => 'OBJECT_EXISTS',
					'message' => "Duplicate option: -$short"
				]);
		$this->options[] = $opt;
		if ($long)
			$this->longForms[$long] = $opt;
		if ($short)
			$this->shortForms[$short] = $opt;
	}
	public final function addSwitchOption(array $properties)
	{
		$properties['type'] = 'switch';
		$this->addOption($properties);
	}
	public final function addBooleanOption(array $properties)
	{
		$properties['type'] = 'boolean';
		$this->addOption($properties);
	}
	public final function addIntOption(array $properties)
	{
		$properties['type'] = 'int';
		$this->addOption($properties);
	}
	public final function addFloatOption(array $properties)
	{
		$properties['type'] = 'float';
		$this->addOption($properties);
	}

						/*
						 * subcommand management methods
						 */
	final function parentCommand()
	{
		return $this->parent;
	}
	final function subcommands()
	{
		return $this->subcommands;
	}
	final function hasSubcommand($name)
	{
		return isset($this->subcommands[$name]);
	}
	final function lookupSubcommand($name)
	{
		if (!isset($this->subcommands[$name]))
			throw new
				Error([
					'status' => 'OBJECT_DOES_NOT_EXIST',
					'message' => "No such subcommand: $name"
				]);
		return $this->subcommands[$name];
	}
	final function addSubcommand($cmd)
	{
		if (is_array($cmd))
			$cmd = new CommandLine($cmd);
		validate($cmd, 'Makeme\Util\CommandLine', 'sub command');
		$name = $cmd->name();
		if (isset($this->subcommands[$name]))
			throw new
				Error([
					'status' => 'OBJECT_EXISTS',
					'message' => "Duplicate subcommand: $name"
				]);
		$this->subcommands[$name] = $cmd;
		$cmd->parent = $this;
	}

						/*
						 * Methods for managing parsed values
						 */
	public final function hasValue($option)
	{
		$opt = $this->lookupOption($option);
		return $opt->hasValue();
	}
	public final function hasExplicitValue($option)
	{
		$opt = $this->lookupOption($option);
		return $opt->hasExplicitValue();
	}
	public final function getValue($option, $multiple = false)
	{
		$opt = $this->lookupOption($option);
		return $opt->value($multiple);
	}
	public final function setValue($option, $value)
	{
		$opt = $this->lookupOption($option);
		$opt->setValue($value, true);
	}
	public final function values()
	{
		$result = [];
		foreach ($this->options as $opt)
			if ($opt->hasValue())
				$result[$opt->key()] = $opt->value(true);
		return $result;
	}
	public final function activeSwitch()
	{
		return $this->activeSwitch;
	}
	public final function arguments()
	{
		return $this->arguments;
	}
	public final function activeSubcommand()
	{
		return $this->activeSubcommand;
	}

						/*
						 * Methods for parsing and execution
						 */
	public final function parse(...$options)
	{
		switch (count($options)) {
		case 0:
			break;
		case 1:
			if (is_array($options[0])) {
				$options = $options[0];
			} elseif (is_bool($options[0])) {
				$options = ['exitOnError' => $options[0]];
			}
			break;
		case 2:
			$options =
				[
					'exitOnError' => $options[0],
					'argv' => $options[1]
				];
			break;
		default:
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => 'Too many arguments to parse()'
				]);
		}
		if (!isset($options['exitOnError']))
			$options['exitOnError'] = false;
		if (!isset($options['argv'])) {
			$argv = isset($GLOBALS['argv']) ?
				$GLOBALS['argv'] :
				( isset($_SERVER['argv']) ?
					  $_SERVER['argv'] :
					  null );
			if ($argv === null)
				throw new
					Error([
						'status' => 'MISSING_PARAMETER',
						'message' => 'Missing argument vector'
					]);
			$options['argv'] = $argv;
		}
		try {
			$this->parseImpl($options['argv']);
		} catch (Throwable $e) {
			if ($options['exitOnError']) {
				echo $e->message();
				exit(1);
			}
			throw $e;
		}
	}
	public final function execute($options)
	{
		try {
			$this->parse($options);
			$cmd = $this;
			while ($cmd->activeSubcommand !== null)
				$cmd = $cmd->activeSubcommand;
			if ($cmd->activeSwitch !== null) {
				$executor = $cmd->activeSwitch->executor();
				$executor($cmd);
			} elseif ($cmd->executor !== null) {
				$exec = $cmd->executor();
				$exec($cmd);
			} else {
				$cmd->doExecute();
			}
		} catch (Throwable $e) {
			if ($options['exitOnError']) {
				echo $e->message();
				exit(1);
			}
			throw $e;
		}
	}
	public final function clear()
	{
		foreach ($this->options as $opt)
			$opt->setValue($opt->default(), false);
		$this->activeSwitch = null;
		$this->arguments = [];
		$this->activeSubcommand = null;
	}
	public final function usage()
	{
		$this->preParse();
		$sections = [];
		$names = [];
		$cmd = $this;
		do {
			array_unshift($names, $cmd->name);
		} while ($cmd = $cmd->parent);
		$command = join(' ', $names);
		if (!empty($this->synopsis)) {
			$usage = "SYNOPSIS\n";
			foreach ($this->synopsis as $s)
				$usage .= "  $command $s\n";
			$sections[] = $usage;
		}
		if ($this->description !== null) {
			$sections[] =
				"DESCRIPTION\n" .
				wrap($this->description, self::LINE_LENGTH, '  ');
		}
		if (!empty($this->examples)) {
			$usage = "EXAMPLES\n";
			foreach ($this->examples as $e)
				$usage .= "  $command $e\n";
			$sections[] = $usage;
		}
		if ($this->notes !== null) {
			$sections[] =
				"NOTES\n" . wrap($this->notes, self::LINE_LENGTH, '  ');
		}
		if (!empty($this->options)) {
			$usage = "OPTIONS\n";
			$names = [];
			$maxLength = 0;
			foreach ($this->options as $opt) {
				$long = $opt->longForm();
				$short = $opt->shortForm();
				$name = $short ?
					"  -$short, --$long " :
					( sizeof($this->shortForms) ?
						  "      --$long " :
						  "  --$long " );
				$name .= ($ph = $opt->placeholder()) ?
					($opt->valueOptional() ? "[$ph] " : "$ph  ") :
					" ";
				$names[] = $name;
				$maxLength = max($maxLength, strlen($name));
			}
			foreach ($this->options as $opt) {
				$desc = $opt->description() ?
					$opt->description() :
					'no description available';
				$name = str_pad(array_shift($names), $maxLength, ' ');
				$prefixes = [$name, str_repeat(' ', strlen($name))];
				$usage .= wrap($desc, self::LINE_LENGTH, $prefixes);
			}

			$sections[] = $usage;
		}
		if (!empty($this->subcommands)) {
			$usage = "SUBCOMMANDS\n";
			$names = [];
			$maxLength = 0;
			foreach ($this->subcommands as $cmd) {
				$name = '  ' . $cmd->name();
				$names[] = $name;
				$maxLength = max($maxLength, strlen($name));
			}
			foreach ($this->subcommands as $cmd) {
				$desc = $cmd->description() ?
					$cmd->description() :
					'no description available';
				$name = str_pad(array_shift($names), $maxLength + 2, ' ');
				$prefixes = [$name, str_repeat(' ', strlen($name))];
				$usage .= wrap($desc, self::LINE_LENGTH, $prefixes);
			}
			$usage .=
				"\nType `$command help <command>' for help on a specific command";

			$sections[] = $usage;
		}

		if ( $this instanceof CommandLine &&
			 ( $this->bugEmail() !== null || $this->copyright() !== null) )
		{
			$parts = [];
			if ($this->bugEmail() !== null)
				$pages[] = $this->bugEmail();
			if ($this->copyright() !== null)
				$pages[] = $this->copyright();
			$sections[] = join("\n", $parts);
		}

		return join("\n", $sections) . "\n";
	}

						/*
						 * Overridable methods
						 */
	protected function doPreParse()
	{
		if ($this->version !== null) {
			if (!$this->hasOption('version'))
				$this->addOption([
					'longForm' => 'version',
					'shortForm' => 'v',
					'type' => 'switch',
					'label' => 'version',
					'description' => 'Displays the version',
					'executor' => function($cmd) { echo $this->version; }
				]);
			if ( count($this->subcommands) > 0 &&
				 !$this->hasSubcommand('version') )
			{
				$this->addSubcommand([
					'name' => 'version',
					'description' => 'Displays the version',
					'executor' => function($cmd) { echo $this->version; }
				]);
			}
		}
		if (!$this->helpless) {
			if (!$this->hasOption('help'))
				$this->addOption([
					'longForm' => 'help',
					'shortForm' => 'h',
					'type' => 'switch',
					'label' => 'help',
					'description' => 'Displays this help',
					'executor' =>
						function($cmd)
						{
							$formatter = $cmd->formatter();
							echo $formatter($cmd);
						}
				]);
			if (count($this->subcommands) > 0 && !$this->hasSubcommand('help'))
				$this->addSubcommand([
					'name' => 'help',
					'description' => 'Displays this help',
					'executor' =>
						function($cmd)
						{
							$args = $cmd->arguments();
							if (empty($args)) {
								echo $this->usage();
							} elseif ($sub = $this->lookupSubcommand($args[0])) {
								echo $sub->usage();
							}
						}
				]);
		}
	}
	protected function doPostParse() { }
	protected function doExecute() { }

						/*
						 * Private methods
						 */
	private function preParse()
	{
		if (!$this->preParsed) {
			$this->preParsed = true;
			$this->doPreParse();
		}
	}
	private function parseImpl($argv)
	{
		$this->preParse();
		$this->clear();
		$options = [];
		$z = 1;
		$n = sizeof($argv);
		while ($z < $n) {
			$arg = $argv[$z];
			if ($arg == '--') {
				++$z;
				break;

			} elseif ( strlen($arg) > 3 && $arg[0] == '-' && $arg[1] == '-' &&
					   $arg[2] != '-' )
			{
				if (($pos = strpos($arg, '=')) !== false) {
					$opt = $this->lookupOption(substr($arg, 2, $pos - 2));
					$key = $opt->key();
					if (!isset($options[$key]))
						$options[$key] = [];
					$options[$key][] = $pos < strlen($arg) - 1 ?
						substr($arg, $pos + 1) :
						'';
				} else {
					$opt = $this->lookupOption(substr($arg, 2));
					$key = $opt->key();
					if (!isset($options[$key]))
						$options[$key] = [];
					if ($opt->type() == 'switch' || $opt->type() == 'boolean') {
						$options[$key][] = true;
						if ($opt->executor() !== null)
							$this->setActiveSwitch($opt);
					} elseif ($opt->valueOptional()) {
						if ( $z < $n - 1 &&
							 ( strlen($argv[$z + 1]) == 1 ||
							   $argv[$z + 1][0] != '-' ) )
						{
							$options[$key][] = $argv[++$z];
						} else {
							 $options[$key][] = true;
						}
					} elseif ( $z < $n - 1 &&
							   ( strlen($argv[$z + 1]) == 1 ||
								 $argv[$z + 1][0] != '-' ) )
					{
						$options[$key][] = $argv[++$z];
					} else {
						throw new
							Error([
								'status' => 'INVALID_PARAMETER',
								'message' =>
									"The option '$arg' requires an argument"
							]);
					}
				}
			} elseif (strlen($arg) > 1 && $arg[0] == '-') {
				for ($w = 1, $m = strlen($arg); $w < $m; ++$w) {
					$opt = $this->lookupOption($arg[$w]);
					$key = $opt->key();
					if (!isset($options[$key]))
						$options[$key] = [];
					if ($opt->type() == 'switch' || $opt->type() == 'boolean') {
						$options[$key][] = true;
						if ($opt->executor() !== null)
							$this->setActiveSwitch($opt);
					} elseif ($opt->valueOptional()) {
						if ($w < $m - 1) {
							$options[$key][] = substr($arg, $w + 1);
						} elseif ( $z < $n - 1 &&
								   ( strlen($argv[$z + 1]) == 1 ||
									 $argv[$z + 1][0] != '-' ) )
						{
							$options[$key][] = $argv[++$z];
						} else {
							$options[$key][] = true;
						}
						break;
					} elseif ($w < $m - 1) {
						$options[$key][] = substr($arg, $w + 1);
						break;
					} elseif ( $z < $n - 1 &&
							   ( strlen($argv[$z + 1]) <= 1 ||
								 $argv[$z + 1][0] != '-' ) )
					{
						$options[$key][] = $argv[++$z];
						break;
					} else {
						throw new
							Error([
								'status' => 'INVALID_PARAMETER',
								'message' =>
									"The option '$arg' requires an argument"
							]);
					}
				}
			} elseif (isset($this->subcommands[$arg])) {
				$cmd = $this->subcommands[$arg];
				if ($this->activeSwitch !== null)
					throw new
						Error([
							'status' => 'INCONSISTENT_PARAMETERS',
							'message' =>
								"The option $this->activeSwitch cannot be " .
								"used with subcommands"
						]);
				$this->activeSubcommand = $cmd;
				$cmd->parseImpl(array_slice($argv, $z));
				$argv = array();
				break;
			} else {
				break;
			}

			++$z;
		}
		$arguments = array_slice($argv, $z);
		foreach ($options as $key => $values) {
			$opt = $this->lookupOption($key);
			if (!$opt->multiple() && sizeof($values) > 1)
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "The option $opt may occur only once"
					]);
			for ($z = 0, $n = sizeof($values); $z < $n; ++$z) {
				$v = $values[$z];
				if (is_bool($v))
					continue;
				switch ($opt->type()) {
				case 'int':
					if (!is_numeric($v) || intval($v) != floatval($v))
						throw new
							Error([
								'status' => 'INVALID_PARAMETER',
								'message' =>
									"The value of $opt must be an integer; " .
									"'$v' provided"
							]);
					$values[$z] = intval($v);
					break;
				case 'float':
					if (!is_numeric($v))
						throw new
							Error([
								'status' => 'INVALID_PARAMETER',
								'message' =>
									"The value of $opt must be a floating " .
									"point value; '$v' provided"
							]);
					$values[$z] = floatval($v);
					break;
				default:
					break;
				}
			}
			$opt->setValue($opt->multiple() ? $values : $values[0], true);
		}
		foreach ($this->options as $opt) {
			if ($opt->required() && !isset($options[$opt->key()])) {
				$name = $opt->longForm() ?
					'--' . $opt->longForm() :
					'-' . $opt->shortForm();
				throw new
					Error([
						'status' => 'MISSING_PARAMETER',
						'message' => "The option $name is required"
					]);
			}
		}
		$this->arguments = $arguments;

		$this->doPostParse();
	}

	private function setActiveSwitch(CommandLineOption $switch)
	{
		if ($this->activeSwitch !== null) {
			throw new
				Error([
					'status' => 'INCONSISTENT_PARAMETERS',
					'message' =>
						"The options $this->activeSwitch and $switch are " .
						"incompatible"
				]);
		}
		$this->activeSwitch = $switch;
	}
	private $name;
	private $synopsis;
	private $description;
	private $notes;
	private $examples;
	private $executor;
	private $helpless;
	private $version;
	private $copyright;
	private $bugEmail;
	private $formatter;
	private $options = [];
	private $longForms = [];
	private $shortForms = [];
	private $activeSwitch;
	private $parent;
	private $subcommands;
	private $activeSubcommand;
	private $arguments = [];
	private $preParsed = false;
}
final class CommandLineOption {
	function __construct(array $options)
	{
		static $names =
			[
				'longForm' => 1,
				'shortForm' => 1,
				'required' => true,
				'type' => 1,
				'default' => 1,
				'label' => 1,
				'placeholder' => 1,
				'description' => 1,
				'multiple' => 1,
				'valueOptional' => 1,
				'executor' => 1
			];
		foreach ($options as $n => $v)
			if (!isset($names[$n]))
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "Illegal option: $n"
					]);
		processOption($options, 'longForm', 'string');
		processOption($options, 'shortForm', 'string');
		processOption($options, 'required', 'boolean', null, false, false);
		processOption($options, 'type', 'string', null, false, 'string');
		processOption($options, 'default', 'scalar');
		processOption($options, 'label', 'string');
		processOption($options, 'placeholder', 'string');
		processOption($options, 'description', 'string');
		if (isset($options['multiple'])) {
			$multiple = $options['multiple'];
			if ( $multiple !== true && $multiple !== false &&
				 $multiple !== 1 && $multiple !== 0 )
			{
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "Invalid 'multiple' flag: $multiple"
					]);
			}
			$options['multiple'] = (boolean) $options['multiple'];
		}
		processOption($options, 'multiple', 'boolean', null, false, false);
		processOption($options, 'valueOptional', 'boolean', null, false, false);
		processOption($options, 'executor', 'callable');
		if (!isset($options['longForm']) && !isset($options['shortForm']))
			throw new
				Error([
					 'status' => 'MISSING_PARAMETER',
					  'message' => 'Missing longForm or shortForm'
				]);
		if (isset($options['default']) && $options['multiple'])
			throw new
				Error([
					'status' => 'INCONSISTENT_PARAMETERS',
					'message' =>
						'Default value not permitted for option admitting ' .
						'multiple values'
				]);
		if (!isset($options['default']))
			$options['default'] =
				$options['type'] == 'switch' ||
				$options['type'] == 'boolean' ?
					false :
					null;
		if ( $options['valueOptional'] &&
			 ( $options['type'] == 'switch' ||
			   $options['type'] == 'boolean' ||
			   $options['multiple']) )
		{
			throw new
				Error([
					'status' => 'INCONSISTENT_PARAMETERS',
					'message' =>
						'Boolean options or options admitting multiple ' .
						'values may not be specified as value-optional'
				]);
		}
		if ( isset($options['description']) &&
			 !isset($options['placeholder']) )
		{
			if (preg_match('/<<(.+)>>/', $options['description'], $match)) {
				$options['description'] =
					preg_replace(
						'/<<(.+)>>/',
						'$1',
						$options['description']
					);
				$options['placeholder'] = $match[1];
			}
		}
		if ( isset($options['executor']) &&
			 $options['type'] != 'switch' &&
			 $options['type'] != 'boolean' )
		{
			throw new
				Error([
					'status' => 'INCONSISTENT_PARAMETERS',
					'message' =>
						'An executor may be specified only for an option of ' .
						'type switch'
				]);
		}
		if (isset($options['longForm']))
			$this->setLongForm($options['longForm']);
		if (isset($options['shortForm']))
			$this->setShortForm($options['shortForm']);
		$this->required = $options['required'];
		$this->setType($options['type']);
		$this->setDefault($options['default']);
		if ($options['default'] !== null)
			$this->setValue($options['default'], false);
		$this->label = isset($options['label']) ?
			$options['label'] :
			null;
		$this->placeholder = isset($options['placeholder']) ?
			$options['placeholder'] :
			null;
		$this->description = isset($options['description']) ?
			$options['description'] :
			null;
		$this->multiple = $options['multiple'];
		$this->valueOptional = $options['valueOptional'];
		$this->executor = isset($options['executor']) ?
			$options['executor'] :
			null;
	}
	public function longForm()
	{
		return $this->longForm;
	}
	public function shortForm()
	{
		return $this->shortForm;
	}
	public function required()
	{
		return $this->required;
	}
	public function type()
	{
		return $this->type;
	}
	public function default_()
	{
		return $this->default;
	}
	public function label()
	{
		return $this->label;
	}
	public function placeholder()
	{
		return $this->placeholder;
	}
	public function description()
	{
		return $this->description;
	}
	public function multiple()
	{
		return $this->multiple;
	}
	public function valueOptional()
	{
		return $this->valueOptional;
	}
	public function executor()
	{
		return $this->executor;
	}
	public function hasValue()
	{
		return $this->value !== null;
	}
	public function hasExplicitValue()
	{
		return $this->explicit;
	}
	public function value($multiple = false)
	{
		return $this->value === null ?
			( $this->multiple && $multiple ? [] : null ) :
			( $multiple ?
				  $this->value :
				  ( $this->multiple ?
						$this->value[0] :
						$this->value ) );
	}
	public function setValue($value, $explicit = true)
	{
		if ($value !== null) {
			if ($this->multiple != is_array($value)) {
				$value = $this->multiple ?
					'' :
					( is_bool($value) ?
						  ($value ? " 'true'" : " 'false'") :
						  " '$value'" );
				$expected = $this->multiple ? 'an array' : 'a scalar';
				$found = $this->multiple ? 'a scalar' : 'an array';
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' =>
							"Invalid value$value for option $this; expected " .
							"$expected; found $found"
					]);
			}
			if (is_array($value)) {
				foreach ($value as $v)
					$this->testDataType($v);
			} else {
				$this->testDataType($value);
			}
		}
		$this->value = $value;
		$this->explicit = $explicit;
	}
	public function key()
	{
		return $this->longForm ? $this->longForm : $this->shortForm;
	}

	public function __call($method, $args)
	{
		if ($method == 'default')
			return $this->default;
		throw new
			Error([
				'status' => 'UNSUPPORTED_OPERATION',
				'message' =>
					"No such method: Makeme\\Util\\CommandLineOption::$method"
			]);
	}

	public function __toString()
	{
		return $this->longForm ? "--$this->longForm" : "-$this->shortForm";
	}
	private function setLongForm($longForm)
	{
		if ( !is_string($longForm) ||
			 strlen($longForm) < 2 ||
			 $longForm[0] == '-')
		{
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "Illegal long form: $longForm"
				]);
		}
		$this->longForm = $longForm;
	}
	private function setShortForm($shortForm)
	{
		if ( !is_string($shortForm) ||
			 strlen($shortForm) != 1 ||
			 $shortForm == '-' )
		{
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "Illegal short form: $shortForm"
				]);
		}
		$this->shortForm = $shortForm;
	}
	private function setType($type)
	{
		switch ($type) {
		case 'switch':
		case 'boolean':
		case 'int':
		case 'float':
		case 'string':
			break;
		default:
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "Illegal type: $type"
				]);
		}
		$this->type = $type;
	}
	private function setDefault($default)
	{
		if ($this->type == 'switch' || $this->type == 'boolean') {
			if ($default !== false)
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "Illegal default value for option $this"
					]);
		}
		$this->default = $default;
	}
	private function testDataType($value)
	{
		if ($this->valueOptional() && $value == true)
			return;
		switch ($this->type()) {
		case 'switch':
		case 'boolean':
			if (!is_bool($value))
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "The value of $this must be boolean"
					]);
			break;
		case 'int':
			if (!is_int($value))
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "The value of $this must be an integer"
					]);
			break;
		case 'float':
			if (!is_int($value) && !is_float($value))
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' =>
							"The value of $this must be a floating point value"
					]);
			break;
		case 'string':
			if (!is_string($value))
				throw new
					Error([
						'status' => 'INVALID_PARAMETER',
						'message' => "The value of $this must be a string"
					]);
			break;
		default:
			break;
		}
	}
	private $longForm;
	private $shortForm;
	private $required;
	private $type;
	private $default;
	private $label;
	private $placeholder;
	private $description;
	private $multiple;
	private $valueOptional;
	private $executor;
	private $value;
	private $explicit;
}
namespace Makeme\Build;

use Makeme\Error;
use Makeme\Log;
use function Makeme\Text\split;

class CommandLine extends \Makeme\Util\CommandLine {
	const BUILD_ACTIONS = 'install build test clean reset info help';
	const DEFAULT_ACTION = 'build';
	const COMMON_OPTIONS =
		'non-interactive quiet log log-level log-level-console log-level-smtp
		 smtp-to smtp-from smtp-host smtp-port smtp-username smtp-password
		 smtp-ssl';
	const LOG_OPTIONS = 'log log-level log-level-console log-level-smtp';
	const REPO_OPTIONS = 'repo-url repo-branch';
	const SMTP_OPTIONS =
		'smtp-to smtp-from smtp-host smtp-port smtp-username smtp-password
		 smtp-ssl';
	const DB_OPTIONS = 'db-dbms db-host db-username db-password';
	const INSTALL_OPTIONS = 'minimal shared local';
	const CONFIG_OPTIONS = 'config sys-config set unset';
	const TEST_OPTIONS = 'project-url project-branch project-path';
	const LOG_CONSOLE_LEVEL = Log::INFO;
	const LOG_CONSOLE_STREAM = 'stderr';
	const LOG_CONSOLE_FORMAT = 0;
	const LOG_COUNTER_LEVEL = Log::WARNING;
	const LOG_FILE_LEVEL = Log::INFO;
	const LOG_FILE_FORMAT = \Makeme\Log\Entry::ALL_EXCEPT_SESSION;
	const LOG_SMTP_LEVEL = Log::WARNING;
	private $action;
	function __construct()
	{
		parent::__construct(
			'makeme [options] [target ...]',
			'Build or install a CodeRage project'
		);
		$this->addOption([
			'longForm' => 'install',
			'description' => 'installs the CodeRage tools',
			'type' => 'boolean'
		]);
		if (!isBootstrapping()) {
			$this->addOption([
				'longForm' => 'build',
				'description' => 'builds a CodeRage project',
				'type' => 'boolean'
			]);
			$this->addOption([
				'longForm' => 'test',
				'description' =>
					'checks out and builds a temporary CodeRage project',
				'type' => 'boolean'
			]);
			$this->addOption([
				'longForm' => 'clean',
				'description' => 'removes files generated by --build',
				'type' => 'boolean'
			]);
			$this->addOption([
				'longForm' => 'reset',
				'description' =>
					'removes files generated by --build and clears the ' .
					'build history',
				'type' => 'boolean'
			]);
		}
		$this->addOption([
			'shortForm' => 'i',
			'longForm' => 'info',
			'description' =>
				'displays information about a CodeRage project',
			'type' => 'boolean'
		]);
		$this->addOption([
			'longForm' => 'minimal',
			'description' =>
				'used with --install to indicate that only files ' .
				'necessary for bootstrapping future installations should ' .
				'be installed (to <<PATH>>)',
			'valueOptional' => true
		]);
		$this->addOption([
			'longForm' => 'shared',
			'description' =>
				'used with --install to indicate that CodeRage tools ' .
				'should be installed to a shared location (<<PATH>>)',
			'valueOptional' => true
		]);
		$this->addOption([
			'longForm' => 'local',
			'description' =>
				'used with --install to indicate that CodeRage tools ' .
				'should be instaled to the project directory',
			'type' => 'boolean'
		]);
		$this->addOption([
			'longForm' => 'repo-url',
			'description' => '<<URL>> of the CodeRage repository',
		]);
		$this->addOption([
			'longForm' => 'repo-branch',
			'description' => 'Git ref for the CodeRage repository',
		]);
		$this->addOption([
			'longForm' => 'project-url',
			'description' => '<<URL>> of the test project',
		]);
		$this->addOption([
			'longForm' => 'project-branch',
			'description' => 'Git ref for the test project',
		]);
		$this->addOption([
			'longForm' => 'project-path',
			'description' =>
				'path of project build directory within test project',
		]);
		$this->addOption([
			'longForm' => 'config',
			'description' =>
				'a configuration file to use in addition to the ' .
				'project definition file; values in <<PATH>> take ' .
				'precendence over those in the project configuration file'
		]);
		$this->addOption([
			'longForm' => 'sys-config',
			'description' => 'path of the system-wide configuration file',
			'placeholder' => 'PATH'
		]);
		$this->addOption([
			'shortForm' => 's',
			'longForm' => 'set',
			'description' =>
				'assigns the configuration variable NAME the value VALUE',
			'placeholder' => 'NAME=VALUE',
			'multiple' => 1
		]);
		$this->addOption([
			'shortForm' => 'u',
			'longForm' => 'unset',
			'description' =>
				'unsets the configuration variable NAME previously ' .
				'specified on the command line',
			'placeholder' => 'NAME',
			'multiple' => 1
		]);
		$this->addOption([
			'longForm' => 'non-interactive',
			'description' => 'suppresses requests for user input',
			'type' => 'boolean'
		]);
		$this->addOption([
			'shortForm' => 'q',
			'longForm' => 'quiet',
			'description' =>
				'sets the log level for console output to WARNING',
			'type' => 'boolean'
		]);
		$this->addOption([
			'longForm' => 'log',
			'description' => 'specifies the location of the log file',
			'placeholder' => 'PATH'
		]);
		$this->addOption([
			'longForm' => 'log-level',
			'description' =>
				'specifies the log level for the log file; ' .
				'<<LEVEL>> can be one of CRITICAL, ERROR, WARNING, INFO, ' .
				'VERBOSE, or DEBUG; defaults to INFO'
		]);
		$this->addOption([
		   'longForm' => 'log-level-console',
			'description' =>
				'specifies the log level for console output; ' .
				'<<LEVEL>> can be one of CRITICAL, ERROR, WARNING, INFO, ' .
				'VERBOSE, or DEBUG; defaults to INFO'
		]);
		$this->addOption([
		   'longForm' => 'log-level-smtp',
			'description' =>
				'specifies the log level for SMTP logging; ' .
				'<<LEVEL>> can be one of CRITICAL, ERROR, WARNING, INFO, ' .
				'VERBOSE, or DEBUG; defaults to INFO'
		]);
		$this->addOption([
			'longForm' => 'smtp-to',
			'description' => 'sends warnings and errors to <<EMAIL>>'
		]);
		$this->addOption([
			'longForm' => 'smtp-from',
			'description' => 'specifies the From header for SMTP messages',
			'placeholder' => 'EMAIL'
		]);
		$this->addOption([
			'longForm' => 'smtp-host',
			'description' => 'specifies the SMTP server',
			'placeholder' => 'HOST'
		]);
		$this->addOption([
			'longForm' => 'smtp-port',
			'description' => 'specifies the SMTP port',
			'placeholder' => 'PORT'
		]);
		$this->addOption([
			'longForm' => 'smtp-username',
			'description' => 'specifies the SMTP username',
			'placeholder' => 'USER'
		]);
		$this->addOption([
			'longForm' => 'smtp-password',
			'description' => 'specifies the SMTP password',
			'placeholder' => 'PSWD'
		]);
		$this->addOption([
			'longForm' => 'smtp-ssl',
			'description' => 'specifies that SSL should be used',
			'placeholder' => 'yes|no'
		]);
		$this->addOption([
			'longForm' => 'db-dbms',
			'description' => 'specifies the DBMS of the test database',
			'placeholder' => 'DBMS'
		]);
		$this->addOption([
			'longForm' => 'db-host',
			'description' => 'specifies test database server',
			'placeholder' => 'HOST'
		]);
		$this->addOption([
			'longForm' => 'db-username',
			'description' => 'specifies test database username',
			'placeholder' => 'USER'
		]);
		$this->addOption([
			'longForm' => 'db-password',
			'description' => 'specifies test database password',
			'placeholder' => 'PASS'
		]);
	}
	function action()
	{
		if ($this->action === null)
			throw new Error("No build action has been set");
		return $this->action;
	}
	function setAction()
	{
		$action = null;
		$options = split(self::BUILD_ACTIONS);
		foreach ($options as $opt) {
			if ($this->hasOption($opt) && $this->getValue($opt)) {
				if ($action !== null) {
					throw new
						Error(
							'At most one of the options ' .
							$this->printOptions($options) . ' may be specified'
						);
				}
				$action = $opt;
				break;
			}
		}
		if (!$action)
			$action = isBootstrapping() ? 'install' : 'build';
		$this->action = loadAction($action);
	}
	function createLog($projectRoot)
	{
		$log = new Log;
		$log->setTag('Build');
		$level = null;
		if ($this->getValue('quiet')) {
			if ($this->hasValue('log-level-console')) {
				$value = $this->getValue('log-level-console');
				if (Log::translateLevel($value) != Log::ERROR)
					throw new
						Error(
							"The option --quiet is incomatible with the " .
							"option --log-level-console $value"
						);
			}
			$level = Log::ERROR;
		} elseif ($this->hasValue('log-level-console')) {
			$level =
				Log::translateLevel
					($this->getValue('log-level-console')
				);
		} else {
			$level = self::LOG_CONSOLE_LEVEL;
		}
		$console =
			new \Makeme\Log\Provider\Console([
					'stream' => self::LOG_CONSOLE_STREAM,
					'format' => self::LOG_CONSOLE_FORMAT
				]);
		$log->registerProvider($console, $level);
		$counter = new \Makeme\Log\Provider\Counter;
		$log->registerProvider($counter, self::LOG_COUNTER_LEVEL);
		$file = $this->getValue('log');
		if ($file !== null) {
			$path = \Makeme\File\isAbsolute($file) ?
				$file :
				"$projectRoot/$file";
			$file =
				new \Makeme\Log\Provider\PrivateFile([
						'path' => $file,
						'format' => self::LOG_FILE_FORMAT
					]);
			$level = $this->getValue('log-level') !== null ?
				Log::translateLevel($this->getValue('log-level')) :
				self::LOG_FILE_LEVEL;
			$log->registerProvider($file, $level);
		}
		$options = split(CommandLine::SMTP_OPTIONS);
		if ($this->getValue('smtp-to') !== null) {
			$values = [];
			foreach ($options as $opt) {
				$value = $this->getValue($opt);
				if ($value !== null)
					$values[substr($opt, 5)] = $value;
			}
			$smtp = new \Makeme\Log\Provider\Smtp($values);
			$level = $this->hasValue('log-level-smtp') ?
				Log::translateLevel($this->getValue('log-level-smtp')) :
				self::LOG_SMTP_LEVEL;
			$log->registerProvider($smtp, $level);
		} else {
			foreach ($options as $opt)
				if ($this->getValue($opt) !== null)
					throw new
						Error(
							"Option --$opt requires option --smtp-to"
						);
		}

		return $log;
	}
	protected function doPostParse()
	{
		$values = $this->values();
		if (isset($values['smtp-username']) && !isset($values['smtp-password']))
			throw new Error('Missing option --smtp-password');
		if (isset($values['smtp-to']) && !isset($values['smtp-from']))
			$this->lookupOption('smtp-from')
				->setValue('no-reply@localhost.localdomain');
	}
	static function printOptions($options)
	{
		switch (sizeof($options)) {
		case 0:
			throw new Error("No options specified");
		case 1:
			return "--{$options[0]}";
		case 2:
			return "--{$options[0]} and --{$options[1]}";
		default:
			$result = '';
			for ($z = 0, $n = sizeof($options); $z < $n; ++$z) {
				$result .= "--{$options[$z]}";
				if ($z < $n - 2)
					$result .= ', ';
				if ($z == $n - 2)
					$result .= 'and ';
			}
			return $result;
		}
	}
}
namespace Makeme\Text;
function wrap($text, $lineLength, $prefixes = [])
{
	if (is_string($prefixes))
		$prefixes = [$prefixes];
	if (sizeof($prefixes) == 0)
		$prefixes = [''];
	$text = preg_replace('/\s+/', ' ', trim($text));

	$line = 0;
	$result = '';
	while (true) {
		$prefix = $line < sizeof($prefixes) ?
			$prefixes[$line] :
			$prefixes[sizeof($prefixes) - 1];
		$text = $prefix . $text;
		$length = strlen($text);
		if ($length <= $lineLength) {
			$result .= "$text\n";
			break;
		}
		$sp = strrpos($text, ' ', -($length - $lineLength));
		$hasSpace = $sp !== false && $sp > strlen($prefix);
		$br = $hasSpace ? $sp : $lineLength;
		++$line;
		$result .= substr($text, 0, $br) . "\n";
		$text = substr($text, $hasSpace ? $br  + 1: $br);
	}
	return $result;
}
namespace Makeme\Log\Provider;

use Makeme\Config;
use Makeme\Error;
use Makeme\Log;
use Makeme\Log\Entry;
use function Makeme\Util\processOption;
use function Makeme\Util\validate;

final class Smtp implements \Makeme\Log\IProvider {
	const DEFAULT_MAX_PER_SESSION = 1;
	function __construct($options)
	{
		processOption($options, 'engine', 'string', [
			'label' => 'SMTP engine class name',
			'default' => null
		]);
		processOption($options, 'params', 'string', [
			'label' => 'SMTP engine parameters',
			'default' => null
		]);
		if (isset($options['params'])) {
			$handler = new \Makeme\Util\ErrorHandler;
			$result = $handler->_json_decode($options['params']);
			$error = 'Failed decoding SMTP engine parameters';
			if ($handler->errno())
				throw new Error(['message' => $handler->formatError($error)]);
			if ($result === null && trim($options['params']) != 'null')
				throw new Error(['message' => $error]);
			validate($result, 'stdClass', 'SMTP engine parameters');
			$options['params'] = (array) $result;
		}
		processOption($options, 'from', 'string', [
			'label' => 'sender address'
		]);
		processOption($options, 'to', 'string', [
			'label' => 'receipient addresses'
		]);
		if (isset($options['maxPerSession'])) {
			$max = $options['maxPerSession'];
			if (is_string($max)) {
				if (!preg_match('/^(0|-?[1-9][0-9]*)$/', $max))
					throw new
						Error([
							'status' => 'INVALID_PARAMETER',
							'message' =>
								"Invalid 'maxPerSession' option: expected " .
								"integer; found $max"
						]);
				$options['maxPerSession'] = (int) $max;
			}
			processOption($options, 'maxPerSession', 'int', [
				'label' => "'maxPerSession' option"
			]);
			if ($max == -1)
				$options['maxPerSession'] = INF;
		} else {
			$options['maxPerSession'] = self::DEFAULT_MAX_PER_SESSION;
		}
		processOption($options, 'ignore', 'string', [
			'label' => "'ignore' option"
		]);
		if (isset($options['ignore'])) {
			$codes = [];
			foreach (\Makeme\Text\split($options['ignore'], '/\s*,\s*/') as $code)
				$codes[$code] = 1;
			$options['ignore'] = $codes;
		}
		$config = class_exists('Makeme\Config') ?
			Config::current() :
			null;
		if (!isset($options['to'])) {
			if ($config === null || !$config->hasProperty('error_email'))
				throw new
					Error([
						'status' => 'MISSING_PARAMETER',
						'message' => 'Missing email recipient'
					]);
			$options['to'] = $config->getRequiredProperty('error_email');
		}
		if (!isset($options['from'])) {
			$domain = $config !== null ?
				$config->getProperty('site_domain', 'localhost.localdomain') :
				'localhost.localdomain';
			$options['from'] = "no-reply@$domain";
		}

		$this->options = $options;
		$this->count = 0;
	}

	function name() { return 'smtp'; }
	public function dispatchEntry(Entry $entry)
	{
		if (++$this->count > $this->options['maxPerSession'])
			return;
		if ($this->ignoreError($entry))
			return;
		$timestamp = $entry::formatTimestamp($entry->timestamp());
		$config = class_exists('Makeme\\Config') ?
			Config::current() :
			null;
		$subject = $config !== null && $config->hasProperty('project.label') ?
			'[' . $config->getProperty('project.label') . '] ' :
			'';
		foreach ($entry->tags() as $t)
			$subject .= "[$t]";
		$subject .= ' ';
		$level = $entry->level();
		switch ($level) {
		case Log::ERROR:
			$subject .= 'Error';
			break;
		case Log::WARNING:
			$subject .= 'Warning';
			break;
		default:
			$subject .=
				'Message (Level: ' . Log::translateLevel($level) . ')';
			break;
		}
		$subject .= " ($timestamp)";
		$file = $entry->file() !== null ? $entry->file() : '?';
		$line = $entry->line() !== null ? $entry->line() : '?';
		$sessionId = $entry->sessionId();
		$tags = join(', ', $entry->tags());
		$dbLink = null;
		if ($config !== null) {
			$url =
				($config->getProperty('ssl', false) ? 'https://' : 'http://') .
				$config->getProperty('site_domain', 'localhost.localdomain') .
					'/CodeRage/Log/view.php' . '?session=' . $sessionId;
			$dbLink =
				"\nIf database logging is enabled, you may view this log " .
				"sessionat $url";
		}
		$format = Entry::ALL;
		$body =
			"Time:     $timestamp\n" .
			"Level:    " . Log::translateLevel($level) . "\n" .
			"File:     $file\n" .
			"Line:     $line\n" .
			"Session:  $sessionId\n" .
			"Tags:     $tags\n\n" .
			Entry::formatMessage($entry->message(), $format) . "\n" .
			$dbLink;
		$this->smtp()->send([
			'from' => $this->options['from'],
			'to' => $this->options['to'],
			'subject' => $subject,
			'text' => $body
		]);
	}
	public function ignoreError(Entry $entry)
	{
		return $entry->message() instanceof Error &&
			   isset($this->options['ignore']) &&
			   isset($this->options['ignore'][$entry->message()->status()]);
	}
	private function smtp()
	{
		if ($this->smtp === null)
			$this->smtp =
				new \Makeme\Util\Smtp([
						'engine' => $this->options['engine'],
						'params' => $this->options['params'],
					]);
		return $this->smtp;
	}
	private $options;
	private $count;
	private $smtp;
}
namespace Makeme\Util;

use Makeme\Error;
final class Smtp {
	const DEFAULT_ENGINE = 'CodeRage.Util.Smtp.Legacy';
	function __construct($options = [])
	{
		$engine = null;
		if (!isset($options['engine'])) {
			if (isset($options['params']))
				throw new
					Error([
						'status' => 'INCONSISTENT_PARAMETERS',
						'details' =>
							'SMTP engine parameters maynot be specified ' .
							'without SMTP engine class name'
					]);
			$engine = self::DEFAULT_ENGINE;
		} else {
			processOption($options, 'engine', 'string', [
				'label' => 'SMTP engine class name'
			]);
			$engine = $options['engine'];
		}
		processOption($options, 'params', 'array', [
			'label' => 'SMTP engine parameters',
			'default' => []
		]);
		if (!empty($options['params']) && isIndexed($options['params']))
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'details' =>
						'Invalid SMTP engine parameters: expected ' .
						'associative array; found indexed array'
				]);
		foreach ($options['params'] as $v)
			validate($v, 'string', 'SMTP engine parameter value');
		$this->engine =
			\Makeme\Util\loadComponent([
			   'class' => $engine,
			   'params' => $options['params']
			]);
	}
	public final function send($options)
	{
		processOption($options, 'from', 'string', [
			'label' => 'sender address',
			'required' => true
		]);
		processOption($options, 'to', 'string', [
			'label' => 'receipient addresses',
			'required' => true
		]);
		processOption($options, 'cc', 'string', [
			'label' => 'CC addresses'
		]);
		processOption($options, 'bcc', 'string', [
			'label' => 'BCC addresses'
		]);
		processOption($options, 'subject', 'string', [
			'label' => 'subject header',
			'required' => true
		]);
		processOption($options, 'text', 'string', [
			'label' => 'text body'
		]);
		processOption($options, 'html', 'string', [
			'label' => 'HTML body'
		]);
		processOption($options, 'attachments', 'array', [
			'label' => 'attachments'
		]);
		processOption($options, 'inlines', 'array', [
			'label' => 'inline attachments'
		]);
		foreach (['attachments', 'inlines'] as $opt) {
			if (!isset($options[$opt]))
				continue;
			foreach ($options[$opt] as $att) {
				processOption($att, 'filename', 'string', [
					'label' => "email $opt name",
					'required' => true
				]);
				processOption($att, 'contentType', 'string', [
					'label' => "email $opt content type",
					'required' => true
				]);
				processOption($att, 'path', 'string', [
					'label' => "email $opt path",
					'required' => true
				]);
				\Makeme\File\checkReadable($att['path']);
			}
		}
		$this->engine->send($options);
	}
	private $engine;
}
interface SmtpEngine {
	public function send($options);
}
namespace Makeme\Log\Provider;

use Makeme\Log\Entry;

abstract class FileHandle implements \Makeme\Log\IProvider {
	public function __construct($options)
	{
		if (!isset($options['file']))
			throw new
				\Makeme\Error([
					'status' => 'MISSING_PARAMETER',
					'message' => 'Missing file pointer'
				]);
		$this->file = $options['file'];
		$this->format = isset($options['format']) ?
			$options['format'] :
			Entry::ALL;
	}

	public function __destruct() { @fclose($this->file); }
	public function dispatchEntry(Entry $entry)
	{
		fwrite($this->file, $entry->formatEntry($this->format));
	}
	private $file;
	private $format;
}
namespace Makeme\Log\Provider;

use Makeme\Error;

final class PrivateFile extends FileHandle {
	public function __construct($options)
	{
		if (!isset($options['path']))
			throw new
				Error([
					'status' => 'MISSING_PARAMETER',
					'message' => 'Missing file pathname'
				]);
		$dir = dirname($options['path']);
		if (!file_exists($dir))
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "No such directory: $dir"
				]);
		if (!is_dir($dir))
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "The file '$dir' is not a directory"
				]);
		$handler = new \Makeme\Util\ErrorHandler;
		$file = $handler->_fopen($options['path'], 'w');
		if ($file === false)
			throw new
				Error([
					'status' => 'FILESYSTEM_ERROR',
					'message' => $handler->formatError()
				]);
		parent::__construct([
			'file' => $file,
			'format' => isset($options['format']) ?
				$options['format'] :
				null
		]);
	}
	public function name() { return 'private_file'; }
}
namespace Makeme\Log\Provider;

use Makeme\Error;

final class Console extends FileHandle {
	public function __construct($options)
	{
		if (!isset($options['stream']))
			throw new
				Error([
					'status' => 'MISSING_PARAMETER',
					'message' => 'Missing stream type'
				]);
		if ($options['stream'] != 'stdout' && $options['stream'] != 'stderr')
			throw new
				Error([
					'status' => 'INVALID_PARAMETER',
					'message' => "Invalid stream type: {$options['stream']}"
				]);
		parent::__construct([
			'file' => $options['stream'] == 'stdout' ?
				fopen('php://stdout', 'w') :
				fopen('php://stderr', 'w'),
			'format' => isset($options['format']) ?
				$options['format'] :
				0
		]);
	}
	public function name() { return 'console'; }
}
namespace Makeme\Build;
function loadAction($name)
{
	$file = 'CodeRage/Build/Action/' . ucfirst($name) . '.php';
	if ($search = \Makeme\File\searchIncludePath($file))
		require_once($search);
	$class = 'Makeme\\Build\\Action\\' . ucfirst($name);
	if (!class_exists($class))
		throw new \Makeme\Error("Invalid build action: $name; no class $class");
	return new $class;
}
interface Action {
	function name();
	function checkCommandLine(Run $run);
	function requiresProjectConfig(Run $run);
	function execute(Run $run);
}
namespace Makeme\Build\Action;

use Throwable;
use Makeme\Build\CommandLine;
use Makeme\Build\Resource_;
use Makeme\Build\Run;
use function Makeme\Build\Git\clone_;
use Makeme\Error;
use function Makeme\File\mkdir;
use Makeme\Log;
use function Makeme\Text\split;
use function Makeme\Util\os;
use const Makeme\VERSION;

class Install implements \Makeme\Build\Action {
	const BINARY_FILE_PERMISSIONS = 0755;
	const BINARY_DIRECTORY_PERMISSIONS = 0755;
	const LIBRARY_FILE_PERMISSIONS = 0644;
	const LIBRARY_DIRECTORY_PERMISSIONS = 0755;
	private $type;
	private $path;
	private $handler;
	function __construct()
	{
		$this->handler = new \Makeme\Util\ErrorHandler;
	}
	function name() { return 'install'; }
	function checkCommandLine(Run $run)
	{
		$commandLine = $run->commandLine();
		if (sizeof($commandLine->arguments()))
			throw new Error(
						  "Targets cannot be specified with the option " .
						  "--install"
					  );
		$common = split(CommandLine::COMMON_OPTIONS);
		$repo = split(CommandLine::REPO_OPTIONS);
		$install = split(CommandLine::INSTALL_OPTIONS);
		$options = array_merge($common, $repo, $install);
		foreach ($commandLine->options() as $opt) {
			if ($opt->hasExplicitValue()) {
				$long = $opt->longForm();
				if ($long != 'install' && !in_array($long, $options))
					throw new
						Error(
							"The option --$long cannot be combined with " .
							"the option --install"
						);
			}
		}
		if ($str = $run->getStream(Log::DEBUG))
			$str->write("Determining installation type");
		foreach ($install as $opt) {
			if ($str = $run->getStream(Log::DEBUG))
				$str->write("Checking for option '$opt'");
			if ($commandLine->hasExplicitValue($opt)) {
				if ($this->type) {
					throw new
						Error(
							'At most one of the options ' .
							CommandLine::printOptions($install) .
							' may be specified'
						);
				}
				if ($str = $run->getStream(Log::DEBUG))
					$str->write("Found option '$opt'");
				$this->type = $commandLine->lookupOption($opt)->longForm();
				if (is_string($path = $commandLine->getValue($opt)))
					$this->path = $path . '/CodeRage-' . VERSION;
			}
		}
		if (!$this->type)
			$this->type = 'shared';
		if ($str = $run->getStream(Log::VERBOSE))
			$str->write("Build type is '$this->type'");
	}
	function requiresProjectConfig(Run $run)
	{
		return false;
	}
	function execute(Run $run)
	{
		switch ($this->type) {
		case 'minimal':
			$this->installMinimal($run);
			break;
		case 'local':
			$this->installLocal($run);
			break;
		case 'shared':
		default:
			$this->installShared($run);
			break;
		}
	}
	private function installMinimal(Run $run)
	{
		if ($str = $run->getStream(Log::INFO))
			$str->write("Performing minimal installation");
		$path = $this->path ?
			$this->path :
			self::defaultInstallPath($run);
		self::checkForTools($run);
		self::checkForBootstrapFiles($run);
		if (file_exists($path)) {
			$file = is_dir($path) ? 'directory' : 'file';
			throw new
				Error(
					"The $file '$path' exists; please move it out of the way"
				);
		}
		$this->installBootstrapFiles($run, $path);
	}
	private function installShared(Run $run)
	{
		if ($str = $run->getStream(Log::INFO))
			$str->write("Performing shared installation");
		$path = $this->path ?
			$this->path :
			self::defaultInstallPath($run);
		self::checkForTools($run);
		$config = $run->buildConfig();
		if ($bootstrapPath = $config->bootstrapPath()) {
			$message =
				self::filesInstalledError(
					$bootstrapPath, $config->bootstrapVersion(),
					'bootstrap files'
				);
			throw new Error($message);
		}
		if (!$bootstrapPath)
			$this->installBootstrapFiles($run, $path);
		if ($str = $run->getStream(Log::INFO))
			$str->write("Checking out CodeRage Tools ...");
		$sep = os() == 'windows' ? '\\' : '/';
		clone_(
			$run,
			$this->toolsUrl($run),
			"$path{$sep}CodeRage",
			$this->toolsBranch($run)
		);
		$run->buildConfig()->setToolsPath($path);
	}
	private function installLocal(Run $run)
	{
		if ($str = $run->getStream(Log::INFO))
			$str->write("Performing local installation");
		$config = $run->buildConfig();
		$path = $config->bootstrapPath();
		if (!$path)
			throw new
				Error(
					"CodeRage bootstrap files are not installed; run " .
					"'makeme --install --minimall' to install"
				);
		$proj = $config->projectConfigFile();
		if (!$proj)
			throw new Error("No project definition file found");
		if ($str = $run->getStream(Log::INFO))
			$str->write("Checking out CodeRage Tools ...");
		$sep = os() == 'windows' ? '\\' : '/';
		$target = dirname($proj->path()) . $sep . 'CodeRage';
		clone_(
			$run,
			$this->toolsUrl($run),
			$target,
			$this->toolsBranch($run)
		);
		$run->buildConfig()->setToolsPath(dirname($proj->path()));
	}
	private function checkForBootstrapFiles(Run $run)
	{
		if ($str = $run->getStream(Log::VERBOSE))
			$str->write("Checking for bootstrap files");
		$config = $run->buildConfig();
		$path = $config->bootstrapPath();
		if ($path !== null) {
			$message =
				self::filesInstalledError(
					$path, $config->bootstrapVersion(), 'bootstrap files'
				);
			throw new Error($message);
		}
	}
	private static function checkForTools(Run $run)
	{
		if ($str = $run->getStream(Log::VERBOSE))
			$str->write("Checking for CodeRage tools");
		$config = $run->buildConfig();
		$path = $config->toolsPath();
		if ($path !== null) {
			$message =
				self::filesInstalledError(
					$path, $config->toolsVersion(), 'tools'
				);
			throw new Error($message);
		}
	}
	private static function filesInstalledError($path, $version, $label)
	{
		$cmp = version_compare($version, VERSION);
		switch ($cmp) {
		case -1:
			return
				"Version $version of CodeRage $label are already " .
				"installed, at '$path'; run makeme --update to update";
		case 0:
			return
				"CodeRage $label already are already installed, at '$path'";
		case 1:
		default:
			return
				"A more recent version of CodeRage $label are already " .
				"installed, at '$path'";
		}
	}
	private function installBootstrapFiles(Run $run, $path)
	{
		if ($str = $run->getStream(Log::INFO))
			$str->write("Installing bootstrap files");
		mkdir($path, self::BINARY_FILE_PERMISSIONS);
		mkdir("$path/Bin", self::BINARY_FILE_PERMISSIONS);
		$os = os();
		$resources = Resource_::listFiles($run);
		$libraries = [];
		$tools = [];
		foreach ($resources as $file) {
			if (preg_match('/^CodeRage(-|$)/', pathinfo($file, PATHINFO_FILENAME))) {
				$libraries[] = $file;
			} else {
				$ext = pathinfo($file, PATHINFO_EXTENSION);
				if ( $ext == 'php' || $ext == 'pl' ||
					 ($os == 'windows' && $ext == 'bat') ||
					 ($os == 'posix' && $ext == '') )
				{
					$tools[] = $file;
				}
			}
		}
		$managers = $run->loadPackageManagers();
		$found = false;
		foreach ($libraries as $file) {
			$src = Resource_::loadFile($run, $file);
			$dest = "$path/$file";
			if (!$this->handler->callUserFunction('copy', $src, $dest))
				if ($str = $run->getStream(Log::ERROR))
					$str->write(
						$this->handler->formatError(
							"Failed copying library file '$file' to '$path'"
						)
					);
			$mode = self::LIBRARY_FILE_PERMISSIONS;
			if (!$this->handler->callUserFunction('chmod', $dest, $mode))
				if ($str = $run->getStream(Log::ERROR))
					$str->write(
						$this->handler->formatError(
							"Failed setting permissions of file '$dest'"
						)
					);
			$content = \Makeme\File\getContents($dest);
			$content = str_replace('__TOOLS_ROOT__', realpath($path), $content);
			file_put_contents($dest, $content);
			$ext = pathinfo($file, PATHINFO_EXTENSION);
			$found = false;
			foreach ($managers as $man) {
				  if ($man->libraryFileExtension() == $ext) {
					  $found = true;
					  $configs = $man->lookupConfigurations();
					  foreach ($configs as $con) {
						  try {
							$con->addToLibrarySearchPath($path);
						  } catch (Throwable $ignore) {
							  try {
								$con->installLocalPackage([$dest], true);
							  } catch (Throwable $e) {
								  if ($str = $run->getStream(Log::WARNING)) {
										$framework = $man->name();
										$id = $con->configurationId();
										$str->write(
										   "Failed adding file '$path' to " .
										   "library search path for framework " .
										   "'$framework' ($id)"
														);
									$str->write(
									   "Failed installing file '$file' " .
									   "as a local package in framework " .
									   "'$framework' ($id): " .
										$e->getMessage()
									);
								  }
							  }
						  }
					  }
				  }
			}
		}
		if (!$found) {
			if ($str = $run->getStream(Log::ERROR))
				$str->write("No package manager found for extension '$ext'");
		}
		foreach ($tools as $file) {
			$src = Resource_::loadFile($run, $file);
			$dest = "$path/Bin/$file";
			if (!$this->handler->callUserFunction('copy', $src, $dest))
				if ($str = $run->getStream(Log::ERROR))
					$str->write(
						$this->handler->formatError(
							"Failed copying tool '$file' to '$path'"
						)
					);
			$mode = self::BINARY_FILE_PERMISSIONS;
			if (!$this->handler->callUserFunction('chmod', $dest, $mode))
				if ($str = $run->getStream(Log::ERROR))
					$str->write(
						$this->handler->formatError(
							"Failed setting permissions of file '$dest'"
						)
					);
		}
		$src = __FILE__;
		$dest = "$path/Bin/makeme.php";
		if (!$this->handler->callUserFunction('copy', $src, $dest))
			if ($str = $run->getStream(Log::ERROR))
				$str->write(
					$this->handler->formatError(
						"Failed copying tool '$file' to '$path'"
					)
				);
		$mode = self::BINARY_FILE_PERMISSIONS;
		if (!$this->handler->callUserFunction('chmod', $dest, $mode))
			if ($str = $run->getStream(Log::ERROR))
				$str->write(
					$this->handler->formatError(
						"Failed setting permissions of file '$dest'"
					)
				);
		$nl = $os == 'windows' ? "\r\n" : "\n";
		$now = time();
		$date = date(\Makeme\Build\BuildConfig::DATE_FORMAT, $now);
		$year = date('Y', $now);
		$version = VERSION;
		$content =
			"#################################################$nl" .
			"#$nl" .
			"# CodeRage Bootstrap Files$nl" .
			"#$nl" .
			"# Date:          $date$nl" .
			"# Version:       $version$nl" .
			"# Copyright:     $year CodeRage$nl" .
			"# License:       All rights reserved$nl" .
			"#$nl" .
			"#################################################$nl";
		if ( !$this->handler->callUserFunction(
				 'file_put_contents',
				 "$path/README",
				 $content) )
		{
			if ($str = $run->getStream(Log::ERROR))
				$str->write(
					$this->handler->formatError(
						"Failed generating README in directory '$path'"
					)
				);
		}
		$files = [];
		foreach ($tools as $t)
			$files[] = "$path/Bin/$t";
		\Makeme\Build\addToPath($files);
	}
	private function defaultInstallPath(Run $run)
	{
		$base = 'CodeRage-' . VERSION;
		return os() == 'windows' ?
			getenv('PROGRAMFILES') . "\\$base" :
			"/usr/share/$base";
	}
	private function toolsUrl(Run $run)
	{
		$config = $run->buildconfig();
		return $config->repositoryUrl() ?
			$config->repositoryUrl() :
			\Makeme\Build\REPO_URL;
	}
	private function toolsBranch(Run $run)
	{
		$config = $run->buildconfig();
		return $config->repositoryBranch() ?
			$config->repositoryBranch() :
			\Makeme\Build\REPO_BRANCH;
	}
}
namespace Makeme;

const VERSION = '3.0';
namespace Makeme\Build\git;

use Makeme\Error;
use function Makeme\Util\escapeShellArg;

function clone_(\Makeme\Build\Run $run, $url, $path, $branch = null,
	$export = false)
{
	if (!\Makeme\File\isAbsolute($path))
		throw new
			Error([
				'status' => 'INVALID_PARAMETER',
				'message' => "Expected absolute path; found $path"
			]);
	$escUrl = escapeShellArg($url);
	$escPath = escapeShellArg($path);
	\Makeme\Util\system("git clone $escUrl $escPath");
	if ($branch !== null) {
		$cwd = getcwd();
		try {
			chdir($path);
			\Makeme\Util\system('git checkout ' . escapeShellArg($branch));
		} catch (\Throwable $e) {
			\Makeme\File\rm($path);
		} finally {
			chdir($cwd);
		}
	}
}
namespace Makeme\File;
function rm($path)
{
	if (is_file($path) || is_link($path)) {
		return  @unlink($path) ? true : !file_exists($path);
	} elseif (is_dir($path)) {
		if ($dir = dir($path)) {
			while (false !== ($file = $dir->read()))
				if ($file != '.' && $file != '..')
					rm("$path/$file");
			$dir->close();
		}
		return @rmdir($path) ? true : !file_exists($path);
	} else {
		return true;
	}
}
namespace Makeme\Build;

use Exception;
use Throwable;
use Makeme\Error;
use function Makeme\Text\split;
use function Makeme\Util\printScalar;

class BuildConfig {
	const BOOTSTRAP_FILES =
		'Bin CodeRage.php CodeRage-3.0.php CodeRage.pm README';
	const TOOLS_FILES = 'CodeRage/Build CodeRage/Util CodeRage/project.xml';
	const CONFIG_FILE_ENV_VARIABLE = 'CODERAGE_CONFIG';
	const CONFIG_FILE_DIRECTORY_UNIX = '/etc';
	const SYSTEM_CONFIG_FILES = 'coderage.xml coderage.ini site-config.php';
	const CONFIG_FILES = 'project.xml project.ini';
	const DATE_FORMAT = 'D M j, H:m:s T Y';
	private $timestamp;
	private $action;
	private $status;
	private $bootstrapPath;
	private $bootstrapVersion;
	private $toolsPath;
	private $toolsVersion;
	private $systemConfigFile;
	private $projectConfigFile;
	private $additionalConfigFiles;
	private $repositoryType;
	private $repositoryUrl;
	private $repositoryBranch;
	private $commandLineProperties;
	private $environmentProperties;
	private $projectInfo;
	public function __construct(
				$timestamp, $action, $status, $bootstrapPath, $bootstrapVersion,
				$toolsPath, $toolsVersion, $systemConfigFile,
				$projectConfigFile, $additionalConfigFiles, $repositoryType,
				$repositoryUrl, $repositoryBranch, $commandLineProperties,
				$environmentProperties, $projectInfo)
	{
		$this->timestamp = $timestamp;
		$this->action = $action;
		$this->status = $status;
		$this->bootstrapPath = $bootstrapPath;
		$this->bootstrapVersion = $bootstrapVersion;
		$this->toolsPath = $toolsPath;
		$this->toolsVersion = $toolsVersion;
		$this->systemConfigFile = is_array($systemConfigFile) ?
			new BuildConfigFile(
					$systemConfigFile[0],
					$systemConfigFile[1]
				) :
			$systemConfigFile;
		$this->projectConfigFile = is_array($projectConfigFile) ?
			new BuildConfigFile(
					$projectConfigFile[0],
					$projectConfigFile[1]
				) :
			$projectConfigFile;
		$files = [];
		foreach ($additionalConfigFiles as $f)
			$files[] = is_array($f) ?
				new BuildConfigFile($f[0], $f[1]) :
				$f;
		$this->additionalConfigFiles = $files;
		$this->repositoryType = $repositoryType;
		$this->repositoryUrl = $repositoryUrl;
		$this->repositoryBranch = $repositoryBranch;
		$this->commandLineProperties = $commandLineProperties;
		$this->environmentProperties = $environmentProperties;
		$this->projectInfo = $projectInfo;
	}
	function timestamp()
	{
		return $this->timestamp;
	}
	function action()
	{
		return $this->action;
	}
	function setAction($action)
	{
		$this->action = $action;
	}
	function status()
	{
		return $this->status;
	}
	function setStatus($status)
	{
		$this->status = $status;
	}
	function bootstrapPath()
	{
		return $this->bootstrapPath;
	}
	function setBootstrapPath($bootstrapPath)
	{
		$this->bootstrapPath = $bootstrapPath;
	}
	function bootstrapVersion()
	{
		return $this->bootstrapVersion;
	}
	function toolsPath()
	{
		return $this->toolsPath;
	}
	function toolsVersion()
	{
		return $this->toolsVersion;
	}
	function setToolsPath($toolsPath)
	{
		$this->toolsPath = $toolsPath;
	}
	function systemConfigFile()
	{
		return $this->systemConfigFile;
	}
	function setSystemConfigFile(BuildConfigFile $systemConfigFile)
	{
		$this->systemConfigFile = $systemConfigFile;
	}
	function projectConfigFile()
	{
		return $this->projectConfigFile;
	}
	function setProjectConfigFile(BuildConfigFile $projectConfigFile)
	{
		$this->projectConfigFile = $projectConfigFile;
	}
	function additionalConfigFiles()
	{
		return $this->additionalConfigFiles;
	}
	function setAdditionalConfigFiles($additionalConfigFiles)
	{
		$this->additionalConfigFiles = $additionalConfigFiles;
	}
	function inheritConfigFiles(BuildConfig $config)
	{
		if (!$this->systemConfigFile)
			$this->systemConfigFile = $config->systemConfigFile;
		if (!sizeof($this->additionalConfigFiles))
			$this->additionalConfigFiles = $config->additionalConfigFiles;
	}
	function repositoryType()
	{
		return $this->repositoryType;
	}
	function setRepositoryType($repositoryType)
	{
		$this->repositoryType = $repositoryType;
	}
	function repositoryUrl()
	{
		return $this->repositoryUrl;
	}
	function setRepositoryUrl($repositoryUrl)
	{
		$this->repositoryUrl = $repositoryUrl;
	}
	function repositoryBranch()
	{
		return $this->repositoryBranch;
	}
	function setRepositoryBranch($repositoryBranch)
	{
		$this->repositoryBranch = $repositoryBranch;
	}
	function inheritRepositoryInfo(BuildConfig $config)
	{
		if ($this->repositoryType === null)
			$this->repositoryType = $config->repositoryType;
		if ($this->repositoryUrl === null)
			$this->repositoryUrl = $config->repositoryUrl;
		if ($this->repositoryBranch === null)
			$this->repositoryBranch = $config->repositoryBranch;
	}
	function commandLineProperties()
	{
		return $this->commandLineProperties;
	}
	function setCommandLineProperties(ProjectConfig $config)
	{
		$properties = [];
		foreach ($config->propertyNames() as $name) {
			$p = $config->lookupProperty($name);
			if ($p->setAt() == COMMAND_LINE)
				$properties[$name] = $p->value();
		}
		$this->commandLineProperties = $properties;
	}
	function inheritCommandLineProperties(BuildConfig $config)
	{
		$this->commandLineProperties = $config->commandLineProperties;
	}
	function environmentProperties()
	{
		return $this->environmentProperties;
	}
	function setEnvironmentProperties(ProjectConfig $config)
	{
		$properties = [];
		foreach ($config->propertyNames() as $name) {
			$p = $config->lookupProperty($name);
			if ($p->setAt() == ENVIRONMENT)
				$properties[$name] = $p->value();
		}
		$this->environmentProperties = $properties;
	}
	function inheritEnvironmentProperties(BuildConfig $config)
	{
		$this->environmentProperties = $config->environmentProperties;
	}
	function projectInfo()
	{
		return $this->projectInfo;
	}
	function setProjectInfo($info)
	{
		$this->projectInfo = $info;
	}
	static function create($commandLine, $projectRoot)
	{
		$bootstrapPath = self::getBootstrapPath();
		$toolsPath = self::getToolsPath($projectRoot, $bootstrapPath);
		return new BuildConfig(
					   time(), $commandLine->action()->name(), false,
					   $bootstrapPath,
					   self::getBootstrapVersion($bootstrapPath),
					   $toolsPath,
					   self::getToolsVersion($toolsPath),
					   self::getSystemConfigFile($commandLine),
					   self::getProjectConfigFile($projectRoot),
					   self::getAdditionConfigFiles($commandLine, $projectRoot),
					   'git', $commandLine->getValue('repo-url'),
					   $commandLine->getValue('repo-branch'),
					   [], [], null
				   );
	}
	static function getBootstrapPath()
	{
		$coderage = \Makeme\File\searchIncludePath('CodeRage.php', true);
		if (!$coderage)
			return null;
		$bootstrapPath = dirname($coderage);
		foreach (split(self::BOOTSTRAP_FILES) as $f)
			if (!file_exists("$bootstrapPath/$f"))
				return null;
		return realpath($bootstrapPath);
	}
	static function getBootstrapVersion($path)
	{
		if (!file_exists($path))
			return null;
		$readme = "$path/README";
		$content = \Makeme\File\getContents($readme);
		$match = null;
		if (!preg_match('/Version:\\s+([0-9]+(?:\.[0-9])*)/', $content, $match))
			throw new
				Error(
					"Failed determining version of bootstrap files"
				);
		return $match[1];
	}
	private static function getToolsPath($projectRoot, $bootstrapPath)
	{
		foreach ([$projectRoot, $bootstrapPath] as $path)
			if (file_exists("$path/CodeRage/project.xml"))
				return realpath($path);
	}
	private static function getToolsVersion($path)
	{
		if (!file_exists($path))
			return null;
		$file = addslashes("$path/CodeRage/Version.php");
		$command = "php -nr \"require_once('$file'); echo CodeRage" . "\\VERSION;\"";
		$version = null;
		try {
			  $version = \Makeme\Util\system($command);
		} catch (Throwable $e) {
			throw new
				Error(
					'Failed determining version of CodeRage tools: ' .
					$e->getMessage()
				);
		}
		if (!preg_match('/[0-9]+(?:\.[0-9])*/', $version))
			throw new
				Error(
					"Failed determining version of CodeRage tools: invalid " .
					"version string '$version'"
				);
		return $version;
	}
	private static function getSystemConfigFile($commandLine)
	{
		if ( ($directory = $commandLine->getValue('sys-config')) &&
			 ($config = self::getSystemConfigFileImpl($directory)) )
		{
			return $config;
		}
		if ( ($directory = getenv(self::CONFIG_FILE_ENV_VARIABLE)) &&
			 ($config = self::getSystemConfigFileImpl($directory)) )
		{
			return $config;
		}
		$directory = \Makeme\Util\os() == 'Windows' ?
			getenv('WINDIR') :
			self::CONFIG_FILE_DIRECTORY_UNIX;
		return self::getSystemConfigFileImpl($directory);
	}
	private static function getSystemConfigFileImpl($directory)
	{
		if (!\Makeme\File\isAbsolute($directory))
			throw new Error(
						  "Invalid location of system-wide CodeRage " .
						  "configuration file: expected an absolute path; " .
						  "found '$directory'"
					  );
		foreach (split(self::SYSTEM_CONFIG_FILES ) as $f)
			if (is_file("$directory/$f"))
				return new BuildConfigFile("$directory/$f");
		return null;
	}
	private static function getProjectConfigFile($projectRoot)
	{
		foreach (split(self::CONFIG_FILES) as $f)
			if (is_file("$projectRoot/$f"))
				return new BuildConfigFile("$projectRoot/$f");
		return null;
	}
	private static function getAdditionConfigFiles($commandLine, $projectRoot)
	{
		$config = $commandLine->getValue('config');
		if ($config !== null) {
			$path =
				\Makeme\File\find(
					$config, [$projectRoot], false, true
				);
			return [new BuildConfigFile($path)];
		} else {
			return [];
		}
	}
	static function load($projectRoot)
	{
		$file = "$projectRoot/.coderage/history.php";
		if (!file_exists($file))
			return new BuildConfig(
						   0, null, false, null, null, null, null, null, null,
						   [], 'git', null, null, [], [], null
					   );
		\Makeme\File\checkReadable($file);
		global $config;  // set in $file
		include($file);
		if (!isset($config) || !is_array($config) || sizeof($config) != 15)
			throw new
				Error(
					"The file '$file' contains no build configuration"
				);
		return new
			BuildConfig(
				$config[0], $config[1], $config[2], $config[3], $config[4],
				$config[5], $config[6], $config[7], $config[8], $config[9],
				$config[10], $config[11], $config[12], $config[13], $config[14],
				null
			);
	}
	function save($projectRoot)
	{
		$file = "$projectRoot/.coderage/history.php";
		$definition = $this->definition();
		$content = "\$config = $definition;\n";
		\Makeme\File\generate($file, $content, 'php');
	}
	function definition()
	{
		return "array($this->timestamp," .
			   printScalar($this->action) . ',' .
			   printScalar($this->status) . ',' .
			   printScalar($this->bootstrapPath) . ',' .
			   printScalar($this->bootstrapVersion) . ',' .
			   printScalar($this->toolsPath) . ',' .
			   printScalar($this->toolsVersion) . ',' .
			   $this->printObject($this->systemConfigFile) . ',' .
			   $this->printObject($this->projectConfigFile) . ',' .
			   $this->printObject($this->additionalConfigFiles) . ',' .
			   printScalar($this->repositoryType) . ',' .
			   printScalar($this->repositoryUrl) . ',' .
			   printScalar($this->repositoryBranch) . ',' .
			   $this->printObject($this->commandLineProperties) . ',' .
			   $this->printObject($this->environmentProperties) . ')';
	}

	function __toString()
	{
		$result =
			"Last build: " . date(self::DATE_FORMAT) . "\n" .
			"Build action: $this->action\n" .
			"Status: " . ($this->status ? 'success' : 'failure') . "\n" .
			"Bootstrap path: " . $this->printInfo($this->bootstrapPath)  .
			"Bootstrap version: " . $this->printInfo($this->bootstrapVersion)  .
			"Tools path: " . $this->printInfo($this->toolsPath)  .
			"Tools version: " . $this->printInfo($this->toolsVersion)  .
			"CodeRage config file: " .
				( $this->systemConfigFile() ?
					  $this->printInfo($this->systemConfigFile()->path()) :
					  "<none>\n" ) .
			"Project config file: " .
				( $this->projectConfigFile() ?
					  $this->printInfo($this->projectConfigFile()->path()) :
					  "<none>\n" );
		if (sizeof($this->additionalConfigFiles)) {
			$result .= "Additional configuration files: \n";
			foreach ($this->additionalConfigFiles as $config)
				$result .= "  * " . $this->priprintInfontPath($config->path());
		}
		if (sizeof($this->commandLineProperties)) {
			$result .= "Command-line configuration: \n";
			foreach ($this->commandLineProperties as $n => $v)
				$result .= "  $n=" . printScalar($v) . "\n";
		}
		return $result;
	}
	function printInfo($value)
	{
		return $value !== null ? "$value\n" : "n/a\n";
	}
	private function printObject($value)
	{
		if (is_array($value)) {
			$items = [];
			foreach ($value as $n => $v)
				$items[] = is_int($n) ?
					$this->printObject($v) :
					$this->printObject($n) . '=>' . $this->printObject($v);
			return 'array(' . join(',', $items) . ')';
		} elseif (is_object($value)) {
			return $value->definition();
		} elseif (is_string($value)) {
			return ctype_print($value) ?
				"'" . addcslashes($value, "\\'") . "'" :
				"base64_decode('" . base64_encode($value) . "')";
		} elseif (is_bool($value)) {
			return $value ? 'true' : 'false';
		} elseif ($value === null) {
			return 'null';
		} else {
			return strval($value);
		}
	}
	private static function printLiteral($value)
	{
		switch (gettype($value)) {
		case 'boolean':
			return $value ? 'true' : 'false';
		case 'integer':
		case 'double':
			return strval($value);
		case 'string':
			return ctype_print($value) ?
				"'" . addcslashes($value, "\\'") . "'" :
				"base64_decode('" . base64_encode($value) . "')";
		case 'array':
			$literals = [];
			foreach ($value as $v)
				$literals[] = self::printLiteral($v);
			return 'array(' . join(',', $literals) . ')';
		default:
			throw new
				Exception(
					"Invalid property value: " . printScalar($value)
				);
		}
	}
}
class BuildConfigFile {
	private $path;
	private $timestamp;
	function __construct($path, $timestamp = null)
	{
		if ($timestamp === null) {
			if (!file_exists($path))
				throw new Error("No such file: $path");
			$timestamp = @filemtime($path);
			if ($timestamp === false)
				throw new
					Error(
						"Failed querying last modification time: $path"
					);
			$path = realpath($path);
		}
		$this->path = $path;
		$this->timestamp = $timestamp;
	}
	function path()
	{
		return $this->path;
	}
	function timestamp()
	{
		return $this->timestamp;
	}
	function definition()
	{
		return 'array(' .
			   printScalar($this->path) . ',' .
			   printScalar($this->timestamp) . ')';
	}
}
namespace Makeme\Build;

use Throwable;
use Makeme\Log;
use function Makeme\Util\escapeShellArg;
use function Makeme\Util\system;

function addToPath($paths)
{
	$log = new Log('build');
	if (is_string($paths))
		$paths = [$paths];
	foreach ($paths as $p) {
		if (!\Makeme\File\isAbsolute($p))
			$log->logError("Failed adding '$f': path is not absolute");
		if (\Makeme\Util\os() == 'windows') {
			$dir = realpath(dirname($p));
			$path = getenv('PATH');
			$path = chop($path, ';\\');
			$found = false;
			foreach (explode(';', $path) as $d)
				if (realpath($d) == $dir) {
					$found = true;
					break;
				}
			if ($found)
				continue;

			if ($str = $log->getStream(Log::INFO))
				$str->write("Updating PATH environment variable");
			$exes = \Makeme\File\findExecutable('setx');
			if (sizeof($exes) == 0)
				if ($str = $log->getStream(Log::ERROR)) {
					$message =
						"Failed updating the system PATH environment to " .
						"include '$dir': setx.exe not found. Please update " .
						 "PATH manually";
					$str->write($message);
					continue;
				}
			$setx = \Makeme\Util\escapeExecutable($exes[0]);
			$newPath = "$dir;$path";
			$command =
				"$setx PATH " . escapeShellArg($newPath) . " -m";
			try {
				system($command);
				putenv("PATH=$newPath");
			} catch (Throwable $e) {
				if ($str = $log->getStream(Log::ERROR)) {
					$message =
						"Failed updating the system PATH environment to " .
						"include '$dir': " . $e->getMessage() . ". You may " .
						"to run makeme with administrative privileges.";
					$str->write($message);
				}
			}
		} else {
			$target = '/usr/bin/' . basename($p);
			\Makeme\File\rm($target);
			$command =
				"ln -s " . escapeShellArg(realpath($p)) . " " .
				escapeShellArg($target);
			try {
				system($command);
			} catch (Throwable $e) {
				if ($str = $log->getStream(Log::ERROR)) {
					$message =
						"Failed creating symbolic link: " . $e->getMessage();
					$str->write($message);
				}
			}
		}
	}
}
namespace Makeme\File;

function findExecutable($program, $search = null)
{
	$posix = \Makeme\Util\os() == 'posix';
	if (!$search) {
		$search = explode(PATH_SEPARATOR, getenv('PATH'));
	} elseif (is_string($search)) {
		$search = [$search];
	}
	$extensions = $posix ?
		[''] :
		explode(';', strtolower(getenv('PATHEXT')));
	$sep = $posix ? '/' : '\\';
	$result = [];
	foreach ($search as $dir) {
		foreach ($extensions as $ext) {
			$file = "$dir$sep$program$ext";
			if (is_file($file) && (!$posix || is_executable($file))) {
				$result[] = realpath($file);
				break;
			}
		}
	}
	return array_unique($result);
}
namespace Makeme\Build;

use Makeme\Log;

function addToIncludePath($dir)
{
	$log = new Log('build');
	$dir = \Makeme\File\canonicalize($dir);
	$path = ini_get('include_path');
	foreach (explode(PATH_SEPARATOR, $path) as $d)
		if (realpath($d) == $dir)
			return;

	if ($str = $log->getStream(Log::INFO))
		$str->write("Updating PHP include_path");
	$manager = new Packages\Php\Manager();
	$version = phpversion();
	$properties =
		[
			'minVersion' => $version,
			'maxVersion' => $version
		];
	if ($iniPath = get_cfg_var('cfg_file_path'))
		$properties['iniPath'] = $iniPath;
	$configurations = $manager->lookupConfigurations($properties);
	if (sizeof($configurations)) {
		  $configurations[0]->addToLibrarySearchPath($dir);
	} else {
		if ($str = $log->getStream(Log::ERROR)) {
			$handler = new \Makeme\Util\ErrorHandler;
			$str->write(
				$handler->formatError(
					"Failed updating PHP include_path to include the " .
					"directory '$dir': Can't locate current PHP " .
					"installation. Please update php.ini manually."
				)
			);
		}
		return;
	}
}
namespace Makeme\File;

use Makeme\Error;

function canonicalize($path)
{
	if (!file_exists($path))
		throw new Error("No such file: $path");
	$path = realpath($path);
	if (\Makeme\Util\os() == 'posix')
		return $path;
	ob_start();
	$esc = \Makeme\Util\escapeShellArg($path);
	$result = system("for %x in ($esc) do echo %~fsx");
	ob_end_clean();
	if (realpath($result) != $path)
		throw new Error("Failed canonicalizing '$path'");
	return $result;
}
namespace Makeme\Build\Packages;

use Makeme\Error;
use Makeme\Log;

abstract class Manager {
	private $log;
	protected function __construct() { }
	function log()
	{
		if (!$this->log) {
			$this->log = new Log('build');
		}
		return $this->log;
	}
	abstract function name();
	function libraryFileExtension()
	{
		return null;
	}
	function dependencies() { return []; }
	function versionCompare($lhs, $rhs)
	{
		return version_compare($lhs, $rhs);
	}
	function lookupConfigurations(array $properties = [])
	{
		return [];
	}
	function installConfiguration(array $properties = [])
	{
		throw new Error('Not implemented');
	}
	function uninstallConfiguration(Configuration $config)
	{
		throw new Error('Not implemented');
	}
	function configurationId(Configuration $config)
	{
		throw new Error('Not implemented');
	}
	function lookupChannels(Configuration $config)
	{
		throw new Error('Not implemented');
	}
	function installChannel(
		Configuration $config,
		Channel $channel )
	{
		throw new Error('Not implemented');
	}
	function uninstallChannel(
		Configuration $config,
		Channel $channel )
	{
		throw new Error('Not implemented');
	}
	function lookupPackages(
		Configuration $config, array $properties = [])
	{
		return [];
	}
	function installPackage(
		Configuration $config, $name,
		array $properties = [] )
	{
		return false;
	}
	function uninstallPackage(
		Configuration $config,
		Package $package )
	{
		return false;
	}
	function installLocalPackage(
		Configuration $config, $paths, $overwrite)
	{
		throw new Error('Not implemented');
	}
	function uninstallLocalPackage(
		Configuration $config, $paths)
	{
		throw new Error('Not implemented');
	}
	function inLibrarySearchPath(
		Configuration $config, $path)
	{
		throw new Error('Not implemented');
	}
	function addToLibrarySearchPath(
		Configuration $config, $dir)
	{
		throw new Error('Not implemented');
	}
	function getConfigurationProperty(
		Configuration $config, $name)
	{
		throw new Error('Not implemented');
	}
	function setConfigurationProperty(
		Configuration $config, $name, $value)
	{
		throw new Error('Not implemented');
	}
	function runCommand($command, $redirectError = false)
	{
		if ($str = $this->log()->getStream(Log::DEBUG))
			$str->write("Running command $command");
		if ($redirectError)
			$command .= \Makeme\Util\os() == 'posix' ?
				' 2>/dev/null' :
				' 2>NUL';
		return \Makeme\Util\system($command);
	}
	protected function mkdirs($path, $mode = 0777)
	{
		return \Makeme\File\mkdir($path, $mode);
	}
	protected function rm($path)
	{
		return \Makeme\File\rm($path);
	}
}
namespace Makeme\Build\Packages\Php;

use Makeme\Build\Packages\Package;
use Makeme\Error;
use function Makeme\File\isAbsolute;
use Makeme\Log;

class Manager extends \Makeme\Build\Packages\Manager {
	function __construct()
	{
		parent::__construct();
	}
	function name() { return 'php'; }
	function libraryFileExtension()
	{
		return 'php';
	}
	function lookupConfigurations(array $properties = [])
	{
		$search = isset($properties['binaryPath']) ?
			$properties['binaryPath'] :
			null;
		$programs = \Makeme\File\findExecutable('php', $search);
		$iniPath = isset($properties['iniPath']) ?
			$properties['iniPath'] :
			null;
		$minVersion = isset($properties['minVersion']) ?
			$properties['minVersion'] :
			null;
		$maxVersion = isset($properties['maxVersion']) ?
			$properties['maxVersion'] :
			null;
		$configs = [];
		foreach ($programs as $p) {
			$esc =  \Makeme\Util\escapeExecutable($p);
			$output = $this->runCommand("$esc -qv");
			$match = null;
			if (!preg_match('/^PHP ([0-9.]+)/', $output, $match))
				throw new
					Error(
						"Failed determining PHP version for '$p'"
					);
			$version = $match[1];
			if ( ($minVersion && version_compare($version, $minVersion)) < 0 ||
				 ($maxVersion && version_compare($version, $maxVersion)) > 0 )
			{
				continue;
			}
			$command = "$esc -qr \"echo get_cfg_var('cfg_file_path');\"";
			$path = $this->runCommand($command);
			if (!file_exists($path))
				continue;
			if ($iniPath !== null && realpath($path) != realpath($iniPath))
				continue;
			$configs[] =
				new Configuration(
						$this, $version, $p
					);
		}

		return $configs;
	}
	function configurationId(\Makeme\Build\Packages\Configuration $config)
	{
		return $config->binaryPath();
	}
	function lookupChannels(\Makeme\Build\Packages\Configuration $config)
	{
			return [];
	}
	function lookupPackages(
		\Makeme\Build\Packages\Configuration $config, array $properties = [])
	{
		$output =
			$config->runCommand(
				'-qr "echo join(\",\", get_loaded_extensions());"'
			);
		$extensions = explode(',', $output);
		$names = !isset($properties['name']) ?
			$extensions :
			( in_array($properties['name'], $extensions) ?
				  [$properties['name']] :
				  [] );
		$packages = [];
		foreach ($names as $n)
			$packages[] = new Package($n, null, null);
		return $packages;
	}
	function installPackage(
		\Makeme\Build\Packages\Configuration $config, $name,
		array $properties = [] )
	{
		if (sizeof($this->lookupPackages($config, ['name' => $name])))
			return false;
		$dir = $this->getConfigurationProperty($config, 'extension_dir');
		if (!isAbsolute($dir))
			$dir = dirname($config->binaryPath()) . '/' . $dir;
		$file =
			(PHP_SHLIB_SUFFIX == 'dll' ? 'php_' : '') .
			$name . '.' . PHP_SHLIB_SUFFIX;
		$path = "$dir/$file";
		if (!file_exists($path))
			throw new
				Error(
					"Failed installing extension '$name': " .
					"file '$file' not found"
				);
		$config->ini()->insertExtension($name);
		$config->ini()->save();
		return true;
	}
	function uninstallPackage(
		\Makeme\Build\Packages\Configuration $config,
		Package $package )
	{
		$name = $package->name();
		if (sizeof($this->lookupPackages($config, ['name' => $name])) == 0)
			return false;
		$config->ini()->disableExtension($name);
		$config->ini()->save();
	}
	function inLibrarySearchPath(
		\Makeme\Build\Packages\Configuration $config, $path)
	{
		$path = addcslashes($path, "'");
		$code =
			"function e(\$a,\$b) { echo 0; exit; } " .
			"set_error_handler('e', E_WARNING); " .
			"if (include('$path')) { echo 1; }";
		$command = "-r " . \Makeme\Util\escapeShellArg($code);
		return (bool) $config->runCommand($command);
	}
	function addToLibrarySearchPath(
		\Makeme\Build\Packages\Configuration $config, $dir)
	{
		try {
			$dir = realpath($dir);
			$ini = $config->ini();
			if (!$ini) {
				if ($str = $this->log()->getStream(Log::ERROR))
					$str->write(
						"Failed updating PHP include_path to include the " .
						"directory '$dir': no php.ini loaded. Please " .
						"update php.ini manually."
					);
					return;
			}
			if ($includePath = $ini->lookupDirective('include_path')) {
				$paths = [$dir];
				foreach ($includePath->value() as $v) {
					if (!isAbsolute($v)) {
						$paths[] = $v;
					} elseif (file_exists($v)) {
						$canon = realpath($v);
						if ($canon != $dir)
							$paths[] = $canon;
					} else {
						  $paths[] = $v;
					}
				}
				$ini->insertDirective('include_path', $paths);
			} else {
				$ini->insertDirective('include_path', [$dir]);
			}
			$ini->save();
		} catch (\Throwable $e) {
			if ($str = $this->log()->getStream(Log::ERROR)) {
				$handler = new \Makeme\Util\ErrorHandler;
				$str->write(
					$handler->formatError(
						"Failed updating PHP include_path to include the " .
						"directory '$dir': $e. Please " .
						"update php.ini manually."
					)
				);
			}
		}
	}
	function getConfigurationProperty(
		\Makeme\Build\Packages\Configuration $config, $name)
	{
		if (!preg_match('/^[_a-z][_a-z0-9]$/i', $name))
			throw new Error("Invalid configuration property: $name");
		$output = $config->runCommand("-qr \"echo ini_get(\"$name\");\"");
		$d = IniDirective::create($name);
		return $d->fromString($output);
	}
	function setConfigurationProperty(
		\Makeme\Build\Packages\Configuration $config, $name, $value)
	{
		if ($this->getConfigurationProperty($config, $name) !== $value) {
			$config->ini()->insertDirective($name, $value);
			$config->ini()->save();
		}
	}
}
namespace Makeme\Build\Packages;
class Configuration {
	private $manager;
	private $version;
	function __construct(Manager $manager, $version)
	{
		$this->manager = $manager;
		$this->version = $version;
	}
	function version() { return $this->version; }

					/*
					 * Convenience methods
					 */
	function configurationId()
	{
		return $this->manager->configurationId($this);
	}
	function lookupChannels()
	{
		return $this->manager->lookupChannels($this);
	}
	function installChannel(Channel $channel)
	{
		return $this->manager->installChannel($this, $channel);
	}
	function uninstallChannel(Channel $channel)
	{
		return $this->manager->uninstallChannel($this, $channel);
	}
	function lookupPackages(array $properties = [])
	{
		return $this->manager->lookupPackages($this, $properties);
	}
	function installPackage($name, array $properties = [])
	{
		return $this->manager->installPackage($this, $name, $properties);
	}
	function uninstallPackage(Package $package)
	{
		return $this->manager->uninstallPackage($this, $package);
	}
	function installLocalPackage($paths, $overwrite = true)
	{
		return $this->manager->installLocalPackage($this, $paths, $overwrite);
	}
	function uninstallLocalPackage($paths)
	{
		return $this->manager->uninstallLocalPackage($this, $paths);
	}
	function inLibrarySearchPath($path)
	{
		return $this->manager->inLibrarySearchPath($this, $path);
	}
	function addToLibrarySearchPath($dir)
	{
		$this->manager->addToLibrarySearchPath($this, $dir);
	}
	function getConfigurationProperty($name)
	{
		return $this->manager->getConfigurationProperty($this, $name);
	}
	function setConfigurationProperty($name, $value)
	{
		$this->manager->setConfigurationProperty($this, $name, $value);
	}
	function manager()
	{
		return $this->manager;
	}
}
namespace Makeme\Build\Packages;

class BasicConfiguration
	extends Configuration
{
	private $binaryPath;
	function __construct(
		Manager $manager, $version, $binaryPath)
	{
		parent::__construct($manager, $version);
		$this->binaryPath = $binaryPath;
	}
	function binaryPath() { return $this->binaryPath; }
	function runCommand($args, $redirectError = false)
	{
		$redirect = $redirectError ?
			(\Makeme\Util\os() == 'windows' ? ' 2>NUL' : ' 2>/dev/null') :
			'';
		$binary = \Makeme\Util\escapeExecutable($this->binaryPath);
		$command = "$binary $args $redirect";
		return $this->manager()->runCommand($command, $redirectError);
	}
}
namespace Makeme\Build\Packages\Php;

class Configuration
	extends \Makeme\Build\Packages\BasicConfiguration
{
	private $ini;
	function __construct(
		Manager $manager, $version, $binaryPath)
	{
		parent::__construct($manager, $version, $binaryPath);
		$this->parseIni();
	}
	function ini() { return $this->ini; }
	private function parseIni()
	{
		$iniPath =
			$this->runCommand('-r "echo get_cfg_var(\'cfg_file_path\');"');
		if (!$iniPath)
			return;
		$match = null;
		$iniScanDir =
			preg_match( '/additional \.ini files => (.*)/',
						$this->runCommand('-i'),
						$match ) ?
				$match[1] :
				null;
		$this->ini = new Ini($iniPath, $iniScanDir);
	}
}
namespace Makeme\Build\Packages\Php;

use Makeme\Error;
use Makeme\Util\ErrorHandler;
use function Makeme\Util\printScalar;

class Ini {
	const BOOLEAN_ = 0;
	const INT_ = 1;
	const STRING_ = 2;
	const PATH = 3;
	const PATHLIST = 4;
	const NONE = 0;
	const SYSLOG = 1;
	const TOKEN_NAME = 0;
	const TOKEN_VALUE = 1;
	const TOKEN_BLOCK = 2;
	const TOKEN_COMMENT = 3;
	const TOKEN_SPACE = 4;
	const TOKEN_DISABLED_NOTICE = 5;
	const TOKEN_DISABLED_NAME = 6;
	const TOKEN_DISABLED_VALUE = 7;
	const STATE_INITIAL = 0;
	const STATE_VALUE = 1;
	const STATE_NAME_DISABLED = 3;
	const STATE_VALUE_DISABLED = 4;
	const DIRECTIVE_DISABLED_NOTICE = '; Disabled by CodeRage';
	const DIRECTIVE_DISABLED_TIMESTAMP = DATE_RFC1036;
	private $files = [];
	function __construct($configFilePath, $configFileScanDir = null)
	{
		$this->files[] = new IniFile($configFilePath);
		if ($configFileScanDir && file_exists($configFileScanDir)) {
			$handler = new ErrorHandler;
			$dir = $handler->_opendir($configFileScanDir);
			if ($handler->errno())
				throw new
					Error(
						$handler->formatError(
							"Failed reading directory '$configFileScanDir'"
						)
					);
			while (($file = @readdir($dir)) !== false)
				if (preg_match('/\.ini$/', $file))
					$this->files[] =
						new IniFile(
							"$configFileScanDir/$file"
						);
			@closedir($dir);
		}
	}
	function hasDirective($name)
	{
		foreach ($this->files as $f)
			if ($f->hasDirective($f))
				return true;
		return false;
	}
	function lookupDirective($name)
	{
		for ($z = sizeof($this->files) - 1; $z != -1; --$z)
			if ($d = $this->files[$z]->lookupDirective($name))
				return $d;
		return null;
	}
	function insertDirective($name, $value)
	{
		for ($z = sizeof($this->files) - 1; $z != -1; --$z) {
			if ($this->files[$z]->insertDirective($name, $value, $z == 0)) {
				for (--$z; $z != -1; --$z)
					$this->files[$z]->removeDirective($name);
				break;
			}
		}
	}
	function removeDirective($name)
	{
		foreach ($this->files as $f)
			$f->removeDirective($name);
	}
	function hasExtension($name)
	{
		foreach ($this->files as $f)
			if ($f->hasExtension($f))
				return true;
		return false;
	}
	function enableExtension($name)
	{
		for ($z = sizeof($this->files) - 1; $z != -1; --$z)
			if ($this->files[$z]->enableExtension($name, $z == 0))
				return;
	}
	function disableExtension($name)
	{
		foreach ($this->files as $f)
			$f->disableExtension($name);
	}
	function save()
	{
		foreach ($this->files as $f)
			$f->save();
	}
}
class IniFile {
	private $path;
	private $prefix;
	private $lines = [];
	private $insertedDirectives = [];
	private $insertedExtensions = [];
	private $lineEnding;
	private $modified = false;
	function __construct($path)
	{
		$this->path = $path;
		$this->parse();
	}
	function hasDirective($name)
	{
		if (isset($this->insertedDirectives[$name]))
			return true;
		foreach ($this->lines as $line) {
			if (  $line->directive() &&
				  $line->name() == $name &&
				 !$line->disabled() )
			{
				return true;
			}
		}
		return false;
	}
	function lookupDirective($name)
	{
		if (isset($this->insertedDirectives[$name]))
			return $this->insertedDirectives[$name];
		for ($z = sizeof($this->lines) - 1; $z != -1; --$z) {
			$line = $this->lines[$z];
			if (  $line->directive() &&
				  $line->name() == $name &&
				 !$line->disabled() )
			{
				return $line->directive();
			}
		}
		return null;
	}
	function insertDirective($name, $value, $insert = true)
	{
		if ($this->enableDirective($name, $value))
			return true;

		if (($d = $this->lookupDirective($name)) && $d->value() === $value) {
			return true;

		} elseif (isset($this->insertedDirectives[$name])) {
			$d->setValue($value);
			return true;

		} else {
			$found = false;
			for ($z = sizeof($this->lines) - 1; $z != -1; --$z) {
				$line = $this->lines[$z];
				if ($line->directive() && $line->name() == $name) {
					$found = true;
					$line->setDisabled(true);
				}
			}

			if (!$insert && !$found)
				return false;
			$d = IniDirective::create($name);
			$d->setValue($value);
			$this->insertedDirectives[$name] = $d;
			$this->modified = true;
			return true;
		}
	}
	function removeDirective($name)
	{
		if (isset($this->insertedDirectives[$name])) {
			unset($this->insertedDirectives[$name]);
			$this->modified = true;
		}
		for ($z = sizeof($this->lines) - 1; $z != -1; --$z) {
			$line = $this->lines[$z];
			if (  $line->directive() &&
				  $line->name() == $name &&
				 !$line->disabled() )
			{
				$line->setDisabled(true);
			}
		}
	}
	function hasExtension($name)
	{
		if (isset($this->insertedExtensions[$name]))
			return true;
		foreach ($this->lines as $line) {
			if (  $line->extension() &&
				  $line->name() == $name &&
				 !$line->disabled() )
			{
				return true;
			}
		}
		return false;
	}
	function enableExtension($name, $insert = true)
	{
		if (isset($this->insertedExtensions[$name]))
			return true;
		for ($z = sizeof($this->lines) - 1; $z != -1; --$z) {
			$line = $this->lines[$z];
			if ($line->extension() && $line->name() == $name) {
				if ($line->disabled())
					$line->setDisabled(false);
				return true;
			}
		}

		if (!$insert)
			return false;
		$this->insertedExtensions[$name] = $name;
		$this->modified = true;
		return true;
	}
	function disableExtension($name)
	{
		if (isset($this->insertedExtensions[$name])) {
			unset($this->insertedExtensions[$name]);
			$this->modified = true;
		}
		for ($z = sizeof($this->lines) - 1; $z != -1; --$z) {
			$line = $this->lines[$z];
			if (  $line->extension() &&
				  $line->name() == $name &&
				 !$line->disabled() )
			{
				$line->setDisabed(true);
			}
		}
	}
	function save()
	{
		$modified = $this->modified;
		if (!$modified) {
			foreach ($this->lines as $line) {
				if ($line->modified()) {
					$modified = true;
					break;
				}
			}
			foreach ($this->insertedDirectives as $dir) {
				if ($dir->modified()) {
					$modified = true;
					break;
				}
			}
		}
		if ($modified) {
			$handler = new ErrorHandler;
			$result = $handler->_file_put_contents($this->path, (string) $this);
			if ($result === false || $handler->errno())
				throw new
					Error(
						$handler->formatError("Failed writing to '$this->path'")
					);
			$this->parse();
		}
	}
	function __toString()
	{
		$result = $this->prefix;
		foreach ($this->lines as $line)
			$result .= $line;
		if ( sizeof($this->insertedDirectives) ||
			 sizeof($this->insertedExtensions) )
		{
			$result = preg_replace('/\n+$/', '', $result);
			$result .=
				"\n\n[CodeRage]\n" .
				"; Updated " . date(Ini::DIRECTIVE_DISABLED_TIMESTAMP) .
				"\n";
			foreach ($this->insertedDirectives as $n => $d)
				$result .= (string) $d;
			foreach ($this->insertedExtensions as $e)
				$result .=
					"extension = " .
					(PHP_SHLIB_SUFFIX == 'dll' ? 'php_' : '') . "$e." .
					PHP_SHLIB_SUFFIX;
		}

		return str_replace("\n", $this->lineEnding, $result);
	}
	function enableDirective($name, $value)
	{
		for ($z = sizeof($this->lines) - 1; $z != -1; --$z) {
			$line = $this->lines[$z];
			if (  $line->directive() &&
				  $line->disabled() &&
				  $line->name() == $name &&
				  $line->value() === $value )
			{
				$line->setDisabled(false);
				unset($this->insertedDirectives[$name]);
				return true;
			}
		}
	}
	private function parse()
	{
		$this->reset();
		$parser = new IniParser($this->path);
		$this->lineEnding = $parser->lineEnding();
		$name = $value = $curPrefix = $nextPrefix = $curBlock = $nextBlock =
			null;
		$text = $suffix = '';
		$first = true;
		while ($token = $parser->nextToken()) {
			switch ($token->id()) {
			case Ini::TOKEN_NAME:
			case Ini::TOKEN_DISABLED_NAME:
				if ($name || $first) {
					if ($name)
						$this->processLine(
							$curBlock, $curPrefix, $text, $suffix, $name, $value
						);
					$curBlock = $nextBlock;
					$curPrefix = $nextPrefix;
					$nextPrefix = null;
					$name = $value;
					$text = $suffix = '';
				}
				$first = false;
				$name = $token->value();
				$text .= $token->text();
				break;
			case Ini::TOKEN_VALUE:
			case Ini::TOKEN_DISABLED_VALUE:
				$value = $token->value();
				$text .= $token->text();
				break;
			case Ini::TOKEN_BLOCK:
				if ($name || $first) {
					if ($token->value() != 'CodeRage')
						$suffix .= $token->text();
					$nextBlock = $token->value();
				} else {
					$this->prefix .= $token->text();
					$curBlock = $nextBlock = $token->value();
				}
				break;
			case Ini::TOKEN_COMMENT:
			case Ini::TOKEN_SPACE:
				if ($name || $first) {
					if ($nextBlock != 'CodeRage')
						$suffix .= $token->text();
				} else {
					$this->prefix .= $token->text();
				}
				break;
			case Ini::TOKEN_DISABLED_NOTICE:
				$curPrefix = $nextPrefix;
				$nextPrefix = $token->text();
				break;
			}
		}
		if ($name)
			$this->processLine(
				$curBlock, $curPrefix, $text, $suffix, $name, $value
			);
	}
	private function reset()
	{
		$this->prefix = '';
		$this->lines = [];
		$this->insertedDirectives = [];
		$this->insertedExtensions = [];
		$this->lineEnding = null;
		$this->modified = false;
	}
	private function processLine(
		$block, $prefix, $text, $suffix, $name, $value)
	{
		$directive = $name != 'extension' ?
			IniDirective::create($name) :
			null;
		if ($directive)
			$directive->setValueImpl($directive->fromString($value));
		$extension = $name == 'extension' ?
			preg_replace('/(^php_)|(\.[^.]+$)/', '', $value) : null;
		if ($block == 'CodeRage') {
			if ($directive)
				$this->insertedDirectives[$name] = $directive;
			else
				$this->insertedExtensions[$extension] = $extension;
		} else {
			$line =
				new IniLine(
						$prefix, $text, $suffix, $directive, $extension
					);
			$this->lines[] = $line;
		}
	}
}
class IniLine {
	private $prefix;
	private $text;
	private $suffix;
	private $directive;
	private $extension;
	private $disabled;
	function __construct($prefix, $text, $suffix, $directive, $extension)
	{
		$this->prefix = $prefix;
		$this->text = $text;
		$this->suffix = $suffix;
		$this->directive = $directive;
		$this->extension = $extension;
		$this->disabled = $prefix !== null;
	}
	function name()
	{
		return $this->directive ?
			$this->directive->name() :
			$this->extension;
	}
	function prefix()
	{
		return $this->prefix;
	}
	function text()
	{
		return $this->text;
	}
	function suffix()
	{
		return $this->suffix;
	}
	function directive()
	{
		return $this->directive;
	}
	function value()
	{
		return $this->directive->value();
	}
	function setValue($value)
	{
		$this->directive->setValue($value);
	}
	function extension()
	{
		return $this->extension;
	}
	function disabled()
	{
		return $this->disabled;
	}
	function setDisabled($disabled)
	{
		$this->disabled = $disabled;
	}
	function modified()
	{
		return $this->disabled === ($this->prefix === null) ||
			   $this->directive && $this->directive->modified();
	}
	function __toString()
	{
		$prefix = $text = null;
		if ($this->disabled == ($this->prefix !== null)) {
			$prefix = $this->prefix;
			$text = $this->directive && $this->directive->modified() ?
				(string) $this->directive :
				$this->text;
		} elseif ($this->disabled) {
			$prefix =
				Ini::DIRECTIVE_DISABLED_NOTICE . ': ' .
				date(Ini::DIRECTIVE_DISABLED_TIMESTAMP) .
				"\n";
			$text = ';' . preg_replace("/\n(?!$)/", "\n;", $this->text);
		} else {
			$prefix = '';
			$text = $this->directive && $this->directive->modified() ?
				(string) $this->directive :
				str_replace("\n;", "\n", substr($this->text, 1));
		}
		return $prefix . $text . $this->suffix;
	}
}
class IniDirective {
	private $name;
	private $type;
	private $specialValues;
	private $value;
	private $modified = false;
	protected function __construct($name, $type, $specialValues = null)
	{
		switch ($type) {
		case Ini::BOOLEAN_:
		case Ini::INT_:
		case Ini::STRING_:
		case Ini::PATH:
		case Ini::PATHLIST:
			break;
		default:
			throw new Error("Unknown type: $type");
		}
		$this->name = $name;
		$this->type = $type;
		$this->specialValues = $specialValues;
	}
	function name()
	{
		return $this->name;
	}
	function type()
	{
		return $this->type;
	}
	function specialValues()
	{
		return $this->specialValues;
	}
	function value()
	{
		return $this->value;
	}
	function setValue($value)
	{
		$this->setValueImpl($value);
		$this->modified = true;
	}
	function modified()
	{
		return $this->modified;
	}
	function fromString($value)
	{
		$value = trim($value);
		if ($value == '' || strcasecmp($value, 'none') == 0)
			return null;
		switch ($this->type) {
		case Ini::BOOLEAN_:
			if (!preg_match('/^on|off|true|false|yes|no|1|0$/i', $value))
				throw new
					Error(
						"Invalid argument to " .
						"Makeme\Build\Packages\Php\IniDirective::fromString() " .
						"for directive '$this->name': expected one of 'On', " .
						"'Off', 'True', 'False', 'Yes', 'No', '1', or '0'; " .
						"found $value"
					);
			switch (strtolower($value)) {
			case 'on':
			case 'true':
			case 'yes':
				return true;
			default:
				return false;
			}
		case Ini::INT_:
			if (!is_numeric($value) || floatval($value) != intval($value))
				throw new
					Error(
						"Invalid argument to " .
						"Makeme\Build\Packages\Php\IniDirective::fromString() " .
						"for directive '$this->name': expected int; found " .
						$value
					);
			return intval($value);
		case Ini::STRING_:
		case Ini::PATH:
			return $value;
		case Ini::PATHLIST:
			return explode(PATH_SEPARATOR, $value);
		default:
			return null; // can't happen
		}
	}
	function toString($value)
	{
		if ($value === null)
			return 'none';
		switch ($this->type) {
		case Ini::BOOLEAN_:
			if (!is_bool($value))
				throw new
					Error(
						'Invalid argument to ' .
						'Makeme\Build\Packages\Php\IniDirective::toString(); ' .
						'expected boolean; found ' .
						printScalar($value)
					);
			return $value ? 'On' : 'Off';
		case Ini::INT_:
			if (!is_int($value))
				throw new
					Error(
						'Invalid argument to ' .
						'Makeme\Build\Packages\Php\IniDirective::toString(); ' .
						'expected int; found ' .
						printScalar($value)
					);
			return strval($value);
		case Ini::PATH:
		case Ini::STRING_:
			if (!is_string($value))
				throw new
					Error(
						'Invalid argument to ' .
						'Makeme\Build\Packages\Php\IniDirective::toString(); ' .
						'expected string; found ' .
						printScalar($value)
					);
			return strpos($value, ';') !== false ||
				   preg_match('/\n(?!$)/', $value) ?
				"\"$value\"" :
				$value;
		case Ini::PATHLIST:
			if (!is_array($value))
				throw new
					Error(
						'Invalid argument to ' .
						'Makeme\Build\Packages\Php\IniDirective::toString(); ' .
						'expected array; found ' .
						printScalar($value)
					);
			return '"' . join(PATH_SEPARATOR, $value) . '"';
		default:
			return null; // can't happen
		}
	}
	static function create($name)
	{
		switch ($name) {
		case 'include_path':
			return new
				IniDirective(
					'include_path',
					Ini::PATHLIST
				);
		default:
			return new
				IniDirective(
					$name,
					Ini::STRING_
				);
		}
	}
	function __toString()
	{
		return "$this->name = " . $this->toString($this->value) . "\n";
	}
	function setValueImpl($value)
	{
		if ($value !== null) {
			switch ($this->type) {
			case Ini::BOOLEAN_:
				if (!is_bool($value))
					throw new
						Error(
							"Invalid argument to " .
							"Makeme\Build\Packages\Php\IniDirective::setValue() " .
							"for directive '$this->name'; expected boolean; " .
							"found " . printScalar($value)
						);
				break;
			case Ini::INT_:
				if (!is_int($value))
					throw new
						Error(
							"Invalid argument to " .
							"Makeme\Build\Packages\Php\IniDirective::setValue() " .
							"for directive '$this->name'; expected int; " .
							"found " . printScalar($value)
						);
				break;
			case Ini::PATH:
			case Ini::STRING_:
				if (!is_string($value))
					throw new
						Error(
							"Invalid argument to " .
							"Makeme\Build\Packages\Php\IniDirective::setValue() " .
							"for directive '$this->name'; expected string; " .
							"found " . printScalar($value)
						);
				break;
			case Ini::PATHLIST:
				if (!is_array($value))
					throw new
						Error(
							"Invalid argument to " .
							"Makeme\Build\Packages\Php\IniDirective::setValue() " .
							"for directive '$this->name'; expected array; " .
							"found " . printScalar($value)
						);
				break;
			default:
				break; // can't happen
			}
		}
		$this->value = $value;
	}
}
class IniToken {
	private $id;
	private $value;
	private $text;
	function __construct($id, $value, $text)
	{
		$this->id = $id;
		$this->value = $value;
		$this->text = $text;
	}
	function id()
	{
		return $this->id;
	}
	function value()
	{
		return $this->value;
	}
	function text()
	{
		return $this->text;
	}
	function __toString()
	{
		$result = '';
		switch ($this->id) {
		case Ini::TOKEN_NAME:
			return "name($this->value)";
		case Ini::TOKEN_VALUE:
			return "value($this->value)";
		case Ini::TOKEN_BLOCK:
			return "block($this->value)";
		case Ini::TOKEN_COMMENT:
			return "comment($this->text)";
		case Ini::TOKEN_SPACE:
			return "space";
		case Ini::TOKEN_DISABLED_NOTICE:
			return "disabled notice";
		case Ini::TOKEN_DISABLED_NAME:
			return "disabled name($this->value)";
		case Ini::TOKEN_DISABLED_VALUE:
			return "disabled value($this->value)";
		default:
			throw new Error("Unknown id: $this->id");
		}
	}
}

class IniParser {
	private $path;
	private $data;
	private $state = Ini::STATE_INITIAL;
	private $line = 1;
	private $pos = 0;
	private $end;
	private $lineEnding;
	function __construct($path)
	{
		 \Makeme\File\checkReadable($path);
		 $contents = @file_get_contents($path);
		 if ($contents === false)
			 throw new Error("failed reading file: $path");
		 $this->path = $path;
		 $this->lineEnding =
			 strpos($contents, "\r\n") !== false ?
				 "\r\n" :
				 "\n";
		 $this->data = preg_replace('/\r\n/', "\n", $contents);
		 $this->end = strlen($this->data);
	}
	function nextToken()
	{
		if ($this->pos == $this->end)
			return false;
		$token = $this->doNextToken();
		return $token;
	}
	function doNextToken()
	{
		switch ($this->state) {
		case Ini::STATE_INITIAL:
			return $this->parseLine();
		case Ini::STATE_VALUE:
		case Ini::STATE_VALUE_DISABLED:
			return $this->parseValue();
		case Ini::STATE_NAME_DISABLED:
			return $this->parseDisabledName();
		default:
			throw new Error("Unknown state; $this->state");
		}
	}
	private function newToken($id, $value, $text)
	{
		return new
			IniToken(
				$id, $value, str_replace("\n", $this->lineEnding, $text)
			);
	}
	function lineEnding()
	{
		return $this->lineEnding;
	}
	private function parseLine()
	{
		static $noticeLen;
		if ($noticeLen === null)
			$noticeLen = strlen(Ini::DIRECTIVE_DISABLED_NOTICE);
		$begin = $this->pos;
		if (!$this->skipSpace())
			return
				$this->newToken(
					Ini::TOKEN_SPACE,
					null,
					substr($this->data, $begin, $this->pos - $begin)
				);
		$id = $value = null;
		$c = $this->data[$this->pos];
		switch ($c) {
		case '[':
			$id = Ini::TOKEN_BLOCK;
			$value = $this->parseIgnoredLine();
			$this->state = Ini::STATE_INITIAL;
			break;
		case ';':
			$notice =
				$begin + $noticeLen < $this->end &&
				substr($this->data, $begin, $noticeLen) ==
					Ini::DIRECTIVE_DISABLED_NOTICE;
			$id = $notice ?
				Ini::TOKEN_DISABLED_NOTICE :
				Ini::TOKEN_COMMENT;
			$value = $this->parseIgnoredLine();
			$this->state = $notice ?
				Ini::STATE_NAME_DISABLED :
				Ini::STATE_INITIAL;
			break;
		default:
			$id = Ini::TOKEN_NAME;
			$value = $this->parseDirectiveName();
			$this->state = Ini::STATE_VALUE;
			break;
		}
		return
			$this->newToken(
				$id, $value, substr($this->data, $begin, $this->pos - $begin)
			);
	}
	private function parseValue()
	{
		$begin = $this->pos;
		$value = '';
		$done = false;
		while ($this->pos < $this->end) {
			if (!$this->skipSpace())
				break;
			$c = $this->data[$this->pos];
			switch ($c) {
			case ';':
				$this->skipComment();
				$done = true;
				break;
			case '"':
				$value .= $this->parseQuote();
				break;
			case '$':
				if ( $this->pos < $this->end - 1 &&
					 $this->data[$this->pos + 1] == '{' )
				{
					$value .= $this->parseReference();
					break;
				}
			default:
				$value .= $this->parsePlainValue();
				break;
			}
		}
		$id = $this->state == Ini::STATE_VALUE ?
			Ini::TOKEN_VALUE :
			Ini::TOKEN_DISABLED_VALUE;
		$this->state = Ini::STATE_INITIAL;
		return
			$this->newToken(
				$id, $value, substr($this->data, $begin, $this->pos - $begin)
			);
	}
	private function parseDisabledName()
	{
		$begin = $this->pos;
		if ($this->data[$this->pos++] != ';')
			throw new
				Error(
					"Failed parsing .ini file '$this->path': " .
					"expected ';' at line $this->line, column 1"
				);
		$value = $this->parseDirectiveName();
		$this->state = Ini::STATE_VALUE_DISABLED;
		return
			$this->newToken(
				Ini::TOKEN_DISABLED_NAME, $value,
				substr($this->data, $begin, $this->pos - $begin)
			);
	}
	private function parseIgnoredLine()
	{
		$result = '';
		$block = $comment = false;
		while ($this->pos < $this->end) {
			$c = $this->data[$this->pos++];
			switch ($c) {
			case '[':
				if (!$block && !$comment)
					$block = true;
				break;
			case ';':
				$comment = true;
				break;
			case ']':
				if (!$comment)
					$block = false;
				break;
			case "\n":
				++$this->line;
				return $result;
			default:
				if ($block)
					$result .= $c;
				break;
			}
		}
		return $result;
	}
	private function parseDirectiveName()
	{
		$result = '';
		while ($this->pos < $this->end) {
			$c = $this->data[$this->pos];
			if (ctype_space($c) || $c == '=') {
				if (!$this->skipSpace() || $this->data[$this->pos] != '=')
					throw new
						Error(
							"Failed parsing .ini file '$this->path': " .
							"expected '=' at line $this->line"
						);
				++$this->pos; // Consume '='
				break;
			}
			$result .= $c;
			++$this->pos;
		}
		return $result;
	}
	private function parsePlainValue()
	{
		$result = '';
		while ($this->pos < $this->end) {
			$c = $this->data[$this->pos];
			switch ($c) {
			case '"':
			case ';':
				return trim($result);
			case '$':
				if ( $this->pos < $this->end - 1 &&
					 $this->data[$this->pos + 1] == '{' )
				{
					return trim($result);
				}
			default:
				if ($c == "\n") {
					return trim($result);
				}
				$result .= $c;
			}
			++$this->pos;
		}
		return trim($result);
	}
	private function parseQuote()
	{
		$result = '';
		++$this->pos; // Assume $this->data[$this->pos] is "
		while ($this->pos < $this->end) {
			$c = $this->data[$this->pos++];
			if ($c == '"')
				return $result;
			if ($c == "\n") {
				++$this->line;
				if ( $this->state ==
						 Ini::STATE_VALUE_DISABLED)
				{
					if ($this->data[$this->pos++] != ';')
						throw new
							Error(
								"Failed parsing .ini file '$this->path': " .
								"expected ';' at line $this->line, column 1"
							);
				}
			}
			$result .= $c;
		}
		throw new
			Error(
				"Failed parsing .ini file '$this->path': unterminated quoted " .
				"string on line $this->line"
			);
	}
	private function parseReference()
	{
		$result = '';
		++$this->pos; // Assume $this->data[$this->pos] is $
		++$this->pos; // Assume $this->data[$this->pos] is {
		while ($this->pos < $this->end) {
			$c = $this->data[$this->pos++];
			if ($c == '}')
				return '${' . trim($result) . '}';
			if ($c == "\n")
				break;
			$result .= $c;
		}
		throw new
			Error(
				"Failed parsing .ini file '$this->path': unterminated ini " .
				"variable reference on line $this->line"
			);
	}
	private function skipSpace()
	{
		while ($this->pos < $this->end) {
			$c = $this->data[$this->pos];
			if ($c == "\n") {
				++$this->pos;
				++$this->line;
				return false;
			}
			if (!ctype_space($c))
				return true;
			++$this->pos;
		}
		return false;
	}
	private function skipComment()
	{
		if ($this->data[$this->pos] != ';')
			return false;
		while ($this->pos < $this->end) {
			$c = $this->data[$this->pos];
			if ($c == "\n")
				break;
			++$this->pos;
		}
		return true;
	}
}
namespace Makeme\Build\Action;

use Makeme\Build\Run;
use Makeme\Error;

class Info implements \Makeme\Build\Action {
	function name() { return 'info'; }
	function checkCommandLine(Run $run)
	{
		$commandLine = $run->commandLine();
		if (sizeof($commandLine->arguments()))
			throw new Error(
						  "Targets cannot be specified with the option --info"
					  );
		$common = \Makeme\Text\split(\Makeme\Build\CommandLine::COMMON_OPTIONS);
		foreach ($commandLine->options() as $opt) {
			if ($opt->hasExplicitValue()) {
				$long = $opt->longForm();
				if ($long != 'info' && !in_array($long, $common))
					throw new
						Error(
							"The option --$long cannot be combined with " .
							"the option --info"
						);
			}
		}
	}
	function requiresProjectConfig(Run $run)
	{
		return false;
	}
	function execute(Run $run)
	{
		echo (string) $run->buildConfig();
	}
}
namespace Makeme\Build\Action;

use Makeme\Build\Run;
use Makeme\Error;

class Help implements \Makeme\Build\Action {
	function name() { return 'help'; }
	function checkCommandLine(Run $run)
	{
		$commandLine = $run->commandLine();
		if (sizeof($commandLine->arguments()))
			throw new Error(
						  "Targets cannot be specified with the option --help"
					  );
		foreach ($commandLine->options() as $opt)
			if ($opt->hasExplicitValue() && $opt->longForm() != 'help')
				throw new Error(
							   "The option --help cannot be combined with " .
							   "other options"
						  );
	}
	function requiresProjectConfig(Run $run)
	{
		return false;
	}
	function execute(Run $run)
	{
		echo $run->commandLine()->usage();
	}
}
namespace Makeme\Build\Action;

use Makeme\Build\CommandLine;
use Makeme\Build\Run;
use Makeme\Error;
use function Makeme\Text\split;

class Build implements \Makeme\Build\Action {
	function name() { return 'build'; }
	function checkCommandLine(Run $run)
	{
		$commandLine = $run->commandLine();
		$common = split(CommandLine::COMMON_OPTIONS);
		$config = split(CommandLine::CONFIG_OPTIONS);
		$options = array_merge($common, $config);
		foreach ($commandLine->options() as $opt) {
			if ($opt->hasExplicitValue()) {
				$long = $opt->longForm();
				if ($long != 'build' && !in_array($long, $options))
					throw new
						Error(
							"The option --$long cannot be combined with " .
							"the option --build"
						);
			}
		}
	}
	function requiresProjectConfig(Run $run)
	{
		  return true;
	}
	function execute(Run $run)
	{
		if (\Makeme\File\searchIncludePath('CodeRage.php') === null)
			throw new
				Error(
					'CodeRage tools are not installed. Use the option ' .
					'--install to install CodeRage tools.'
				);
		require_once('CodeRage.php');
		$run->build();
	}
}
namespace Makeme\Build;
interface Target {
	function id();
	function setId($id);
	function dependencies();
	function setDependencies($dependencies);
	function info();
	function setInfo(Info $info);
	function definition();
	function setDefinition(\DOMElement $src);
	function source();
	function setSource($src);
	function execute(Run $run);
}
namespace Makeme\Build;

use DOMElement;
use Throwable;
use Makeme\Log;
use function Makeme\Xml\childElements;
use function Makeme\Xml\firstChildElement;
use function Makeme\Xml\getAttribute;

class TargetSet {
	const STATE_DONE = 0;
	const STATE_NEW_TOOLS = 1;
	const STATE_NEW_TARGETS = 2;
	const STATE_TARGETS_BUILT = 4;
	private $run;
	private $tools = [];
	private $requiredTargets = [];
	private $knownTargets = [];
	private $unparsedTargets = [];
	private $unparsedTargetIds = [];
	private $pendingTargets = [];
	private $builtTargets = [];
	private $failedTargets = [];
	private $frozen = false;
	private $state = self::STATE_DONE;
	function __construct(Run $run, $targets)
	{
		$this->run = $run;
		foreach ($targets as $t)
			$this->requiredTargets[$t] = $t;
	}
	function getTool($class)
	{
		foreach ($this->tools as $t)
			if (strcasecmp(get_class($t), $class) == 0)
				return $t;
		return null;
	}
	function successCount()
	{
		return sizeof($this->builtTargets);
	}
	function failureCount()
	{
		$count = sizeof($this->requiredTargets) + sizeof($this->failedTargets);
		foreach ($this->unparsedTargets as $target) {
			list($elt) = $target;
			if (!$elt->hasAttribute('id'))
				++$count;
		}
		return $count;
	}
	function execute()
	{
		if ($this->run->projectConfig()) {
			$default = new Target\Default_($this->run->projectConfig());
			$default->execute($this->run);
		}
		$config = $this->run->buildConfig();
		$this->processConfigFile(dirname(__FILE__) . '/../project.xml');
		if ($config->systemConfigFile())
			$this->processConfigFile($config->systemConfigFile()->path());
		foreach ($config->additionalConfigFiles() as $file)
			$this->processConfigFile($file->path());
		if ($config->projectConfigFile())
			$this->processConfigFile($config->projectConfigFile()->path());
		$this->frozen = true;
		while ($this->state != self::STATE_DONE) {
			$this->state = self::STATE_DONE;
			$this->parseTargets();
			$this->buildTargets();
		}
		$failures =
			sizeof($this->requiredTargets) + sizeof($this->failedTargets);
		foreach ($this->requiredTargets as $label) {
			$message =
				"Failed building '$label': " .
				( isset($this->unparsedTargetIds[$label]) ?
					  "can't parse target definition" :
					  "target definition missing" );
			$this->run->log()->logError($message);
		}
		foreach ($this->unparsedTargets as $target) {
			list($elt, $baseUri) = $target;
			if (!$elt->hasAttribute('id')) {
				$this->run->log()->logError(
					"Failed building target '$elt->localName' at '$baseUri': " .
					"can't parse target definition"
				);
				++$failures;
			}
		}
		if ($str = $this->run->getStream(Log::INFO)) {
			$message = "Built " . sizeof($this->builtTargets) . " target(s)";
			if ($failures)
				$message .= "; failed building $failures target(s)";
			$str->write($message);
		}
		return $failures == 0;
	}
	public function processConfigFile($path)
	{
		if (pathinfo($path, PATHINFO_EXTENSION) != 'xml')
			return;
		if (file_exists($path))
			$path = realpath($path);
		if ($str = $this->run->getStream(Log::VERBOSE))
			$str->write("Processing configuration file '$path'");
		$dom = \Makeme\Xml\loadDom($path);
		$elt = $dom->documentElement;
		$namespace = NAMESPACE_URI;
		if ($elt->localName == 'config' && $elt->namespaceURI == $namespace) {
			if ( $this->frozen &&
				 ($str = $this->run->getStream(Log::WARNING)) )
			{
				$str->write(
					"Project configuration already generated; ignoring " .
					"configuration at '$path'"
				);
			}
		} elseif ( $elt->localName == 'project' &&
				   $elt->namespaceURI == $namespace )
		{
			foreach (childElements($elt) as $k) {
				if ($k->namespaceURI != $namespace) {
					if ($str = $this->run->getStream(Log::ERROR))
						$str->write(
							"Unexpected element in XML configuration file: " .
							"$elt->namespaceURI:$elt->localName"
						);
				} elseif ($k->localName == 'include') {
					$src = $inc->getAttribute('src');
					$file = \Makeme\File\find($src, dirname($path), false);
					if (!$file) {
						if ($str = $this->run->getStream(Log::WARNING)) {
							$str->write(
								"Missing file '$src' referenced in by " .
								"'include' element in '$path'"
							);
						}
					} else {
						$this->processConfigFile($file);
					}
				} elseif ($k->localName == 'config') {
					if ($this->frozen &&
						($str = $this->run->getStream(Log::WARNING)))
					{
						$str->write(
							"Project configuration already generated; " .
							"ignoring configuration at '$path'"
						);
					}
				} elseif ($k->localName == 'tool') {
					$this->loadTool($k, $path);
				} elseif ($k->localName == 'targets') {
					foreach (childElements($k) as $tgt) {
						$id = getAttribute($tgt, 'id');
						$skip = false;
						if ($id !== null) {
							if ( isset($this->unparsedTargetIds[$id]) ||
								 isset($this->knownTargets[$id]) ||
								 isset($this->pendingTargets[$id]) ||
								 isset($this->builtTargets[$id]) ||
								 isset($this->failedTargets[$id]) )
							{
								$skip = true;
								$this->run->log()->logError(
									"Duplicate target '$id' at '$path'; " .
									"ignoring target definition"
								);
							}
						}
						if (!$skip) {
							$this->unparsedTargets[] = [$tgt, $path];
							if ($id !== null)
								$this->unparsedTargetIds[$id] = 1;
							$this->state |= self::STATE_NEW_TARGETS;
						}
					}
				}
			}
		} else {
			if ($str = $this->run->getStream(Log::ERROR))
				$str->write(
					"Invalid XML configuration file '$path': expected " .
					"'$namespace:config' or '$namespace:project'; found " .
					"'$elt->namespaceURI:$elt->localName'"
				);
		}
		if ($str = $this->run->getStream(Log::DEBUG))
			$str->write("Done processing configuration file '$path'");
	}
	public function addTarget($target)
	{
		if ($str = $this->run->getStream(Log::VERBOSE))
			$str->write('Processing ' . self::printTarget($target, true));
		$wrapper = new TargetSetWrapper($target);
		$id = $wrapper->id();
		if ( isset($this->pendingTargets[$id]) ||
			 isset($this->builtTargets[$id]) ||
			 isset($this->failedTargets[$id]) )
		{
			return;
		}
		$failed = false;
		foreach ($wrapper->dependencies() as $dep) {
			if ( isset($this->pendingTargets[$dep]) ||
				 isset($this->builtTargets[$dep]) )
			{
				continue;
			} elseif (isset($this->failedTargets[$dep])) {
				$failed = true;
				$this->run->log()->logError(
					"Failed building " . self::printTarget($target, true) .
					": failed dependency '$dep'"
				);
			} elseif (isset($this->knownTargets[$dep])) {
				$this->addTarget($this->knownTargets[$dep]);
			} else {
			if ($str = $this->run->getStream(Log::VERBOSE))
				$str->write("Adding dependency '$dep'");
				$this->requiredTargets[$dep] = $dep;
			}
		}

		if ($failed) {
			$this->failedTargets[$id] = $wrapper;
		} else {
			if ($str = $this->run->getStream(Log::VERBOSE))
				$str->write('Queuing ' . self::printTarget($target, true));
			unset($this->requiredTargets[$id]);
			$this->pendingTargets[$id] = $wrapper;
			$this->state |= self::STATE_NEW_TARGETS;
		}
	}
	public function addTool(Tool $tool)
	{
		foreach ($this->tools as $t)
			if (get_class($t) == get_class($tool))
				return;
		if ($str = $this->run->getStream(Log::VERBOSE))
			$str->write('Adding tool ' . get_class($tool));
		$this->tools[] = $tool;
		$this->state |= self::STATE_NEW_TOOLS;
	}
	private function loadTool(DOMElement $elt, $baseUri)
	{
		$class = $elt->getAttribute('class');
		$classPath = getAttribute($elt, 'classPath');
		if ($classPath && !\Makeme\File\isAbsolute($classPath))
			$classPath = dirname($baseUri) . '/' . $classPath;
		$info = ($i = firstChildElement($elt, 'info')) ?
			Info::fromXml($i) :
			new Info;
		if ($str = $this->run->getStream(Log::VERBOSE))
			$str->write(
				"Parsing tool definition '$class' at '$baseUri'"
			);
		try {
			$options =
				[
					'class' => $class,
					'classPath' => $classPath,
					'checkSyntax' => true,
					'php' => $this->run->binaryPath()
				];
			$tool = \Makeme\Util\loadComponent($options);
			$tool->setInfo($info);
			$this->addTool($tool);
		} catch (Throwable $e) {
			if ($str = $this->run->getStream(Log::ERROR)) {
				$str->write(
					"Failed loading tool '$class': $e"
				);
			}
		}
	}
	private function parseTargets()
	{
		if ($str = $this->run->getStream(Log::VERBOSE))
			$str->write('Parsing targets');
		for ($z = sizeof($this->unparsedTargets) - 1; $z != -1; --$z) {
			list($elt, $uri) = $this->unparsedTargets[$z];
			$localName = $elt->localName;
			$namespace = $elt->namespaceURI;
			foreach ($this->tools as $tool) {
				if ($tool->canParse($localName, $namespace)) {
					try {
						$target = $this->parseTarget($tool, $elt, $uri);
						$wrapper = new TargetSetWrapper($target);
						if ($target->id() !== null)
							unset($this->unparsedTargetIds[$target->id()]);
						if ( $target->id() === null ||
							 isset($this->requiredTargets[$target->id()]) )
						{
							$this->addTarget($wrapper);
						} else {
							if ($verb = $this->run->getStream(Log::VERBOSE))
									$verb->write(
										"Adding target '" . $target->id() .
										"' to list of parsed targets"
									);
							$this->knownTargets[$target->id()] = $wrapper;
						}
						array_splice($this->unparsedTargets, $z, 1);
					} catch (Throwable $e) {
						$message =
							"Failed parsing target '$namespace:" .
							"$localName' at '$uri': $e";
						$this->run->log()->logError($message);
					}
				}
			}
		}
	}
	private function parseTarget(Tool $tool, DOMElement $elt, $baseUri)
	{
		if ($str = $this->run->getStream(Log::VERBOSE)) {
			$str->write("Parsing target '$elt->localName' at '$baseUri'");
		} elseif ($str = $this->run->getStream(Log::INFO)) {
			$str->write("Parsing target '$elt->localName'");
		}
		$target = $tool->parseTarget($this->run, $elt, $baseUri);
		$target->setDefinition($elt);
		$target->setSource($baseUri);
		if ($info = firstChildElement($elt, 'info'))
			$target->setInfo(Info::fromXml($info));
		if ($id = $elt->getAttribute('id'))
			$target->setId($id);
		if ($deps = $elt->getAttribute('dependsOn'))
			$target->setDependencies(\Makeme\Text\split($deps));
		return $target;
	}
	private function buildTargets()
	{
		$pending = [];
		foreach ($this->pendingTargets as $t)
			$pending[] = $t;
		$callback = ['Makeme\Build\TargetSet', 'compareTargets'];
		\Makeme\Util\strictPreorderSort($pending, $callback);
		if (sizeof($pending))
			if ($str = $this->run->getStream(Log::VERBOSE))
				$str->write("Analyzing targets");
		for ($z = 0, $n = sizeof($pending); $z < $n; ++$z) {
			$target = $pending[$z];
			$id = $target->id();
			$skip = false;
			foreach ($target->dependencies() as $dep) {
				if (isset($this->failedTargets[$dep])) {
					if ($str = $this->run->getStream(Log::INFO))
						$str->write(
							"Failed building " .
							self::printTarget($target, true) . ": missing " .
							"dependency '$dep'"
						);
					unset($this->pendingTargets[$id]);
					$this->failedTargets[$id] = $target;
					$skip = true;
					break;
				} elseif (!isset($this->builtTargets[$dep])) {
					$skip = true;
					break;
				}
			}
			if ($skip)
				continue;
			try {
				if ($str = $this->run->getStream(Log::INFO))
					$str->write("Building " . self::printTarget($target, false));
				$target->execute($this->run);
				$this->builtTargets[$id] = $target;
				unset($this->pendingTargets[$id]);
				$this->state |= self::STATE_TARGETS_BUILT;
			} catch (TryAgain $e) {
				if ($str = $this->run->getStream(Log::VERBOSE)) {
					$info = $target->info();
					$label = $info ?
						$info->label() :
						get_class($target);
					$str->write("Scheduling $label to execute again");
				}
			} catch (Throwable $e) {
				$this->failedTargets[$id] = $target;
				unset($this->pendingTargets[$id]);
				$label = self::printTarget($target, true);
				$message =
					"Failed building $label: " .
					( $e instanceof \Makeme\Error ?
						  $e->details() :
						  $e->getMessage() );

				$this->run->log()->logError($message);
			}
		}
	}
	static function compareTargets($lhs, $rhs)
	{
		$rid = $rhs->id();
		foreach ($lhs->dependencies() as $dep)
			if ($dep == $rid)
				return 1;
		$lid = $lhs->id();
		foreach ($rhs->dependencies() as $dep)
			if ($dep == $lid)
				return -1;
		return 0;
	}
	static function printTarget($target, $verbose)
	{
		$label = null;
		if (($info = $target->info()) && $info->label()) {
			$label = "target '" . $info->label() . "'";
		} elseif (($id = $target->id()) && strncmp($id, '__', 2) != 0) {
			$label = "target '" . $target->id() . "'";
		} elseif ($def = $target->definition()) {
			$label = "target of type '$def->localName'";
		} else {
			$label = 'unnamed target';
		}
		if ($verbose && $target->source())
			$label .= " at '" . $target->source() . "'";
		return $label;
	}
}
class TargetSetWrapper implements Target {
	private $target;
	private $id;
	function __construct(Target $target)
	{
		$this->target = $target;
		$id = $target->id();
		$this->id = $id !== null ? $id : self::nextId();
	}
	function id()
	{
		return $this->id;
	}
	function setId($id) { $this->id = $id; }
	function dependencies()
	{
		return $this->target->dependencies();
	}
	function setDependencies($dependencies)
	{
		$this->target->setDependencies($dependencies);
	}
	function info()
	{
		return $this->target->info();
	}
	function setInfo(Info $info)
	{
		$this->target->setInfo($info);
	}
	function definition()
	{
		return $this->target->definition();
	}
	function setDefinition(DOMElement $definition)
	{
		$this->target->setDefinition($definition);
	}
	function source()
	{
		return $this->target->source();
	}
	function setSource($src)
	{
		$this->target->setSource($src);
	}
	function execute(Run $run)
	{
		$this->target->execute($run);
	}

	function __toString()
	{
		return $target->id() !== null ? $target->id() : get_class($target);
	}
	private static function nextId()
	{
		static $next = 0;
		return '__' . ++$next;
	}
}
namespace Makeme\Util;
function preorderSort(&$items, $callback)
{
	$size = sizeof($items);
	$pairs = [];       // Defines a <= relation
	$byFirst = [];     // Maps an index i to the list of j with i <= j
	$bySecond = [];    // Maps an index i to the list of j with j <= i
	for ($a = 0; $a < $size; ++$a) {
		_preorderSortAddPair( $a, $a, $pairs,
									   $byFirst, $bySecond );
		for ($b = 0; $b < $size; ++$b) {
			$cmp =
				call_user_func_array( $callback,
									  [$items[$a], $items[$b]] );
			if ($cmp)
				_preorderSortAddPair( $a, $b, $pairs,
											   $byFirst, $bySecond );
		}
	}
	$stop = false;
	while (!$stop) {
		$stop = true;
		foreach ($pairs as $p) {
			list($b, $c) = $p;
			if (isset($byFirst[$c])) {
				foreach ($byFirst[$c] as $d) {
					if (array_search([$b, $d], $pairs) !== false)
						continue;
					$stop = false;
					_preorderSortAddPair( $b, $d, $pairs,
												   $byFirst, $bySecond );
				}
				foreach ($bySecond[$b] as $a) {
					if (array_search([$a, $c], $pairs) !== false)
						continue;
					$stop = false;
					_preorderSortAddPair( $a, $c, $pairs,
												   $byFirst, $bySecond );
				}
			}
		}
	}
	$order = [];
	for ($z = 0; $z < $size; ++$z) {
		$found = false;
		for ($w = 0, $n = sizeof($order); $w < $n; ++$w) {
			if (array_search([$z, $order[$w]], $pairs) !== false) {
				array_splice($order, $w, 0, $z);
				$found = true;
				break;
			}
		}
		if (!$found)
			$order[] = $z;
	}
	$temp = [];
	for ($z = 0; $z < $size; ++$z)
		$temp[$z] = $items[$order[$z]];
	for ($z = 0; $z < $size; ++$z)
		$items[$z] = $temp[$z];
}
function strictPreorderSort(&$items, $callback)
{
	$size = sizeof($items);
	$pairs = [];       // Defines a <= relation
	$byFirst = [];     // Maps an index i to the list of j with i <= j
	$bySecond = [];    // Maps an index i to the list of j with j <= i
	for ($a = 0; $a < $size; ++$a) {
		for ($b = 0; $b < $size; ++$b) {
			$cmp =
				call_user_func_array( $callback,
									  [$items[$a], $items[$b]] );
			if ($cmp === null)
				continue;
			if ($cmp < 0) {
				_preorderSortAddPair( $a, $b, $pairs,
											   $byFirst, $bySecond );
			} elseif ($cmp > 0) {
				_preorderSortAddPair( $b, $a, $pairs,
											   $byFirst, $bySecond );
			} else {
				_preorderSortAddPair( $a, $b, $pairs,
											   $byFirst, $bySecond );
				_preorderSortAddPair( $b, $a, $pairs,
											   $byFirst, $bySecond );
			}
		}
	}
	$stop = false;
	while (!$stop) {
		$stop = true;
		foreach ($pairs as $p) {
			list($b, $c) = $p;
			if (isset($byFirst[$c])) {
				foreach ($byFirst[$c] as $d) {
					if (array_search([$b, $d], $pairs) !== false)
						continue;
					$stop = false;
					_preorderSortAddPair( $b, $d, $pairs,
												   $byFirst, $bySecond );
				}
			}
			if (isset($bySecond[$b])) {
				foreach ($bySecond[$b] as $a) {
					if (array_search([$a, $c], $pairs) !== false)
						continue;
					$stop = false;
					_preorderSortAddPair( $a, $c, $pairs,
												   $byFirst, $bySecond );
				}
			}
		}
	}
	$order = [];
	for ($z = 0; $z < $size; ++$z) {
		$found = false;
		for ($w = 0, $n = sizeof($order); $w < $n; ++$w) {
			if (array_search([$z, $order[$w]], $pairs) !== false) {
				array_splice($order, $w, 0, $z);
				$found = true;
				break;
			}
		}
		if (!$found)
			$order[] = $z;
	}
	$temp = [];
	for ($z = 0; $z < $size; ++$z)
		$temp[$z] = $items[$order[$z]];
	for ($z = 0; $z < $size; ++$z)
		$items[$z] = $temp[$z];
}

function _preorderSortAddPair($a, $b, &$pairs, &$byFirst, &$bySecond)
{
	$p = [$a, $b];
	if (array_search($p, $pairs) !== false)
		return;
	$pairs[] = $p;
	if (!isset($byFirst[$a]))
		$byFirst[$a] = [];
	$byFirst[$a][] = $b;
	if (!isset($bySecond[$b]))
		$bySecond[$b] = [];
	$bySecond[$b][] = $a;
}
namespace Makeme\Build\Target;

abstract class Basic implements \Makeme\Build\Target {
	private $id;
	private $dependencies;
	private $info;
	private $definition;
	private $src;
	function __construct($id = null, $dependencies = [], $info = null,
		$definition = null, $src = null)
	{
		$this->id = $id;
		$this->dependencies = $dependencies;
		$this->info = $info;
		$this->definition = $definition;
		$this->src = $src;
	}
	function id() { return $this->id; }
	function setId($id) { $this->id = $id; }
	function dependencies() { return $this->dependencies; }
	function setDependencies($dependencies)
	{
		$this->dependencies = $dependencies;
	}
	function info()
	{
		return $this->info;
	}
	function setInfo(\Makeme\Build\Info $info)
	{
		$this->info = $info;
	}
	function definition()
	{
		return $this->definition;
	}
	function setDefinition(\DOMElement $definition)
	{
		$this->definition = $definition;
	}
	function source()
	{
		return $this->src;
	}
	function setSource($src)
	{
		$this->src = $src;
	}
}
namespace Makeme\Build\Target;

use Exception;
use Makeme\Build\Run;
use Makeme\Error;
use function Makeme\File\mkdir;
use Makeme\Log;
use Makeme\Util\ErrorHandler;

class Default_ extends Basic {
	const WEBSERVER_ROOT = 'www';
	const PUBLIC_DIRECTORY_NAME = '__www__';
	function __construct(\Makeme\Build\ProjectConfig $config)
	{
		parent::__construct('__default');
	}
	function info()
	{
		return new
			\Makeme\Build\Info([
				'label' => 'Default Target',
				'description' =>
					'Target added automatically to projects whose ' .
					'primary configuration file is not XML'
			]);
	}
	function execute(Run $run)
	{
		if ($str = $run->getStream(Log::INFO))
			$str->write('Copying public files to web server root');
		$toolsRoot = $run->buildConfig()->toolsPath();
		$projectRoot = $run->projectRoot();
		$pub =
			($prop = $run->projectConfig()->lookupProperty('public_directory'))
				? $prop->value()
				: self::WEBSERVER_ROOT;
		$pairs = []; // List of ($src, $dest) pairs
		$debug = $run->getStream(Log::DEBUG);
		$handler = new ErrorHandler;
		$stack = [["$toolsRoot/CodeRage", "$projectRoot/$pub/CodeRage"]];
		while (sizeof($stack)) {
			list($src, $dest) = array_pop($stack);
			if ($debug)
				$debug->write("Processing pair ('$src','$dest')");
			$dir = $handler->_opendir($src);
			if ($handler->errno())
				throw new
					Error(
						$handler->formatError(
							 'Failed copying public files to web server root'
						)
					);
			if ($debug)
				$debug->write("Reading directory '$src'");
			while (($file = $handler->_readdir($dir)) !== false) {
				if ($debug)
					$debug->write("Processing entry '$file'");
				if ($handler->errno())
					throw new
						Error(
							$handler->formatError(
								 'Failed copying public files to web server ' .
								 'root'
							)
						);
				if ($file == '.' || $file == '..')
					continue;
				$src2 = "$src/$file";
				$dest2 = "$dest/$file";
				if (is_file($src2))
					continue;
				if ($file == self::PUBLIC_DIRECTORY_NAME) {
					$this->copyDirectory($run, $handler, $src2, $dest);
				} else {
					if ($debug)
						$debug->write(
							"Adding pair ('$src2','$dest2') to stack"
						);
					$stack[] = [$src2, $dest2];
				}
			}
			$handler->_closedir($dir);
		}
	}
	private function copyDirectory(Run $run,
		ErrorHandler $handler, $src, $dest)
	{
		$debug = $run->getStream(Log::DEBUG);
		if ($debug)
			$debug->write("Copying directory '$src' to '$dest'");
		$handler = new ErrorHandler;
		$stack = [[$src, $dest]];
		while (sizeof($stack)) {
			list ($s, $d) = array_pop($stack);
			if ($debug)
				$debug->write("Processing pair ('$s','$d')");
			$dir = $handler->_opendir($s);
			if ($handler->errno())
				throw new
					Exception(
						$handler->formatError(
							'Failed copying public files to web server root'
						)
					);
			if ($debug)
				$debug->write("Reading directory '$s'");
			while (($f = $handler->_readdir($dir)) !== false) {
				if ($debug)
					$debug->write("Processing entry '$f'");
				if ($handler->errno())
					throw new
						Exception(
							$handler->formatError(
								'Failed copying public files to web server root'
							)
						);
				if ($f == '.' || $f == '..')
					continue;
				$s2 = "$s/$f";
				$d2 = "$d/$f";
				if (is_file($s2)) {
					if (is_dir($d2))
						throw new
							Exception(
								"Failed copying public files to web server " .
								"root: '$d2' is a directory"
							);
					mkdir(dirname($d2), 0755);
					\Makeme\File\copy($s2, $d2);
					$run->recordGeneratedFile($d2);
				} else {
					if ($debug)
						$debug->write("Creating directory '$d2'");
					mkdir(dirname($d2), 0755);
					if (is_file($d2) || is_link($d2))
						throw new
							Exception(
								"Failed copying public files to web server " .
								"root: '$d2' is not a directory"
							);
					$stack[] = [$s2, $d2];
				}
			}
			$handler->_closedir($s);
		}
	}
}
namespace Makeme\File;

use Exception;

function copy($src, $dest)
{
	$handler = new \Makeme\Util\ErrorHandler;
	if (is_file($src)) {
		if (is_dir($dest))
			throw new
				Exception(
					"Failed copying '$src' to '$dest': the file " .
					"'$dest' is a directory"
				);
		$dir = $handler->_copy($src, $dest);
		if ($handler->errno())
			throw new
				Exception(
					$handler->formatError(
						"Failed copying '$src' to '$dest'"
					)
				);
		$perm = fileperms($src);
		$dir = $handler->_chmod($dest, $perm);
		if ($handler->errno())
			throw new
				Exception(
					$handler->formatError(
						"Failed setting file permissions '$src' to " .
						sprintf("%o", $perm)
					)
				);
		return;
	}
	$stack = [[$src, $dest]];
	while (sizeof($stack)) {
		list ($s, $d) = array_pop($stack);
		$dir = $handler->_opendir($s);
		if ($handler->errno())
			throw new
				Exception(
					$handler->formatError("Failed copying '$src' to '$dest'")
				);
		while (($f == $handler->_readdir($dir)) !== false) {
			if ($handler->errno())
				throw new
					Exception(
						$handler->formatError(
							"Failed copying '$src' to '$dest'"
						)
					);
			if ($f == '.' || $f == '..')
				continue;
			$s2 = "$s/$f";
			$d2 = "$d/$f";
			if (is_file($s2)) {
				if (is_dir($d2))
					throw new
						Exception(
							"Failed copying '$src' to '$dest': the file " .
							"'$d2' is a directory"
						);
				$handler->_copy($s2, $d2);
				$perm = fileperms($s2);
				$dir = $handler->_chmod($d2, $perm);
				if ($handler->errno())
					throw new
						Exception(
							$handler->formatError(
								"Failed setting file permissions '$s2' to " .
								sprintf("%o", $perm)
							)
						);
			} else {
				if (!is_dir($d2))
					throw new
						Exception(
							"Failed copying '$src' to '$dest': the file " .
							"'$d2' is not a directory"
						);
				$stack[] = [$s2, $d2];
			}
		}
		$handler->_closedir($s);
	}
}
namespace Makeme\Build\Target;

use Makeme\Build\Run;

abstract class MultiPhase extends Basic {
	private $phase = 1;
	function __construct($id = null, $dependencies = [], $info = null)
	{
		parent::__construct($id, $dependencies, $info);
	}
	function execute(Run $run)
	{
		$current = 'phase' . $this->phase;
		$next = 'phase' . ++$this->phase;
		$this->$current($run);
		if (method_exists($this, $next))
			throw new \Makeme\Build\TryAgain;
	}
	protected abstract function phase1(Run $run);
}
namespace Makeme\Build;
class TryAgain extends \Exception { }
namespace Makeme\Build\Packages\Perl;

use Makeme\Error;
use function Makeme\File\rm;
use Makeme\Log;
use Makeme\Util\RegexCommandRunner;
use function Makeme\Util\escapeExecutable;
use function Makeme\Util\os;

class Manager extends \Makeme\Build\Packages\Manager {
	const PPM_REPEATS = 4;
	const CPAN_TIMEOUT = 1200;
	function __construct(\Makeme\Build\Run $run)
	{
		parent::__construct($run);
	}
	function name() { return 'perl'; }
	function libraryFileExtension()
	{
		return 'pm';
	}
	function versionCompare($lhs, $rhs)
	{
		if (!preg_match('/^[0-9]+(\.[0-9]+)*(_[0-9]+)?$/', $lhs))
			throw new Error("Invalid version string '$lhs'");
		if (!preg_match('/^[0-9]+(\.[0-9]+)*(_[0-9]+)$/', $rhs))
			throw new Error("Invalid version string '$rhs'");
		$lParts = explode('.', $lhs);
		$rParts = explode('.', $rhs);
		$length = sizeof($lParts);
		if ($length != sizeof($rParts))
			return null;
		$numeric = $length == 2;
		if (strpos($lParts[$length - 1], '_') !== false)
			foreach (explode('_', array_pop($lParts)) as $p)
				$lParts[] = $p;
		if (strpos($rParts[$length - 1], '_') !== false)
			foreach (explode('_', array_pop($rParts)) as $p)
				$rParts[] = $p;
		for ($z = 0, $n = sizeof($lParts); $z < $n; ++$z) {
			$l = $lParts[$z];
			$r = $rParts[$z];
			if ($numeric && $z > 0) {
				if (floatval(".$l") < floatval(".$r"))
					return -1;
				if (floatval(".$r") < floatval(".$l"))
					return 1;
			} else {
				if (intval($l) < intval($r))
					return -1;
				if (intval($r) < intval($l))
					return 1;
			}
		}
		return sizeof($lParts) < sizeof($rParts) ?
			-1 :
			( sizeof($rParts) < sizeof($lParts) ?
				  1 :
				  0 );
	}
	function lookupConfigurations(array $properties = [])
	{
		$search = isset($properties['binaryPath']) ?
			$properties['binaryPath'] :
			null;
		$programs = \Makeme\File\findExecutable('perl', $search);
		$configs = [];
		foreach ($programs as $p) {
			$version = $this->runCommand($this->configCommand($p, 'version'));
			if (!preg_match('/^"[0-9]+(\.[0-9]+)*"$/', $version))
				throw new
					Error(
						"Failed determining Perl version for '$p'"
					);
			$tooLow = $tooHigh = false;
			if (isset($properties['minVersion'])) {
				$min = $properties['minVersion'];
				$tooLow = version_compare($version, $min) < 0;
			}
			if (isset($properties['maxVersion'])) {
				$max = $properties['maxVersion'];
				$tooHigh = $this->versionCompare($max, $version) < 0;
			}
			if ($tooLow || $tooHigh)
				continue;
			$configs[] =
				new Configuration(
						$this, $version, $p
					);
		}

		return $configs;
	}
	function configurationId(\Makeme\Build\Packages\Configuration $config)
	{
		return $config->binaryPath();
	}
	function lookupChannels(\Makeme\Build\Packages\Configuration $config)
	{
		return [];
	}
	function lookupPackages(
		\Makeme\Build\Packages\Configuration $config, array $properties = [])
	{
		if ( !isset($properties['name']) &&
			 ( isset($properties['minVersion']) ||
			   isset($properties['maxVersion']) ) )
		{
			throw new
				Error(
					"Inconsistent properties provided to " .
					"Makeme\Build\Packages\Perl\Manager::lookupPackages(): " .
					"'minVersion' or 'maxVersion' specified without 'name'"
				);
		}
		$output = null;
		if (os() == 'windows') {
			$output = $config->runCommand('-MCPAN -e autobundle');
		} else {
			$runner =
				new RegexCommandRunner([
						'requiresResponse' => '/\[.*?\][ \t]*$/',
						'defaultResponse' => "\n",
						'quiet' => false,
						'timeout' => self::CPAN_TIMEOUT
					]);
			$runner->addResponseRule(
				'/^Are you ready for manual configuration\? \[yes\] /m',
				"no\n"
			);
			$command =
				escapeExecutable($config->binaryPath()) .
				' -MCPAN -e autobundle';
			ob_start();
			$status = $runner->run($command);
			$output = ob_get_contents();
			ob_end_clean();
			if ($status)
				throw new
					Error(
						"Exit status $status returned by command '$command'"
					);
		}
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write("Autobundle output: $output");
		$match = null;
		if (!preg_match('/^Package\s+namespace/im', $output, $match))
			throw new Error("Can't parse autobundle output");
		preg_match_all(
			'/^((?:::|[_a-zA-Z0-9])+)\s+(undef|[0-9.]+)/m',
			$output,
			$match,
			PREG_SET_ORDER,
			sizeof($match[0])
		);
		$perl = $config->binaryPath();
		$packages = [];
		foreach ($match as $m) {
			$name = $m[1];
			$version = $m[2] != 'undef' ? $m[2] : null;
			if (isset($properties['name']) && $properties['name'] != $name)
				continue;
			$tooLow = $tooHigh = false;
			if (isset($properties['minVersion'])) {
				$min = $properties['minVersion'];
				$comp = $this->versionCompare($version, $min);
				if ($comp === null)
					throw new
						Error(
							"Can't compare version strings '$version' " .
							"and '$min'"
						);
				$tooLow = $comp < 0;
			}
			if (isset($properties['maxVersion'])) {
				$max = $properties['maxVersion'];
				$comp = $this->versionCompare($max, $version);
				if ($comp === null)
					throw new
						Error(
							"Can't compare version strings '$version' " .
							"and '$max'"
						);
				$tooHigh = $comp < 0;
			}
			if ($tooLow || $tooHigh)
				continue;
			$packages[] = new \Makeme\Build\Packages\Package($name, $version);
		}

		return $packages;
	}
	function installPackage(
		\Makeme\Build\Packages\Configuration $config, $name,
		array $properties = [] )
	{
		$match = null;
		if ( !preg_match('/^([_a-z0-9]+)(::[_a-z0-9]+)*$/i', $name, $match) ||
			 $match[1] == 'Bundle' )
		{
			throw new Error("Invalid module name: $name");
		}
		$search = $properties;
		$search['name'] = $name;
		if (sizeof($this->lookupPackages($config, $search)))
			return false;
		if (isset($properties['maxVersion'])) {
			$relaxed = $search;
			unset($relaxed['maxVersion']);
			if (sizeof($packages = $this->lookupPackages($config, $relaxed))) {
				$installed = $packages[0]->version();
				throw new
					Error(
						"Failed installing package '$name' with 'maxVersion' " .
						"{$properties['maxVersion']}: installed version " .
						"'$installed' is too new"
					);
			}
		}
		$upgrade = false;
		if (isset($properties['minVersion'])) {
			$relaxed = $search;
			unset($relaxed['minVersion']);
			$upgrade = sizeof($this->lookupPackages($config, $relaxed)) > 0;
		}

		return $config->ppmPath() ?
			 $this->ppmInstall($config, $name, $properties) :
			 $this->cpanInstall($config, $name, $properties);
	}
	function installLocalPackage(
		\Makeme\Build\Packages\Configuration $config, $paths, $overwrite = true)
	{
		$sitelib = $this->getConfigurationProperty($config, 'sitelib');
		if (!file_exists($sitelib) && !\Makeme\File\mkdir($sitelib))
			throw new
				Error("Failed creating local package directory '$sitelib'");
		$copied = [];
		foreach ($paths as $p) {
			$dest = $sitelib . '/' . basename($p);
			$exists = file_exists($dest);
			if (file_exists($dest) && !$overwrite) {
				foreach ($copied as $c)
					rm($c);
				throw new Error("The file '$dest' already exists");
			}
			$handler = new \Makeme\Util\ErrorHandler;
			if (!$handler->_copy($p, $dest)) {
				foreach ($copied as $c)
					rm($c);
				throw new
					Error(
						$handler->formatError(
							"Failed copying '$p' already exists"
						)
					);
			}
			if ( is_file($p) &&
				 !$this->inLibrarySearchPath($config, basename($p)) )
			{
				foreach ($copied as $c)
					rm($c);
				throw new
					Error("Failed adding '$p' to library search path");
			}
			$copied[] = $dest;
		}
		return sizeof($copied);
	}
	function uninstallLocalPackage(
		\Makeme\Build\Packages\Configuration $config, $paths)
	{
		$sitelib = $this->getConfigurationProperty($config, 'sitelib');
		$removed = [];
		$failed = [];
		foreach ($paths as $p) {
			$file = $sitelib . '/' . basename($p);
			if (file_exists($file)) {
				if (rm($file))
					$removed[] = $file;
				else
					$failed[] = $file;
			}
		}
		if (sizeof($failed))
			throw new
				Error('Failed removing files ' . join(', ', $failed));
		return sizeof($removed);
	}
	function inLibrarySearchPath(
		\Makeme\Build\Packages\Configuration $config, $path)
	{
		$path = addcslashes($path, "'");
		$code =
			"eval { require('$path') }; " .
			"if ($@) { print 0 } else { print 1 }";
		$command = "-e " . \Makeme\Util\escapeShellArg($code);
		return (bool) $config->runCommand($command);
	}
	function getConfigurationProperty(
		\Makeme\Build\Packages\Configuration $config, $name)
	{
		$output = null;
		try {
			$command = $this->configCommand($config->binaryPath(), $name);
			$output = $this->runCommand($command);
		} catch (\Throwable $e) {
			throw new
				Error(
					"Failed getting configuration property '$name': " .
					$e->getMessage()
				);
		}
		if ( $output &&
			 ($output[0] != '"' || $output[strlen($output) - 1] != '"') )
		{
			Error(
				"Failed getting configuration property '$name': invalid " .
				"output: $output"
			);
		}
		return $output ?
			substr($output, 1, strlen($output) - 2) :
			null;
	}
	private function configCommand($binaryPath, $name)
	{
		if (!preg_match('/^[_a-zA-Z][_a-zA-Z0-9]*$/', $name))
			throw new Error("Invalid configuration property: $name");
		$oq = os() == 'posix' ? "'" : '"'; // Outer quote
		$iq = os() == 'posix' ? '"' : "'"; // Inner quote
		return
			"$binaryPath -MConfig -e{$oq}if (exists(\$Config{{$name}})) " .
			"{print $iq\\\"$iq . \$Config{{$name}} . $iq\\\"$iq;}$oq";
	}
	private function ppmInstall(
		$config, $name, $properties,
		$repeats = self::PPM_REPEATS )
	{
		$ppm = $config->ppmPath();
		$esc =  escapeExecutable($ppm);
		$output = $this->runCommand("$esc search $name");
		$match = null;
		$hits =
			preg_match_all(
				'/^[ \t]*([0-9]+): ([-_a-z0-9]+)\r?\n([ \t]*\D[^\n]+\r?\n)*/im',
				$output,
				$match
			);
		$package = $version = null;
		if ($hits = substr_count($output, "\n")) {
			foreach ($match[1] as $index) {
				$output = $this->runCommand("$esc describe $index");
				$package = $this->checkPpmSearch($output, $name, $properties);
				if ($package)
					break;
			}
			if ( !$package &&
				 ( isset($properies['minVersion']) ||
				   isset($properies['maxVersion']) ) )
			{
				$relax = $properties;
				unset($properies['minVersion']);
				unset($properies['maxVersion']);
				foreach ($match[1] as $index) {
					$output = $this->runCommand("$esc describe $index");
					$package = $this->checkPpmSearch($output, $name, $relax);
					if ($package)
						break;
				}
				if ($package) {
					$package = null;

				} else {
					return
						$this->ppmInstall(
							$config, $name, $properties, --$repeats
						);
				}
			}

		} else {
			foreach ($match[0] as $result) {
				$package = $this->checkPpmSearch($result, $name, $properties);
				if ($package)
					break;
			}
		}
		if (!$package) {
			$hasMin = isset($properies['minVersion']);
			$hasMax = isset($properies['maxVersion']);
			throw new
				Error(
					"Failed installing module '$name': module not available" .
					( $hasMin || $hasMax ? ' with' : '' ) .
					( $hasMin ?
						  " version >= '{$properies['minVersion']}'" :
						  '' ) .
					( $hasMin && $hasMax ? ' and' : '' ) .
					( $hasMax ?
						  " version <= '{$properies['maxVersion']}'" :
						  '' )
				);
		}
		$package = escapeshellarg($package);
		$output = $this->runCommand("$esc install $package");
		if (stripos($output, 'install failed') !== false)
			throw new Error("Failed installing package '$name'");
	}
	private function checkPpmSearch($output, $name, $properties)
	{
		$match = null;
		$quote = preg_quote($name);
		if ( !preg_match(
				 '/^[ \t]*Provide: $name version ([0-9]+(\.[0-9]+)*)/m',
				 $output,
				 $match ) )
		{
			return null;
		}
		$version = $match[1];
		$tooLow = $tooHigh = false;
		if (isset($properties['minVersion'])) {
			$min = $properties['minVersion'];
			$comp = $this->versionCompare($version, $min);
			if ($comp === null)
				throw new
					Error(
						"Can't compare version strings '$version' " .
						"and '$min'"
					);
			$tooLow = $comp < 0;
		}
		if (isset($properties['maxVersion'])) {
			$max = $properties['maxVersion'];
			$comp = $this->versionCompare($max, $version);
			if ($comp === null)
				throw new
					Error(
						"Can't compare version strings '$version' " .
						"and '$max'"
					);
			$tooHigh = $comp < 0;
		}
		if ($tooLow || $tooHigh)
			return null;
		if (!preg_match('/^[ \t]*[0-9]+: (\S+)/', $output, $match))
			throw new Error("Failed parsing ppm output: $output");
		return $match[1];
	}
	private function cpanInstall($config, $name, $properties)
	{
		if ($str = $this->log()->getStream(Log::INFO))
			$str->write("This could take a long time");
		$runner =
			new RegexCommandRunner([
					'requiresResponse' => '/\[.*?\][ \t]*$/',
					'defaultResponse' => "\n",
					'quiet' => false,
					'timeout' => self::CPAN_TIMEOUT
				]);
		$id = isset($properties['cpan-tarball']) ?
			$properties['cpan-tarball'] :
			$name;
		$command =
			escapeExecutable($config->binaryPath()) .
			" -MCPAN -e 'CPAN::Shell->";
		if ( isset($properties['force']) &&
			 ( $properties['force'] == '1' ||
			   $properties['force'] == 'true' ) )
		{
			$command .= "force(\"install\", \"$id\");'";
		} else {
			$command .= "install(\"$id\");'";
		}
		$env =
			[
				'PATH' => getenv('PATH'),
				'PERL_MM_USE_DEFAUT' => 1,
				'HOME' => getcwd()
			];
		$status = $runner->run($command, null, $env);
		if ($status)
			throw new
				Error(
					"Exit status $status returned by command '$command'"
				);
		$properties['name'] = $name;
		if (sizeof($this->lookupPackages($config, $properties)) == 0)
			throw new Error("Failed installing package '$name'");
	}
}
namespace Makeme\Util;

use Makeme\Error;

abstract class CommandRunner {
const CACHE_SIZE = 20;
const MAX_REPEATS = 100;
const LINE_LENGTH = 1024;
const OBFUSCATED_RESPONSE = '<hidden>';

					/*
					 * Member variables set at construction
					 */
	private $quiet;
	private $cacheSize;
	private $timeout;
	private $noOutputTimeout;
	private $noInputTimeout;
	private $maxRepeats;
	private $errorQuiet;

					/*
					 * Member variables specific to a command execution
					 */
	private $command;
	private $log;
	private $errorLog;
	private $output;
	private $errorOutput;
	private $elapsed;
	private $elapsedNoOutput;
	private $elapsedNoInput;
	private $lastRequest;
	private $repeatCount;
	private $process;
	private $pipes;
	protected function __construct(
		$quiet = null, $cacheSize = null, $timeout = null,
		$noOutputTimeout = null, $noInputTimeout = null,
		$maxRepeats = null, $errorQuiet = null )
	{
		static $defaults = null;
		if (!$defaults) {
			$defaults =
				[
					'quiet' => false,
					'cacheSize' => CommandRunner::CACHE_SIZE,
					'timeout' => null,
					'noOutputTimeout' => null,
					'noInputTimeout' => null,
					'maxRepeats' => CommandRunner::MAX_REPEATS,
					'errorQuiet' => null
				];
		}
		$params = is_array($quiet) ?
			$quiet :
			[
				'quiet' => $quiet,
				'cacheSize' => $cacheSize,
				'timeout' => $timeout,
				'noOutputTimeout' => $noOutputTimeout,
				'noInputTimeout' => $noInputTimeout,
				'maxRepeats' => $maxRepeats,
				'errorQuiet' => $errorQuiet
			];
		$params += $defaults;
		foreach ($params as $n => $v)
			$this->$n = $v;
	}

					/*
					 * Public operations
					 */
	function run(
		$command, $cwd = null, $env = null, $logFile = null,
		$errorLogFile = null )
	{
		try {
			return
				$this->runImpl($command, $cwd, $env, $logFile, $errorLogFile);
		} catch (\Throwable $e) {
			$this->cleanup();
			throw new
				Error(
					"Failed executing command '$command': " . $e->getMessage()
				);
		}
	}

					/*
					 * Overrideable methods
					 */
	protected abstract function requiresResponse($output, $source);
	protected abstract function generateResponse($output, $source);
	protected abstract function checkForErrors($output, $source);
	protected function updateCommand(&$command) { }

					/*
					 * Private methods
					 */
	function runImpl(
		$command, $cwd = null, $env = null, $logFile = null,
		$errorLogFile = null )
	{
		$this->command = $command;
		$this->log = null;
		if ($logFile) {
			$this->log = fopen($logFile, 'w');
			if (!$this->log)
				throw new Error("Failed opening '$logFile'");
		}
		$this->errorLog = null;
		if ($errorLogFile) {
			$this->errorLog = fopen($errorLogFile, 'w');
			if (!$this->errorLog)
				throw new Error("Failed opening '$errorLogFile'");
		}
		$this->output =
			$this->errorOutput = '';
		$this->elapsed =
			$this->elapsedNoOutput =
			$this->elapsedNoInput = 0.0;
		$this->lastRequest = null;
		$this->repeatCount = 0;
		$this->startProcess($cwd, $env);
		$exitcode = null;
		while (true) {
			$read = [$this->pipes[1], $this->pipes[2]];
			$write = [];
			$except = [$this->pipes[1], $this->pipes[2]];
			$begin = microtime(true);
			if (@stream_select($read, $write, $except, 1) === false)
				throw new Error('stream_select() failed');
			$end = microtime(true);
			$this->elapsed += $end - $begin;
			$this->elapsedNoInput += $end - $begin;
			if (sizeof($read) == 0) {
				$this->elapsedNoOutput += $end - $begin;
			} else {
				$this->elapsedNoOutput = 0;
			}
			if (sizeof($except))
				throw new Error('received out-of-band data');
			if (in_array($this->pipes[2], $read))
				$this->processOutput(2);
			if (in_array($this->pipes[1], $read))
				$this->processOutput(1);
			$this->checkTimeouts();

			$status = proc_get_status($this->process);
			if ($status === false)
				throw new Error('Failed querying process status');
			if (!$status['running']) {
				$exitcode = $status['exitcode'];
				break;
			}
		}
		$this->cleanup();

		return $exitcode;
	}
	private function startProcess($cwd, $env)
	{
		$this->pipes = [];
		$spec =
			[
			   0 => ["pipe", "r"],
			   1 => ["pipe", "w"],
			   2 => ["pipe", "w"]
			];
		$options = [];
		if ( os() == 'windows' &&
			 version_compare(phpversion(), '5.2.1') <= 0 )
		{
		}
		$this->process =
			@proc_open(
				$this->command, $spec, $this->pipes, $cwd, $env, $options
			);
		if ( !$this->process ||
			 !stream_set_blocking($this->pipes[0], 0) ||
			 !stream_set_blocking($this->pipes[1], 0) ||
			 !stream_set_blocking($this->pipes[2], 0) )
		{
			throw new Error('proc_open() failed');
		}
	}
	private function processOutput($target)
	{
		$pipe = $this->pipes[$target];
		$output = null;
		if ($target == 1)
			$output =& $this->output;
		else
			$output =& $this->errorOutput;
		$len = CommandRunner::LINE_LENGTH;
		$data = null;
		while (true) {
			if (($data = @fread($pipe, $len)) === false)
				throw new
					Error(
						'Failed reading standard ' .
						($target == 1 ? 'output' : 'error')
					);
			$output .= $data;
			$this->log($data, $target);
			$this->echo($data, $target);
			if (strlen($data) < $len)
				break;
		}
		$lines = preg_split('/\r?\n/', $output);
		if (!$lines[sizeof($lines) - 1])
			array_pop($lines);
		$keep = min(sizeof($lines), $this->cacheSize);
		$output = join("\n", array_slice($lines, -$keep));
		$this->checkForErrors($output, $target);
		$response = null;
		if ($this->requiresResponse($output, $target)) {
			if ($this->lastRequest == $output) {
				++$this->repeatCount;
			} else {
				$this->repeatCount = 0;
			}
			if ($this->repeatCount > $this->maxRepeats)
				throw new
					Error(
						"The process asked for identical user input " .
						"'$output' $this->repeatCount times in a row"
					);
			$this->lastRequest = $output;
			list($response, $obfuscate) =
				$this->generateResponse($output, $target);
			for ($z = 0, $n = strlen($response); $z < $n; ++$z) {
				$read = [];
				$write = [$this->pipes[0]];
				$except = [$this->pipes[0]];
				$begin = microtime(true);
				if (@stream_select($read, $write, $except, 1) === false)
					throw new
						Error(
							'Failed writing to standard input'
						);
				$end = microtime(true);
				if (sizeof($except))
					throw new Error('Failed writing to stanard input');
				$amt = @fwrite($this->pipes[0], substr($response, $z));
				if ($amt === false)
					throw new Error('Failed writing to stanard input');
				$z += $amt;
				$this->elapsed += $end - $begin;
				if ($this->timeout !== null && $this->elapsed > $this->timeout)
					throw new Error('Timeout expired');
			}
			$output .= $response;
			$resp = $obfuscate ?
				CommandRunner::OBFUSCATED_RESPONSE .
					str_repeat("\n", substr_count($response, "\n")) :
				$response;
			$this->log($resp, $target);
			$this->echo($resp, $target);
		}

		return $response !== null;
	}
	private function checkTimeouts()
	{
		if ($this->timeout !== null && $this->elapsed > $this->timeout)
			throw new Error('timeout expired');
		if ( $this->noOutputTimeout !== null &&
			 $this->elapsedNoOutput > $this->noOutputTimeout )
		{
			$seconds = (int) ceil($this->elapsedNoOutput);
			throw new Error("$seconds seconds elapsed with no output");
		}
		if ( $this->noInputTimeout !== null &&
			 $this->elapsedNoInput > $this->noInputTimeout )
		{
			$seconds = (int) ceil($this->elapsedNoInput);
			throw new
				Error(
					"$seconds seconds elapsed with no request for user input"
				);
		}
	}
	private function cleanup($nothrow = true)
	{
		$this->command =
			$this->output =
			$this->errorOutput =
			$this->elapsed =
			$this->elapsedNoOutput =
			$this->elapsedNoInput =
			$this->lastRequest =
			$this->repeatCount = null;
		if (is_resource($file = $this->log)) {
			$this->log = null;
			if (!@fclose($file)) {
				$this->cleanup(true);
				if (!$nothrow)
					throw new Error('Failed closing log');
			}
		}
		if (is_resource($file = $this->errorLog)) {
			$this->log = null;
			if (!@fclose($file)) {
				$this->cleanup(true);
				if (!$nothrow)
					throw new Error('Failed closing error log');
			}
		}
		if ($this->pipes && is_resource($file = $this->pipes[0])) {
			$this->pipes[0] = null;
			if (!@fclose($file)) {
				$this->cleanup(true);
				if (!$nothrow)
					throw new Error('Failed closing standard input');
			}
		}
		if ($this->pipes && is_resource($file = $this->pipes[1])) {
			$this->pipes[1] = null;
			if (!@fclose($file)) {
				$this->cleanup(true);
				if (!$nothrow)
					throw new Error('Failed closing standard output');
			}
		}
		if ($this->pipes && is_resource($file = $this->pipes[2])) {
			$this->pipes[2] = null;
			if (!@fclose($file)) {
				$this->cleanup(true);
				if (!$nothrow)
					throw new Error('Failed closing standard error');
			}
		}
		$this->pipes = null;
		if (is_resource($proc = $this->process)) {
			$this->process = null;
			@proc_close($proc);
		}
	}
	private function log($msg, $target)
	{
		if ($target == 2 && ($log = $this->errorLog)) {
			if (!@fwrite($msg, $data) || !@fflush($file))
				throw new Error('Failed writing to error log');
		} elseif ($file = $this->log) {
			if (!@fwrite($msg, $data) || !@fflush($file))
				throw new Error('Failed writing to log');
		}
	}
	private function echo_($msg, $target)
	{
		if (!$this->quiet && ($target == 1 || $this->errorQuiet !== true))
			echo $msg;
	}
	function __call($method, $args)
	{
		if ($method != 'echo')
			throw new
				Error(
					"No such method: Makeme\\Util\\CommandRunner::$method"
				);
		 if (sizeof($args) < 2)
			throw new
				Error(
					"Makeme\Util\CommandRunner::echo() requires two " .
					"arguments; " . sizeof($args) . " given"
				);
		 return $this->echo_($args[0], $args[1]);
	}
}
class RegexCommandRunner extends CommandRunner {
	private $requiresResponse;
	private $defaultResponse;
	private $responseRules = [];
	private $errorRules = [];
	function __construct(
		$requiresResponse, $defaultResponse = null, $quiet = false,
		$cacheSize = null, $timeout = null, $noOutputTimeout = null,
		$noInputTimeout = null, $maxRepeats = null, $errorQuiet = null  )
	{
		$params = is_array($requiresResponse) ?
			$requiresResponse :
			[
				'requiresResponse' => $requiresResponse,
				'defaultResponse' => $defaultResponse,
				'quiet' => $quiet,
				'cacheSize' => $cacheSize,
				'timeout' => $timeout,
				'noOutputTimeout' => $noOutputTimeout,
				'noInputTimeout' => $noInputTimeout,
				'maxRepeats' => $maxRepeats,
				'errorQuiet' => $errorQuiet
			];
		if (!array_key_exists('requiresResponse', $params))
			throw new Error("Missing required parameter 'requiresResponse'");
		if (!array_key_exists('defaultResponse', $params))
			$params['defaultResponse'] = null;
		$this->requiresResponse = $params['requiresResponse'];
		$this->defaultResponse = $params['defaultResponse'];
		unset($params['requiresResponse']);
		unset($params['defaultResponse']);
		parent::__construct($params);
	}
	function addResponseRule($pattern, $response, $obfuscate = false)
	{
		$this->responseRules[] = [$pattern, $response, $obfuscate];
	}
	function addErrorRule($pattern, $msg)
	{
		$this->errorRules[] = [$pattern, $msg];
	}

					/*
					 * Implementation of abstract methods
					 */
	protected function requiresResponse($output, $source)
	{
		$result = sizeof($output) ?
			preg_match($this->requiresResponse, $output) :
			false;
		return $result;
	}
	protected function generateResponse($output, $source)
	{
		foreach ($this->responseRules as $rule)
			if (preg_match($rule[0], $output))
				return [$rule[1], $rule[2]];
		if ($this->defaultResponse !== null)
			return [$this->defaultResponse, false];
		throw new Error("Unable to generate response to '$output'");
	}
	protected function checkForErrors($output, $source)
	{
		foreach ($this->errorRules as $rule)
			if (preg_match($rule[0], $output))
				throw new Error($rule[1]);
	}
}
class SudoCommandRunner
	extends RegexCommandRunner
{
	private $username;
	function __construct(
		$password, $username = null, $quiet = false, $cacheSize = null,
		$timeout = null, $noOutputTimeout = null, $noInputTimeout = null,
		$maxRepeats = null, $errorQuiet = null  )
	{
		$pattern = '/^\[sudo\].+:[ \t]*\z/m';
		parent::__construct(
			$pattern, null, $quiet, $cacheSize, $timeout, $noOutputTimeout,
			$noInputTimeout, $maxRepeats, $errorQuiet
		);
		$this->addResponseRule($pattern, $password, true);
		$this->username = $username;
	}
	protected function updateCommand(&$command)
	{
		$user = $this->username ?
			' -u ' . escapeshellarg($this->username) :
			'';
		$command = "sudo$user $command";
	}
}
namespace Makeme\Build\Packages\Perl;

class Configuration
	extends \Makeme\Build\Packages\BasicConfiguration
{
	private $ppmPath;
	function __construct(
		Manager $manager, $version, $binaryPath)
	{
		parent::__construct($manager, $version, $binaryPath);
		if (\Makeme\Util\os() == 'windows') {
			$programs =
				\Makeme\File\findExecutable(
					'ppm', dirname($binaryPath)
				);
			if (sizeof($programs))
				$this->ppmPath = $programs[0];
		}
	}
	function ppmPath() { return $this->ppmPath; }
}
namespace Makeme\Build\Packages\Pear;

use Makeme\Build\Packages\Channel;
use Makeme\Build\Packages\Package;
use Makeme\Error;
use Makeme\Log;
use function Makeme\Util\escapeExecutable;
use function Makeme\Util\escapeShellArg;

class Manager extends \Makeme\Build\Packages\Manager {
	const TIMEOUT = 300;
	function __construct()
	{
		parent::__construct();
	}
	function name() { return 'pear'; }
	function dependencies() { return ['php']; }
	function lookupConfigurations(array $properties = [])
	{
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write('Listing PEAR installations');
		$search = isset($properties['binaryPath']) ?
			$properties['binaryPath'] :
			null;
		$programs = \Makeme\File\findExecutable('pear', $search);
		$minVersion = isset($properties['minVersion']) ?
			$properties['minVersion'] :
			null;
		$maxVersion = isset($properties['maxVersion']) ?
			$properties['maxVersion'] :
			null;
		$phpPath = isset($properties['phpPath']) ?
			$properties['phpPath'] :
			null;
		$configs = [];
		foreach ($programs as $p) {
			$version = $this->getVersion($p);
			if ( ($minVersion && version_compare($version, $minVersion)) < 0 ||
				 ($maxVersion && version_compare($version, $maxVersion)) > 0 )
			{
				continue;
			}
			if ($phpPath) {
				$esc = escapeExecutable($p);
				$output = $this->runCommand("$esc config-get php_bin");
				if ( !file_exists($output) ||
					 realpath(dirname($phpPath)) !=
						realpath(dirname($output)) )
				{
					continue;
				}
			}
			$configs[] =
				new Configuration(
						$this, $version, $p
					);
		}

		return $configs;
	}
	function installConfiguration(array $properties = [])
	{
		try {
			if ($str = $this->log()->getStream(Log::VERBOSE))
				$str->write('Installing PEAR');
			$installer = new Installer();
			$pear = $installer->install($properties, true);
			\Makeme\Build\addToPath($pear);
			$config =
				new Configuration(
						$this, $this->getVersion($pear), $pear
					);
			\Makeme\Build\addToIncludePath(
				$config->getConfigurationProperty('php_dir')
			);
			return $config;
		} catch (\Throwable $e) {
			throw new
				Error(
					'Failed installing PEAR: ' . $e->getMessage()
				);
		}
	}
	function uninstallConfiguration(\Makeme\Build\Packages\Configuration $config)
	{
		throw new Error('Not implemented');
	}
	function configurationId(\Makeme\Build\Packages\Configuration $config)
	{
		return $config->binaryPath();
	}
	function lookupChannels(\Makeme\Build\Packages\Configuration $config)
	{
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write("Listing PEAR channels");
		$output = $config->runCommand("list-channels");
		$output = join("\n", array_slice(preg_split('/\n/', $output), 3));
		$match = null;
		$channels = [];
		if (preg_match_all('/^([-_a-zA-Z0-9.]+)/m', $output, $match)) {
			foreach ($match[1] as $ch) {
				$esc = escapeShellArg($ch);
				if ( stripos(
						$config->runCommand("channel-info $esc"),
						'Unknown channel' ) === false )
				{
					$channels[] = new Channel($ch);
				}
			}
		}
		return $channels;
	}
	function installChannel(
		\Makeme\Build\Packages\Configuration $config,
		Channel $channel )
	{
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write(
				"Checking whether PEAR channel '" . $chanel->url() .
				"' is installed"
			);
		$channels = $this->lookupChannels($config);
		foreach ($channels as $ch)
			if ($ch->url() == $channel->url())
				return false;
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write("Installing PEAR channel '" . $channel->url() . "'");
		$esc = escapeShellArg($channel->url());
		$output = $config->runCommand("channel-discover $esc");
		if (stripos($output, 'failed') !== false)
			throw new
				Error(
					"Failed installing channel: pear output: '$output'"
				);

		return true;
	}
	function uninstallChannel(
		\Makeme\Build\Packages\Configuration $config,
		Channel $channel )
	{
		$found = false;
		$channels = $this->lookupChannels($config);
		foreach ($channels as $ch)
			if ($ch->url() == $channel->url()) {
				$found = true;
				break;
			}
		if (!$found)
			return false;
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write("Uninstalling PEAR channel '" . $channel->url() . "'");
		$esc = escapeShellArg($channel->url());
		$output = $config->runCommand("channel-delete $esc");
		if (!preg_match('/channel.*deleted/i', $output))
			throw new
				Error(
					"Failed uninstalling channel: pear output: '$output'"
				);

		return true;
	}
	function lookupPackages(
		\Makeme\Build\Packages\Configuration $config, array $properties = [])
	{
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write('Listing PEAR packages');
		if ( !isset($properties['name']) &&
			 ( isset($properties['minVersion']) ||
			   isset($properties['minVersion']) ) )
		{
			throw new
				Error(
					"Inconsistent properties provided to " .
					"Makeme\Build\Packages\Pear\Manager::lookupPackages(): " .
					"'minVersion' or 'maxVersion' specified without 'name'"
				);
		}
		$name = isset($properties['name']) ?
			$properties['name'] :
			null;
		$minVersion = isset($properties['minVersion']) ?
			$properties['minVersion'] :
			null;
		$maxVersion = isset($properties['maxVersion']) ?
			$properties['maxVersion'] :
			null;
		$channels = null;
		if (isset($properties['channel'])) {
			$channels = $properties['channel'];
		} else {
			foreach ($this->lookupChannels($config) as $ch)
				$channels[] = $ch->url();
		}
		$packages = [];
		foreach ($channels as $ch) {
			$chopt = '-c ' . escapeShellArg($ch);
			$output = $config->runCommand("list $chopt");
			$match = null;
			if ( preg_match_all(
					 '/^([_a-zA-Z0-9]+)\s+([0-9][a-zA-Z0-9.]*)\s+([_a-zA-Z0-9]+)/m',
					  $output,
					  $match,
					  PREG_SET_ORDER ) )
			{
				foreach ($match as $m) {
					if ( (!$name || $name == $m[1]) &&
						 ( $minVersion === null ||
							   version_compare($m[2], $minVersion) >= 0 ) &&
						 ( $maxVersion === null ||
							   version_compare($m[2], $maxVersion) <= 0 ) )
					{
						$package =
							new Package(
									$m[1], $m[2], $ch
								);
						if ($m[3] != 'stable')
							$package->setProperty('state', $m[3]);
						$packages[] = $package;
					}
				}
			}
		}

		return $packages;
	}
	function installPackage(
		\Makeme\Build\Packages\Configuration $config, $name,
		array $properties = [] )
	{
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write("Checking whether PEAR package '$name' is installed");
		$channel = isset($properties['channel']) ?
			 $properties['channel'] :
			null;
		$minVersion = isset($properties['minVersion']) ?
			$properties['minVersion'] :
			null;
		$maxVersion = isset($properties['maxVersion']) ?
			$properties['maxVersion'] :
			null;
		if ($channel && !($channel instanceof Channel))
			throw new
				Error(
					"Invalid 'channel' property provided to " .
					"Makeme\Build\Packages\Pear\Manager::installPackage(): " .
					"expected Makeme\Build\Packages\Channel, found " .
					\Makeme\Util\printScalar($channel)
				);
		$search = $properties;
		$search['name'] = $name;
		if (sizeof($this->lookupPackages($config, $search)))
			return false;
		if (isset($properties['maxVersion'])) {
			$relaxed = $search;
			unset($relaxed['maxVersion']);
			if (sizeof($packages = $this->lookupPackages($config, $relaxed))) {
				$installed = $packages[0]->version();
				throw new
					Error(
						"Failed installing package '$name' with 'maxVersion' " .
						"{$properties['maxVersion']}: installed version " .
						"'$installed' is too new"
					);
			}
		}
		$upgrade = false;
		if (isset($properties['minVersion'])) {
			$relaxed = $search;
			unset($relaxed['minVersion']);
			$upgrade = sizeof($this->lookupPackages($config, $relaxed)) > 0;
		}
		if ($channel)
			$this->installChannel($config, $channel);
		$binary = escapeExecutable($config->binaryPath());
		$pecl =
			isset($properties['pecl']) &&
			($properties['pecl'] == 'true' || $properties['pecl'] == '1');
		if ($pecl)
			$binary =
				preg_replace(
					'/pear([.a-z]*)$/i', 'pecl$1', $config->binaryPath()
				);
		if ($pecl) {
			$php = $config->getConfigurationProperty('php_bin');
			$command =
				escapeExecutable($php) .
				' -r "echo get_cfg_var(\'cfg_file_path\');"';
			$ini = $this->runCommand($command);
			$config->setConfigurationProperty('php_ini', $ini);
		}
		$command = $upgrade ? 'upgrade' : 'install';
		$description = $upgrade ? 'upgrading' : 'installing';
		$prefix = $channel ? "$channel/" : '';
		$package = escapeShellArg("$prefix$name");
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write(ucfirst($description) . " PEAR package '$name");
		$this->runUnattended("$binary $command --onlyreqdeps $package");
		if (!sizeof($this->lookupPackages($config, $search)))
				throw new
					Error(
						"Failed $description package '$name'"
					);

		return true;
	}
	function uninstallPackage(
		\Makeme\Build\Packages\Configuration $config,
		Package $package )
	{
		$name = $package->name();
		$properties = ['name' => $name];
		if ($package->channel())
			$properties['channel'] = $package->channel();
		if (sizeof($this->lookupPackages($config, $properties)))
			return false;
		$prefix = $channel ? "$channel/" : '';
		$esc = escapeShellArg("$prefix$name");
		$output = $config->runCommand("uninstall $esc");
		if (stripos($output, 'uninstall ok') === false)
			throw new
				Error(
					"Failed uninstalling package '$name': pear output: " .
					$output
				);

		return true;
	}
	function getConfigurationProperty(
		\Makeme\Build\Packages\Configuration $config, $name)
	{
		$esc = escapeShellArg($name);
		$output = $config->runCommand("config-get $esc");
		return trim($output);
	}
	function setConfigurationProperty(
		\Makeme\Build\Packages\Configuration $config, $name, $value)
	{
		$old = $this->getConfigurationProperty($config, $name);
		if ($name == $value)
			return false;
		$n = escapeShellArg($name);
		$v = escapeShellArg($value);
		$output = $config->runCommand("config-set $n $v");
		return stripos($output, 'failed') === false;
	}
	private function getVersion($binaryPath)
	{
		ob_start();
		$status = null;
		passthru("$binaryPath version 2>&1", $status);
		$output = ob_get_contents();
		ob_end_clean();
		if (preg_match('/PEAR Version:[ \t]+([0-9.]+)/', $output, $match)) {
			return $match[1];
		} else {
			throw new
				Error(
					"Failed determining PEAR version for '$binaryPath'"
				);
		}
	}
	private function runUnattended($command)
	{
		if ($str = $this->log()->getStream(Log::VERBOSE))
			$str->write("Running command '$command'");
		if (\Makeme\Util\os() == 'windows') {
			\Makeme\Util\system($command);
		} else {
			$runner =
				new \Makeme\Util\RegexCommandRunner([
						'requiresResponse' => '/./',
						'defaultResponse' => "\n",
						'quiet' => false,
						'timeout' => self::TIMEOUT
					]);
			$status = $runner->run($command);
			if ($status)
				throw new
					Error(
						"Exit status $status returned by command '$command'"
					);
		}
	}
}
namespace Makeme\Build\Packages\Pear;

use Makeme\Error;
use function Makeme\Util\os;

class Installer {
	const GOPEAR_URL = 'http://pear.php.net/go-pear';
	private $config;
	private $quiet;
	private $log;
	private $gopear;
	private $firstMenu;
	static private $instance;
	function __construct() { }
	function install($config, $quiet = false)
	{
		if (!isset($config['prefix']))
			throw new Error('Must specify installation prefix');
		if (!isset($config['bin_dir']))
			$config['bin_dir'] = os() == 'windows' ?
				$config['prefix'] :
				"{$config['prefix']}/bin";
		foreach ($config as $n => $v)
			if (!\Makeme\File\isAbsolute($v))
				throw new
					Error("'$n' must be an absolute path; '$v' given");
		$this->config = $config;
		$this->quiet = $quiet;
		$this->log = '';
		$this->firstMenu = true;
		$this->gopear = \Makeme\File\temp();
		$this->getGopear();
		$this->patchGopear();
		$this->includeGopear();
		$pear = $config['bin_dir'] .
			( os() == 'windows' ?
				  '\pear.bat' :
				  '/pear' );
		if (!file_exists($pear))
			throw new Error("Failed installing 'pear' executable");
		return realpath($pear);
	}
	function instance()
	{
		return self::$instance;
	}

					/*
					 * Private methods
					 */
	private function getGopear()
	{
		$url = self::GOPEAR_URL;
		$contents = @file_get_contents($url);
		if ($contents === false)
			throw new Error("Failed downloading url '$url'");
		if (!@file_put_contents($this->gopear, $contents))
			throw new Error("Failed writing to file '$this->gopear'");
	}
	private function patchGopear()
	{
		$contents = null;
		if (($contents = @file_get_contents($this->gopear)) === false)
			throw new Error("Failed reading file '$this->gopear'");
		$match = null;
		preg_match('/(.*?)\bfunction\s+([_a-zA-Z0-9]+)/s', $contents, $match);
		preg_match_all('/(\$[_a-zA-Z0-9]+)/', $match[1], $match);
		$vars = [];
		foreach ($match[1] as $v)
			if (!isset($vars[$v]))
				$vars[$v] = 1;
		$contents =
			preg_replace(
				'/^\s*<\?php/',
				"<?php global " . join(", ", array_keys($vars)) . ";\n",
				$contents
			);
		$contents =
			preg_replace(
				'/fgets\(\$tty,\s*[0-9]+\)/',
				'Makeme\Build\Packages\Pear\Installerfgets()',
				$contents
			);
		$match = null;
		preg_match_all(
			'/function\s+([_a-zA-Z0-9]+)\s*\(/i',
			$contents,
			$match
		);
		$patterns = [];
		$replacements = [];
		foreach ($match[1] as $f) {
			$patterns[] = '/\b' . $f . '\(/';
			$replacements[] =
				"Makeme\\Build\\Packages\\Pear\\Installer$f(";
		}
		$contents = preg_replace($patterns, $replacements, $contents);
		$contents =
			preg_replace(
				'/\bprint\s*\(([^;]+)\);/',
				'Makeme\Build\Packages\Pear\Installerprint($1);',
				$contents
			);
		$contents =
			preg_replace(
				'/\bprint\s+\'([^;]+)\';/',
				'Makeme\Build\Packages\Pear\Installerprint(\'$1\');',
				$contents
			);
		$contents =
			preg_replace(
				'/\bprint\s+"([^;]+)";/',
				'Makeme\Build\Packages\Pear\Installerprint("$1");',
				$contents
			);
		$contents =
			preg_replace(
				'/\bprint\s+([^;]+);/',
				'Makeme\Build\Packages\Pear\Installerprint($1);',
				$contents
			);
		$contents =
			preg_replace(
				'/\becho\s*\(([^;]+)\);/',
				'Makeme\Build\Packages\Pear\Installerprint($1);',
				$contents
			);
		$contents =
			preg_replace(
				'/\becho\s+\'([^;]+)\';/',
				'Makeme\Build\Packages\Pear\Installerprint(\'$1\');',
				$contents
			);
		$contents =
			preg_replace(
				'/\becho\s+"([^;]+)";/',
				'Makeme\Build\Packages\Pear\Installerprint("$1");',
				$contents
			);
		$contents =
			preg_replace(
				'/\becho\s+([^;]+[")]);\n/',
				"Makeme\Build\Packages\Pear\Installerprint(\$1);\n",
				$contents
			);
		$contents =
			preg_replace(
				'/\bprintf\b/',
				'Makeme\Build\Packages\Pear\Installerprintf',
				$contents
			);
		$contents =
			preg_replace(
				'/\bmkdir\b/',
				'Makeme\Build\Packages\Pear\Installermkdir',
				$contents
			);
		$contents =
			preg_replace(
				'/\bregister_shutdown_function\b/',
				'Makeme\Build\Packages\Pear\Installerregister_shutdown_function',
				$contents
			);

		if (!@file_put_contents($this->gopear, $contents))
			throw new Error("Failed writing to file '$this->gopear'");
	}
	private function includeGopear()
	{
		if ($this->quiet)
			ob_start();
		set_error_handler(
			['Makeme\Build\Packages\Pear\Installer', 'handleError']);
		$globals = $GLOBALS;
		$ini = ini_get_all();
		self::$instance = $this;
		try {
			include($this->gopear);
		} catch (\Throwable $e) {
			if ($this->quiet)
				ob_end_clean();
			restore_error_handler();
			$this->restoreGlobals($globals);
			$this->restoreIni($ini);
			self::$instance = null;
			throw $e;
		}
		if ($this->quiet)
			ob_end_clean();
		restore_error_handler();
		$this->restoreGlobals($globals);
		$this->restoreIni($ini);
		self::$instance = null;
	}
	private function writeTty($s)
	{
		$this->print_($s);
		return $s;
	}
	private function restoreGlobals($globals)
	{
		foreach ($GLOBALS as $n => $v)
			if (!isset($globals[$n]))
				unset($GLOBALS[$n]);
		foreach ($globals as $n => $v)
			$GLOBALS[$n] = $v;
	}
	private function restoreIni($ini)
	{
		$INI = ini_get_all();
		foreach ($INI as $n => $triple)
			if (!isset($ini[$n]))
				@ini_restore($n);
		foreach ($ini as $n => $triple)
			if ($ini[$n]['local_value'] !== $INI[$n]['local_value'])
				@ini_set($n, $ini[$n]['local_value']);
	}

					/*
					 * Error handler
					 */
	function handleError($errno, $errstr, $errfile, $errline)
	{
		if ($errno & (E_USER_ERROR | E_USER_WARNING)) {
			$label = ($errno & E_USER_ERROR) ? 'Error' : 'Warning';
			throw new
				Error(
					"$label: $errstr in file '$errfile' at line $line"
				);
		}
	}

					/*
					 * Replacements for built-in functions
					 */
	function print_($s)
	{
		print $s;
		$this->log .= $s;
		return 1;
	}
	function printf(array $args)
	{
		$s = call_user_func_array('sprintf', $args);
		$this->print_($s);
		return strlen($s);
	}
	function fgets()
	{
		$last = null;
		foreach (array_reverse(preg_split('/\n/', $this->log)) as $line)
			if ($line) {
				$last = $line;
				break;
			}
		if (stripos($last, 'HTTP proxy') !== false) {
			$result = isset($this->config['http_proxy']) ?
				$this->config['http_proxy'] . "\n" :
				"\n";
			return $this->writeTty($result);
		}
		global $config_desc;
		if ($this->firstMenu && stripos($last, "'all' or Enter") !== false) {
			$this->firstMenu = false;
			$result =
				array_intersect_key($this->config, $config_desc) ?
					"all\n" :
					"\n";
			return $this->writeTty($result);
		}
		foreach ($config_desc as $name => $desc)
			if (stripos($last, $desc) !== false) {
				$result = isset($this->config[$name]) ?
					$this->config[$name] . "\n" :
					"\n";
				return $this->writeTty($result);
			}
		$result = stripos($line, '[Y/n]') !== false ?
			"n" :
			"\n";
		return $this->writeTty($result);
	}
}

					/* Supporting functions */

function Installerregister_shutdown_function($s)
{
	return @register_shutdown_function("Makeme\\Build\\Packages\\Pear\\Installer$s");
}

function Installermkdir($s)
{
	return !file_exists($s) ? @mkdir($s) : true;
}

function Installerprint($s)
{
	return Installer::instance()->print_($s);
}

function Installerprintf()
{
	$args = func_get_args();
	return Installer::instance()->printf($args);
}

function Installerfgets()
{
	return Installer::instance()->fgets();
}
namespace Makeme\Build\Packages\Pear;

class Configuration
	extends \Makeme\Build\Packages\BasicConfiguration
{
	function __construct(
		Manager $manager, $version, $binaryPath)
	{
		parent::__construct($manager, $version, $binaryPath);
	}
}
namespace Makeme\Build\Packages;

class Channel extends \Makeme\Util\BasicProperties {
	private $url;
	private $username;
	private $password;
	function __construct($url, $username = null, $password = null)
	{
		parent::__construct();
		$this->url = $url;
		$this->username = $username;
		$this->password = $password;
	}
	function url() { return $this->url; }
	function username() { return $this->username; }
	function password() { return $this->password; }
}

if (\Makeme\Build\isBootstrapping()) {
	\Makeme\Build\updateIncludePath();
	$driver = \Makeme\File\searchIncludePath('CodeRage/Build/driver.php');
	if ($driver)
		include($driver);
}

$run = new \Makeme\Build\Run;
$success = $run->execute();
exit($success ? 0 : 1);


?>
